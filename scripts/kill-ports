#!/usr/bin/env node

/**
 * Kill Dev - Development Process Terminator (Standalone Version)
 * 
 * A dependency-free utility to hunt down and terminate stubborn development processes
 * running on common ports used by Next.js, React, Vite, and other dev servers.
 * 
 * Features:
 * - Zero external dependencies - uses only Node.js built-ins
 * - Scans default development ports (3000-3010, 5000-5005, 5173-5183)
 * - Interactive process selection
 * - Supports port ranges and individual port specification
 * - Cross-platform support (Linux, macOS, Windows)
 * - Enhanced CLI with loading spinners and colored output
 * 
 * Usage:
 *   ./kill-ports                    # Scan default ports
 *   ./kill-ports 3000              # Scan specific port
 *   ./kill-ports 3000 8080         # Scan multiple ports
 *   ./kill-ports 3000-3005         # Scan port range
 *   ./kill-ports --help            # Show help
 * 
 * Author: Remco Stoeten
 */

const { exec, spawn } = require('child_process');
const { promisify } = require('util');
const readline = require('readline');
const fs = require('fs');
const os = require('os');
const path = require('path');

const execAsync = promisify(exec);

// ANSI color codes for terminal output
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  dim: '\x1b[2m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
  white: '\x1b[37m',
  gray: '\x1b[90m',
  bgRed: '\x1b[41m',
  bgGreen: '\x1b[42m',
  bgYellow: '\x1b[43m',
  bgBlue: '\x1b[44m',
  bgMagenta: '\x1b[45m',
  bgCyan: '\x1b[46m'
};

// Helper functions for colored output
const chalk = {
  red: (text) => `${colors.red}${text}${colors.reset}`,
  green: (text) => `${colors.green}${text}${colors.reset}`,
  yellow: (text) => `${colors.yellow}${text}${colors.reset}`,
  blue: (text) => `${colors.blue}${text}${colors.reset}`,
  magenta: (text) => `${colors.magenta}${text}${colors.reset}`,
  cyan: (text) => `${colors.cyan}${text}${colors.reset}`,
  white: (text) => `${colors.white}${text}${colors.reset}`,
  gray: (text) => `${colors.gray}${text}${colors.reset}`,
  bold: (text) => `${colors.bright}${text}${colors.reset}`,
  dim: (text) => `${colors.dim}${text}${colors.reset}`
};

// Configuration
const CONFIG_DIR = path.join(os.homedir(), '.killdevports');
const CONFIG_FILE = path.join(CONFIG_DIR, 'config.json');

const DEFAULT_CONFIG = {
  ports: {
    nextjs: Array.from({ length: 11 }, (_, i) => 3000 + i),
    generic: Array.from({ length: 6 }, (_, i) => 5000 + i),
    vite: Array.from({ length: 11 }, (_, i) => 5173 + i),
    custom: [4000, 4001]
  }
};

// Global options
let globalOptions = {
  verbose: false,
  dryRun: false,
  force: false,
  json: false,
  killAll: false
};

// Spinner characters and states
const spinnerFrames = ['⠋', '⠙', '⠹', '⠸', '⠼', '⠴', '⠦', '⠧', '⠇', '⠏'];
let spinnerIndex = 0;

/**
 * Simple spinner implementation
 */
class Spinner {
  constructor(text = '') {
    this.text = text;
    this.isSpinning = false;
    this.interval = null;
  }

  start() {
    if (this.isSpinning || globalOptions.json) return;
    this.isSpinning = true;
    process.stdout.write('\x1b[?25l'); // Hide cursor
    
    this.interval = setInterval(() => {
      process.stdout.write(`\r${colors.cyan}${spinnerFrames[spinnerIndex]} ${this.text}${colors.reset}`);
      spinnerIndex = (spinnerIndex + 1) % spinnerFrames.length;
    }, 80);
  }

  stop() {
    if (!this.isSpinning) return;
    this.isSpinning = false;
    
    if (this.interval) {
      clearInterval(this.interval);
      this.interval = null;
    }
    
    process.stdout.write('\r\x1b[K'); // Clear line
    process.stdout.write('\x1b[?25h'); // Show cursor
  }

  succeed(message) {
    this.stop();
    if (!globalOptions.json) {
      console.log(`${colors.green}✓ ${message}${colors.reset}`);
    }
  }

  fail(message) {
    this.stop();
    if (!globalOptions.json) {
      console.log(`${colors.red}✗ ${message}${colors.reset}`);
    }
  }

  updateText(newText) {
    this.text = newText;
  }
}

/**
 * Load configuration from file
 */
function loadConfig() {
  try {
    if (fs.existsSync(CONFIG_FILE)) {
      const userConfig = JSON.parse(fs.readFileSync(CONFIG_FILE, 'utf8'));
      return { ...DEFAULT_CONFIG, ...userConfig };
    }
  } catch (error) {
    if (globalOptions.verbose) {
      console.warn(chalk.yellow(`⚠️  Warning: Could not load config file: ${error.message}`));
    }
  }
  return DEFAULT_CONFIG;
}

/**
 * Get default ports from configuration
 */
function getDefaultPorts() {
  const config = loadConfig();
  return [
    ...config.ports.nextjs,
    ...config.ports.generic,
    ...config.ports.vite,
    ...config.ports.custom
  ];
}

/**
 * Display help information
 */
function showHelp() {
  const pkg = { version: '1.0.0', license: 'MIT' };
  
  console.log(chalk.cyan(`
██╗  ██╗██╗██╗     ██╗         ██████╗ ███████╗██╗   ██╗
██║ ██╔╝██║██║     ██║         ██╔══██╗██╔════╝██║   ██║
█████╔╝ ██║██║     ██║         ██║  ██║█████╗  ██║   ██║
██╔═██╗ ██║██║     ██║         ██║  ██║██╔══╝  ╚██╗ ██╔╝
██║  ██╗██║███████╗███████╗    ██████╔╝███████╗ ╚████╔╝ 
╚═╝  ╚═╝╚═╝╚══════╝╚══════╝    ╚═════╝ ╚══════╝  ╚═══╝  
`));
  
  console.log(chalk.magenta(`            Process Port Terminator ${chalk.yellow(`v${pkg.version}`)}`));
  console.log(chalk.gray('                    by @remcostoeten'));
  
  const helpContent = `
${chalk.bold('USAGE:')}
  ${chalk.cyan('kill-ports [options] [ports...]')}
  ${chalk.cyan('kill-ports ports <port-list>')}

${chalk.bold('OPTIONS:')}
  ${chalk.green('-h, --help')}       Show this help message
  ${chalk.green('-v, --version')}    Show version number
  ${chalk.green('-a, --all')}        Kill all default development ports without prompts
  ${chalk.green('--verbose')}        Enable verbose logging
  ${chalk.green('--dry-run')}        Show what would be killed without actually killing
  ${chalk.green('--force')}          Skip confirmation prompts
  ${chalk.green('--json')}           Output results in JSON format

${chalk.bold('EXAMPLES:')}
  ${chalk.yellow('kill-ports')}              Scan all default development ports
  ${chalk.yellow('kill-ports --all')}        Kill all default ports without prompts
  ${chalk.yellow('kill-ports -a')}           Kill all default ports (short form)
  ${chalk.yellow('kill-ports 3000')}         Kill processes on port 3000
  ${chalk.yellow('kill-ports 3000 8080')}    Kill processes on multiple ports
  ${chalk.yellow('kill-ports 3000-3005')}    Kill processes on port range
  ${chalk.yellow('kill-ports --3000+')}      Kill processes on ports 3000-3010
  ${chalk.yellow('kill-ports ports 3000')}   Kill processes on port 3000 (no prompts)
  ${chalk.yellow('kill-ports ports 3000,4000,5173')} Kill processes on multiple ports
  ${chalk.yellow('kill-ports --dry-run')}    Preview what would be killed
  ${chalk.yellow('kill-ports --force 3000')} Kill without confirmation

${chalk.bold('DEFAULT PORTS:')}
  ${chalk.magenta('Next.js/React:')} 3000-3010
  ${chalk.magenta('Generic dev:')}   5000-5005
  ${chalk.magenta('Vite:')}          5173-5183
  ${chalk.magenta('Custom:')}        4000, 4001

${chalk.bold('INTERACTIVE CONTROLS:')}
  ${chalk.cyan('Enter')}         Confirm selection
  ${chalk.cyan('Ctrl+C')}        Exit application
  ${chalk.cyan('y/n')}           Yes/No responses

${chalk.gray('─'.repeat(60))}
Documentation: https://github.com/remcostoeten/kill-development-ports
Version: ${pkg.version} | License: ${pkg.license}
`;
  
  console.log(helpContent);
}

/**
 * Parse command-line arguments
 */
function parseArguments(args) {
  // Check for help flags
  if (args.includes('-h') || args.includes('--help')) {
    showHelp();
    process.exit(0);
  }
  
  // Check for version flag
  if (args.includes('-v') || args.includes('--version')) {
    console.log('Kill Dev v1.0.0\n');
    process.exit(0);
  }
  
  // Parse global options
  globalOptions.verbose = args.includes('--verbose');
  globalOptions.dryRun = args.includes('--dry-run');
  globalOptions.force = args.includes('--force') || args.includes('-a') || args.includes('--all');
  globalOptions.json = args.includes('--json');
  globalOptions.killAll = args.includes('-a') || args.includes('--all');
  
  // If --all or -a is used, return default ports and set force mode
  if (globalOptions.killAll) {
    return getDefaultPorts();
  }
  
  // Check for 'ports' command with port specifications
  const portsIndex = args.indexOf('ports');
  if (portsIndex !== -1 && portsIndex < args.length - 1) {
    // Handle 'ports' command - force mode and parse following arguments
    globalOptions.force = true;
    const portSpecs = args.slice(portsIndex + 1).filter(arg => !arg.startsWith('-'));
    const ports = new Set();
    
    for (const spec of portSpecs) {
      if (spec.includes(',')) {
        // Handle comma-separated ports (e.g., "5173,5174,3001,4515")
        const portList = spec.split(',').map(p => p.trim());
        for (const portStr of portList) {
          const port = parseInt(portStr, 10);
          if (!isNaN(port) && port > 0 && port <= 65535) {
            ports.add(port);
          } else {
            console.warn(chalk.yellow(`⚠️  Invalid port '${portStr}' in list. Skipping.`));
          }
        }
      } else {
        // Handle single port (e.g., "3000")
        const port = parseInt(spec, 10);
        if (!isNaN(port) && port > 0 && port <= 65535) {
          ports.add(port);
        } else {
          console.warn(chalk.yellow(`⚠️  Invalid port '${spec}'. Skipping.`));
        }
      }
    }
    
    return Array.from(ports);
  }
  
  // Filter out option flags to get only port arguments, but keep --<port>+ patterns
  const portArgs = args.filter(arg => {
    if (arg.startsWith('--') && arg.endsWith('+')) return true;
    return !arg.startsWith('--') && !arg.startsWith('-');
  });
  
  if (portArgs.length === 0) return getDefaultPorts();
  
  const ports = new Set();
  for (const arg of portArgs) {
    if (arg.startsWith('--') && arg.endsWith('+')) {
      // Handle --<port>+ syntax (e.g., "--3000+" becomes 3000-3010) - enable force mode
      globalOptions.force = true;
      const portStr = arg.slice(2, -1); // Remove -- and +
      const port = parseInt(portStr, 10);
      if (!isNaN(port) && port > 0 && port <= 65525) { // Ensure port+10 doesn't exceed 65535
        for (let i = port; i <= port + 10; i++) {
          ports.add(i);
        }
      } else {
        console.warn(chalk.yellow(`⚠️  Invalid port range '${arg}'. Skipping.`));
      }
    } else if (arg.includes('-')) {
      // Handle port ranges (e.g., "3000-3005")
      const [startStr, endStr] = arg.split('-');
      const start = parseInt(startStr, 10);
      const end = parseInt(endStr, 10);
      if (!isNaN(start) && !isNaN(end) && start <= end && start > 0 && end <= 65535) {
        for (let i = start; i <= end; i++) {
          ports.add(i);
        }
      } else {
        console.warn(chalk.yellow(`⚠️  Invalid port range '${arg}'. Skipping.`));
      }
    } else {
      // Handle single ports
      const port = parseInt(arg, 10);
      if (!isNaN(port) && port > 0 && port <= 65535) {
        ports.add(port);
      } else {
        console.warn(chalk.yellow(`⚠️  Invalid port '${arg}'. Skipping.`));
      }
    }
  }
  return Array.from(ports);
}

/**
 * Find processes running on a specific port
 */
async function findProcessesByPort(port) {
  try {
    let cmd;
    
    if (process.platform === 'win32') {
      cmd = `netstat -ano | findstr :${port}`;
    } else {
      // Try lsof first, then ss, then netstat
      try {
        await execAsync('which lsof');
        cmd = `lsof -ti :${port}`;
      } catch {
        try {
          await execAsync('which ss');
          cmd = `ss -tlnp | grep :${port}`;
        } catch {
          cmd = `netstat -tlnp | grep :${port}`;
        }
      }
    }
    
    const { stdout } = await execAsync(cmd, { timeout: 5000 });
    
    if (!stdout.trim()) {
      return null;
    }
    
    if (process.platform === 'win32') {
      return parseWindowsNetstat(stdout, port);
    } else {
      return parseUnixOutput(stdout, port, cmd);
    }
  } catch (error) {
    if (globalOptions.verbose) {
      console.warn(chalk.yellow(`⚠️  Error scanning port ${port}: ${error.message}`));
    }
    return null;
  }
}

/**
 * Parse Windows netstat output
 */
function parseWindowsNetstat(stdout, port) {
  const lines = stdout.trim().split('\n');
  const processes = new Set();
  
  for (const line of lines) {
    const parts = line.trim().split(/\s+/);
    if (parts.length >= 5) {
      const pid = parseInt(parts[4], 10);
      if (!isNaN(pid)) {
        processes.add(pid);
      }
    }
  }
  
  if (processes.size === 0) return null;
  
  return Array.from(processes).map(pid => ({
    pid,
    name: 'unknown', // We'll get the name later if needed
    port
  }));
}

/**
 * Parse Unix command output (lsof, ss, netstat)
 */
async function parseUnixOutput(stdout, port, cmd) {
  const lines = stdout.trim().split('\n');
  const processes = [];
  
  for (const line of lines) {
    if (cmd.includes('lsof')) {
      // lsof output is just PIDs
      const pid = parseInt(line.trim(), 10);
      if (!isNaN(pid)) {
        const name = await getProcessName(pid);
        processes.push({ pid, name, port });
      }
    } else if (cmd.includes('ss')) {
      // ss output: extract from users:((name,pid=12345,fd=...))
      const userMatch = line.match(/users:\(\("([^"]+)",pid=(\d+),/);
      if (userMatch) {
        const name = userMatch[1];
        const pid = parseInt(userMatch[2], 10);
        if (!isNaN(pid)) {
          processes.push({ pid, name, port });
        }
      }
    } else {
      // netstat output: extract PID/name from last column
      const parts = line.trim().split(/\s+/);
      const lastPart = parts[parts.length - 1];
      if (lastPart && lastPart.includes('/')) {
        const [pidStr, name] = lastPart.split('/');
        const pid = parseInt(pidStr, 10);
        if (!isNaN(pid)) {
          processes.push({ pid, name, port });
        }
      }
    }
  }
  
  return processes.length > 0 ? processes : null;
}

/**
 * Get process name by PID
 */
async function getProcessName(pid) {
  try {
    if (process.platform === 'win32') {
      const { stdout } = await execAsync(`tasklist /FI "PID eq ${pid}" /FO CSV /NH`);
      const match = stdout.match(/"([^"]+)"/);
      return match ? match[1] : 'unknown';
    } else {
      const { stdout } = await execAsync(`ps -p ${pid} -o comm=`);
      return stdout.trim() || 'unknown';
    }
  } catch {
    return 'unknown';
  }
}

/**
 * Kill process by PID
 */
async function killProcess(pid) {
  try {
    const cmd = process.platform === 'win32'
      ? `taskkill /PID ${pid} /F`
      : `kill -9 ${pid}`;
    
    await execAsync(cmd);
    return true;
  } catch {
    return false;
  }
}

/**
 * Create a simple table display
 */
function createTable(headers, rows) {
  const colWidths = headers.map((header, i) => {
    const maxWidth = Math.max(
      header.length,
      ...rows.map(row => String(row[i] || '').length)
    );
    return Math.max(maxWidth, 8); // Minimum width of 8
  });
  
  // Top border
  const topBorder = '┌' + colWidths.map(w => '─'.repeat(w + 2)).join('┬') + '┐';
  
  // Header
  const headerRow = '│' + headers.map((header, i) => 
    ` ${chalk.bold(header.padEnd(colWidths[i]))} `
  ).join('│') + '│';
  
  // Header separator
  const headerSep = '├' + colWidths.map(w => '─'.repeat(w + 2)).join('┼') + '┤';
  
  // Data rows
  const dataRows = rows.map(row => 
    '│' + row.map((cell, i) => 
      ` ${String(cell || '').padEnd(colWidths[i])} `
    ).join('│') + '│'
  );
  
  // Bottom border
  const bottomBorder = '└' + colWidths.map(w => '─'.repeat(w + 2)).join('┴') + '┘';
  
  return [topBorder, headerRow, headerSep, ...dataRows, bottomBorder].join('\n');
}

/**
 * Prompt user for input
 */
function prompt(question) {
  return new Promise((resolve) => {
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });
    
    rl.question(question, (answer) => {
      rl.close();
      resolve(answer.trim());
    });
  });
}

/**
 * Prompt user for confirmation
 */
async function confirm(message, defaultValue = false) {
  const defaultText = defaultValue ? 'Y/n' : 'y/N';
  const answer = await prompt(`${message} (${defaultText}): `);
  
  if (answer === '') return defaultValue;
  return ['y', 'yes', '1', 'true'].includes(answer.toLowerCase());
}

/**
 * Multi-select prompt (simplified)
 */
async function multiSelect(message, choices) {
  console.log(`\n${message}`);
  console.log(chalk.dim('Enter the numbers of processes to select (comma-separated), or "all" for all:'));
  
  choices.forEach((choice, index) => {
    console.log(`  ${chalk.yellow((index + 1).toString().padStart(2))}. ${choice.name}`);
  });
  
  const answer = await prompt('\nSelection: ');
  
  if (answer.toLowerCase() === 'all') {
    return choices.map(c => c.value);
  }
  
  const indices = answer.split(',')
    .map(s => parseInt(s.trim(), 10) - 1)
    .filter(i => i >= 0 && i < choices.length);
  
  return indices.map(i => choices[i].value);
}

/**
 * Output JSON data
 */
function outputJSON(data) {
  console.log(JSON.stringify(data, null, 2));
}

/**
 * Verbose logging
 */
function verboseLog(message, ...args) {
  if (globalOptions.verbose && !globalOptions.json) {
    console.log(chalk.dim(`[VERBOSE] ${message}`), ...args);
  }
}

/**
 * Main function
 */
async function main() {
  const args = process.argv.slice(2);
  const ports = parseArguments(args);
  
  verboseLog('Parsed ports:', ports);
  verboseLog('Active options:', globalOptions);

  // Skip header for JSON output
  if (!globalOptions.json) {
    const asciiTitle = chalk.cyan(`
██╗  ██╗██╗██╗     ██╗         ██████╗ ███████╗██╗   ██╗
██║ ██╔╝██║██║     ██║         ██╔══██╗██╔════╝██║   ██║
█████╔╝ ██║██║     ██║         ██║  ██║█████╗  ██║   ██║
██╔═██╗ ██║██║     ██║         ██║  ██║██╔══╝  ╚██╗ ██╔╝
██║  ██╗██║███████╗███████╗    ██████╔╝███████╗ ╚████╔╝ 
╚═╝  ╚═╝╚═╝╚══════╝╚══════╝    ╚═════╝ ╚══════╝  ╚═══╝  
`);
    
    const subtitle = chalk.magenta('            Kill Dev - ') + chalk.red('🎯') + chalk.magenta(' v') + chalk.yellow('1.0.0') + chalk.magenta(' - by ') + chalk.green('@remcostoeten');
    const separator = chalk.gray('═'.repeat(65));
    
    console.log(separator);
    console.log(asciiTitle);
    console.log(subtitle);
    console.log(separator);
    
    // Show active options if verbose
    if (globalOptions.verbose) {
      const activeOptions = [];
      if (globalOptions.dryRun) activeOptions.push(chalk.yellow('DRY-RUN'));
      if (globalOptions.force) activeOptions.push(chalk.red('FORCE'));
      if (globalOptions.verbose) activeOptions.push(chalk.blue('VERBOSE'));
      if (globalOptions.json) activeOptions.push(chalk.green('JSON'));
      
      if (activeOptions.length > 0) {
        console.log(chalk.dim(`\n[OPTIONS] ${activeOptions.join(' | ')}\n`));
      }
    }
  }

  // Enhanced scanning with spinner
  const scanSpinner = new Spinner(`Scanning ${ports.length} port(s): ${ports.slice(0, 5).join(', ')}${ports.length > 5 ? '...' : ''}`);
  scanSpinner.start();

  // Find processes on all ports
  const allProcesses = [];
  for (let i = 0; i < ports.length; i++) {
    const port = ports[i];
    if (globalOptions.verbose) {
      scanSpinner.updateText(`Scanning port ${port} (${i + 1}/${ports.length})`);
    }
    
    const processes = await findProcessesByPort(port);
    if (processes) {
      allProcesses.push(...processes);
    }
  }
  
  scanSpinner.succeed(`Scan completed on ${ports.length} port(s)`);
  
  verboseLog(`Found ${allProcesses.length} active processes`);

  // Handle JSON output
  if (globalOptions.json) {
    const jsonData = {
      timestamp: new Date().toISOString(),
      ports_scanned: ports,
      processes_found: allProcesses.length,
      processes: allProcesses,
      options: globalOptions
    };
    outputJSON(jsonData);
    return;
  }

  if (allProcesses.length === 0) {
    console.log(`\n${chalk.gray('▪')} No active processes found on the specified ports.`);
    console.log(`${chalk.gray('▪')} All ports appear to be free.\n`);
    return;
  }

  // Display found processes in a table
  console.log(`\n${chalk.bold('◆')} Found ${chalk.bold(allProcesses.length)} active process(es):\n`);
  
  const tableData = allProcesses.map(proc => [
    proc.port.toString(),
    proc.pid.toString(),
    proc.name
  ]);
  
  const table = createTable(['PORT', 'PID', 'PROCESS NAME'], tableData);
  console.log(table);

  try {
    let selectedProcesses;
    
    if (globalOptions.force) {
      // Force mode: select all processes automatically
      selectedProcesses = allProcesses;
      verboseLog('Force mode enabled - selecting all processes');
    } else {
      // Interactive mode: prompt user to select processes
      const choices = allProcesses.map(proc => ({
        name: `Port ${proc.port} (${proc.name}) - PID: ${proc.pid}`,
        value: proc
      }));
      
      const message = globalOptions.dryRun ? 'Select processes to preview (DRY RUN):' : 'Select processes to kill:';
      selectedProcesses = await multiSelect(message, choices);
    }

    if (selectedProcesses.length === 0) {
      console.log('No processes selected. Exiting.');
      return;
    }

    // Dry run mode
    if (globalOptions.dryRun) {
      console.log(chalk.yellow('\n📋 DRY RUN MODE - No processes will actually be killed\n'));
      
      const dryRunData = selectedProcesses.map(proc => [
        chalk.red('WOULD KILL'),
        proc.port.toString(),
        proc.pid.toString(),
        proc.name
      ]);
      
      const dryRunTable = createTable(['ACTION', 'PORT', 'PID', 'PROCESS'], dryRunData);
      console.log(dryRunTable);
      
      console.log(`\n${chalk.yellow('⚠️')} ${selectedProcesses.length} process(es) would be terminated.`);
      console.log(chalk.dim('Run without --dry-run to actually kill these processes.\n'));
      return;
    }

    // Skip confirmation for force mode (--all, -a, ports command, --force)
    if (!globalOptions.force) {
      const confirmKill = await confirm(`Are you sure you want to kill ${selectedProcesses.length} process(es)?`, false);
      
      if (!confirmKill) {
        console.log('Operation cancelled.');
        return;
      }
    }

    console.log(`\n${globalOptions.force ? '⚡ Force killing' : 'Attempting to terminate'} selected processes...\n`);
    let successCount = 0;

    for (let i = 0; i < selectedProcesses.length; i++) {
      const proc = selectedProcesses[i];
      const spinner = new Spinner(`Terminating process on port ${proc.port} (PID: ${proc.pid}) [${i + 1}/${selectedProcesses.length}]`);
      spinner.start();
      
      const success = await killProcess(proc.pid);
      
      if (success) {
        spinner.succeed(`Terminated process (PID: ${proc.pid}) on port ${proc.port}`);
        successCount++;
      } else {
        spinner.fail(`Failed to terminate process (PID: ${proc.pid}) on port ${proc.port}`);
      }
      
      // Small delay between kills
      if (i < selectedProcesses.length - 1) {
        await new Promise(resolve => setTimeout(resolve, 100));
      }
    }

    // Final summary
    console.log('\n' + chalk.cyan('═'.repeat(50)));
    console.log(chalk.cyan.bold('⚙️  TERMINATION SUMMARY'));
    console.log(chalk.cyan('═'.repeat(50)));
    
    if (successCount === selectedProcesses.length) {
      console.log(chalk.green(`✓ All ${successCount} process(es) were successfully terminated.`));
    } else {
      console.log(chalk.yellow(`✓ ${successCount} process(es) were successfully terminated.`));
      if (selectedProcesses.length > successCount) {
        console.log(chalk.red(`✗ ${selectedProcesses.length - successCount} process(es) could not be terminated.`));
        console.log(chalk.dim('\nYou may need to run this command with elevated privileges (sudo).'));
      }
    }
    
    console.log(chalk.cyan('═'.repeat(50)) + '\n');
    
  } catch (error) {
    console.error(chalk.red('An error occurred:'), error.message);
    process.exit(1);
  }
}

// Handle Ctrl+C gracefully
process.on('SIGINT', () => {
  console.log(chalk.yellow('\n\n⚠️  Operation cancelled by user.'));
  process.exit(0);
});

// Handle unhandled promise rejections
process.on('unhandledRejection', (error) => {
  console.error(chalk.red('An unexpected error occurred:'), error);
  process.exit(1);
});

// Run main function
main().catch(error => {
  console.error(chalk.red('A critical error occurred:'), error);
  process.exit(1);
});