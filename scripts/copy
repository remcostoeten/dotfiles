#!/usr/bin/env bash

# Copy Utility Script
# Interactive display utility for development workflows
# Works with files, directories, git remotes, and more

set -euo pipefail

# Configuration
readonly SCRIPT_NAME="copy"
readonly VERSION="1.0.0"

# Determine the script directory and source color utilities
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
DOTFILES_DIR="$(cd "$SCRIPT_DIR/../" && pwd)"

# Color utility functions
red() { printf "\033[31m%s\033[0m" "$@"; }
green() { printf "\033[32m%s\033[0m" "$@"; }
yellow() { printf "\033[33m%s\033[0m" "$@"; }
blue() { printf "\033[34m%s\033[0m" "$@"; }
cyan() { printf "\033[36m%s\033[0m" "$@"; }
bold() { printf "\033[1m%s\033[0m" "$@"; }

# Semantic functions
error() { red "[ERROR]" && printf " %s" "$@"; }
success() { green "[SUCCESS]" && printf " %s" "$@"; }
warning() { yellow "[WARNING]" && printf " %s" "$@"; }
info() { blue "[INFO]" && printf " %s" "$@"; }

# Display text with color formatting
function copy_to_clipboard() {
    local content="$1"
    local title="${2:-Content}"
    
    # Copy to clipboard using xclip or wl-copy
    if command -v xclip >/dev/null 2>&1; then
        echo -n "$content" | xclip -selection clipboard
    elif command -v wl-copy >/dev/null 2>&1; then
        echo -n "$content" | wl-copy
    else
        echo "ERROR: Neither xclip nor wl-copy found. Please install one of them."
        exit 1
    fi
    
    # Display the copied content
    echo
    printf "%s\n" "$(bold "$(cyan "=== $title ===")")
    echo
    printf "%s\n" "$content"
    echo
    printf "%s\n" "$(bold "$(cyan "=== End of $title ===")")
    echo
    printf "%s\n" "$(success "Content copied to clipboard!")"
    echo
}

# Handle file display
function handle_file() {
    local file_path="$1"
    
    if [[ ! -f "$file_path" ]]; then
        printf "%s %s\n" "$(error "File not found:")" "$file_path"
        return 1
    fi
    
    if [[ ! -r "$file_path" ]]; then
        printf "%s %s\n" "$(error "Cannot read file:")" "$file_path"
        return 1
    fi
    
    local content
    if ! content=$(cat "$file_path"); then
        printf "%s %s\n" "$(error "Failed to read file:")" "$file_path"
        return 1
    fi
    
    copy_to_clipboard "$content" "File: $file_path"
    
    local file_size=$(wc -c < "$file_path")
    local line_count=$(wc -l < "$file_path")
    printf "%s ðŸ“„ File size: %s bytes, %s lines\n" "$(info)" "$(bold "$file_size")" "$(bold "$line_count")"
    
    return 0
}

# Handle pwd/path display
function handle_pwd() {
    local target_path="${1:-$(pwd)}"
    local resolved_path
    
    # Try to resolve the path
    if ! resolved_path=$(realpath "$target_path" 2>/dev/null); then
        printf "%s %s\n" "$(error "Invalid path:")" "$target_path"
        return 1
    fi
    
    if [[ "$target_path" == "$(pwd)" ]] || [[ "$target_path" == "." ]]; then
        copy_to_clipboard "$resolved_path" "Current Directory"
        printf "%s ðŸ“‚ Current directory path displayed above\n" "$(success)"
    else
        copy_to_clipboard "$resolved_path" "Directory Path"
        printf "%s ðŸ“‚ Path displayed above\n" "$(success)"
    fi
    
    return 0
}

# Handle git remote display
function handle_remote() {
    # Check if we're in a git repository
    if ! git rev-parse --git-dir &> /dev/null; then
        printf "%s Not in a git repository\n" "$(error)"
        return 1
    fi
    
    local remote_url
    
    # Try to get the remote URL (prefer origin)
    if remote_url=$(git remote get-url origin 2>/dev/null); then
        :  # Success, use remote_url
    elif remote_url=$(git config --get remote.origin.url 2>/dev/null); then
        :  # Fallback method
    else
        # List available remotes
        local remotes
        remotes=$(git remote)
        
        if [[ -z "$remotes" ]]; then
            printf "%s No git remotes configured\n" "$(error)"
            return 1
        fi
        
        printf "%s No 'origin' remote found. Available remotes:\n" "$(warning)"
        echo "$remotes" | while read -r remote; do
            local url
            url=$(git remote get-url "$remote" 2>/dev/null || echo "unknown")
            printf "  %s: %s\n" "$(cyan "$remote")" "$url"
        done
        
        return 1
    fi
    
    copy_to_clipboard "$remote_url" "Git Remote URL"
    printf "%s ðŸ”— Git remote URL displayed above\n" "$(success)"
    
    return 0
}

# Handle tree display with custom arguments
function handle_tree() {
    local tree_args=()
    local tree_path="."
    local custom_exclude=""
    local custom_include=""
    local exclude_extensions=""
    local include_extensions=""
    local has_custom_filters=false
    
    # Check if tree command exists
    if ! command -v tree >/dev/null 2>&1; then
        printf "%s tree command not found. Please install it first.\n" "$(error)"
        return 1
    fi
    
    # Default exclusions (always ignore node_modules and .next unless overridden)
    local default_exclude="node_modules|.next"
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -l|--level)
                if [[ -n "$2" ]] && [[ "$2" =~ ^[0-9]+$ ]]; then
                    tree_args+=("-L" "$2")
                    shift 2
                else
                    printf "%s Invalid level argument. Use: -l <number>\n" "$(error)"
                    return 1
                fi
                ;;
            -a|--all)
                tree_args+=("-a")
                shift
                ;;
            -d|--dirs-only)
                tree_args+=("-d")
                shift
                ;;
            -f|--full-path)
                tree_args+=("-f")
                shift
                ;;
            -e|--exclude)
                if [[ -n "$2" ]]; then
                    if [[ -n "$custom_exclude" ]]; then
                        custom_exclude="$custom_exclude|$2"
                    else
                        custom_exclude="$2"
                    fi
                    has_custom_filters=true
                    shift 2
                else
                    printf "%s --exclude requires a pattern\n" "$(error)"
                    return 1
                fi
                ;;
            -i|--include-only)
                if [[ -n "$2" ]]; then
                    if [[ -n "$custom_include" ]]; then
                        custom_include="$custom_include|$2"
                    else
                        custom_include="$2"
                    fi
                    has_custom_filters=true
                    shift 2
                else
                    printf "%s --include-only requires a pattern\n" "$(error)"
                    return 1
                fi
                ;;
            --exclude-ext)
                if [[ -n "$2" ]]; then
                    # Remove leading dot if present and add pattern
                    local ext="${2#.}"
                    if [[ -n "$exclude_extensions" ]]; then
                        exclude_extensions="$exclude_extensions|*.$ext"
                    else
                        exclude_extensions="*.$ext"
                    fi
                    has_custom_filters=true
                    shift 2
                else
                    printf "%s --exclude-ext requires an extension\n" "$(error)"
                    return 1
                fi
                ;;
            --include-ext)
                if [[ -n "$2" ]]; then
                    # Remove leading dot if present and add pattern
                    local ext="${2#.}"
                    if [[ -n "$include_extensions" ]]; then
                        include_extensions="$include_extensions|*.$ext"
                    else
                        include_extensions="*.$ext"
                    fi
                    has_custom_filters=true
                    shift 2
                else
                    printf "%s --include-ext requires an extension\n" "$(error)"
                    return 1
                fi
                ;;
            --no-defaults)
                # Don't apply default exclusions
                default_exclude=""
                shift
                ;;
            --help)
                printf "%s\n" "$(bold "Tree Copy Usage:")"
                printf "    %s tree [OPTIONS] [PATH]\n" "$(green "copy")"
                echo
                printf "%s\n" "$(bold "OPTIONS:")"
                printf "    %s        Limit depth to N levels\n" "$(cyan "-l, --level N")"
                printf "    %s           Show hidden files\n" "$(cyan "-a, --all")"
                printf "    %s     Show directories only\n" "$(cyan "-d, --dirs-only")"
                printf "    %s     Show full path names\n" "$(cyan "-f, --full-path")"
                printf "    %s      Exclude folders/files matching pattern\n" "$(cyan "-e, --exclude PATTERN")"
                printf "    %s  Show only folders/files matching pattern\n" "$(cyan "-i, --include-only PATTERN")"
                printf "    %s  Exclude files with extension\n" "$(cyan "--exclude-ext EXT")"
                printf "    %s  Include only files with extension\n" "$(cyan "--include-ext EXT")"
                printf "    %s    Don't exclude node_modules/.next by default\n" "$(cyan "--no-defaults")"
                printf "    %s         Show this help\n" "$(cyan "--help")"
                echo
                printf "%s\n" "$(bold "EXAMPLES:")"
                printf "    %s           # Tree with default settings\n" "$(green "copy tree")"
                printf "    %s        # Tree limited to 2 levels\n" "$(green "copy tree -l 2")"
                printf "    %s  # Exclude dist and build folders\n" "$(green "copy tree -e dist -e build")"
                printf "    %s      # Include only TypeScript files\n" "$(green "copy tree --include-ext ts")"
                printf "    %s     # Exclude JavaScript files\n" "$(green "copy tree --exclude-ext js")"
                printf "    %s    # Include only src and docs folders\n" "$(green "copy tree -i 'src|docs'")"
                printf "    %s # No default exclusions\n" "$(green "copy tree --no-defaults")"
                return 0
                ;;
            -*)
                printf "%s Unknown tree option: %s\n" "$(error)" "$1"
                printf "%s Use 'copy tree --help' for available options\n" "$(info)"
                return 1
                ;;
            *)
                # Treat as path
                tree_path="$1"
                shift
                ;;
        esac
    done
    
    # Validate path
    if [[ ! -d "$tree_path" ]]; then
        printf "%s Directory not found: %s\n" "$(error)" "$tree_path"
        return 1
    fi
    
    # Build final filter patterns
    local final_exclude=""
    local final_include=""
    
    # Handle include patterns (takes precedence)
    if [[ -n "$custom_include" ]] || [[ -n "$include_extensions" ]]; then
        if [[ -n "$custom_include" ]] && [[ -n "$include_extensions" ]]; then
            final_include="$custom_include|$include_extensions"
        elif [[ -n "$custom_include" ]]; then
            final_include="$custom_include"
        else
            final_include="$include_extensions"
        fi
        tree_args+=("-P" "$final_include")
    else
        # Handle exclude patterns
        local all_excludes=""
        
        # Add default exclusions unless disabled
        if [[ -n "$default_exclude" ]]; then
            all_excludes="$default_exclude"
        fi
        
        # Add custom exclusions
        if [[ -n "$custom_exclude" ]]; then
            if [[ -n "$all_excludes" ]]; then
                all_excludes="$all_excludes|$custom_exclude"
            else
                all_excludes="$custom_exclude"
            fi
        fi
        
        # Add extension exclusions
        if [[ -n "$exclude_extensions" ]]; then
            if [[ -n "$all_excludes" ]]; then
                all_excludes="$all_excludes|$exclude_extensions"
            else
                all_excludes="$exclude_extensions"
            fi
        fi
        
        # Apply exclusions if any
        if [[ -n "$all_excludes" ]]; then
            tree_args+=("-I" "$all_excludes")
            final_exclude="$all_excludes"
        fi
    fi
    
    # Generate tree output
    local tree_output
    if ! tree_output=$(tree "${tree_args[@]}" "$tree_path" 2>/dev/null); then
        printf "%s Failed to generate tree output\n" "$(error)"
        return 1
    fi
    
    # Get resolved path for title
    local resolved_path
    resolved_path=$(realpath "$tree_path" 2>/dev/null || echo "$tree_path")
    
    copy_to_clipboard "$tree_output" "Directory Tree: $resolved_path"
    
    # Display tree stats
    local dir_count file_count
    if [[ "$tree_output" =~ ([0-9]+)\ director(y|ies),\ ([0-9]+)\ files? ]]; then
        dir_count="${BASH_REMATCH[1]}"
        file_count="${BASH_REMATCH[3]}"
        printf "%s ðŸŒ³ Tree displayed above (%s directories, %s files)\n" "$(success)" "$(bold "$dir_count")" "$(bold "$file_count")"
    else
        printf "%s ðŸŒ³ Directory tree displayed above\n" "$(success)"
    fi
    
    # Show applied filters
    if [[ -n "$final_include" ]]; then
        printf "%s ðŸ“‹ Filters: Including only: %s\n" "$(info)" "$final_include"
    elif [[ -n "$final_exclude" ]]; then
        printf "%s ðŸ“‹ Filters: Excluding: %s\n" "$(info)" "$final_exclude"
    elif [[ -z "$default_exclude" ]]; then
        printf "%s ðŸ“‹ Filters: None (--no-defaults used)\n" "$(info)"
    else
        printf "%s ðŸ“‹ Filters: Default exclusions (node_modules, .next)\n" "$(info)"
    fi
    
    return 0
}

# Handle tree display with custom arguments
function handle_tree() {
    local tree_args=()
    local tree_path="."
    local custom_exclude=""
    local custom_include=""
    local exclude_extensions=""
    local include_extensions=""
    local has_custom_filters=false
    
    # Check if tree command exists
    if ! command -v tree >/dev/null 2>&1; then
        printf "%s tree command not found. Please install it first.\n" "$(error)"
        return 1
    fi
    
    # Default exclusions (always ignore node_modules and .next unless overridden)
    local default_exclude="node_modules|.next"
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -l|--level)
                if [[ -n "$2" ]] && [[ "$2" =~ ^[0-9]+$ ]]; then
                    tree_args+=("-L" "$2")
                    shift 2
                else
                    printf "%s Invalid level argument. Use: -l <number>\n" "$(error)"
                    return 1
                fi
                ;;
            -a|--all)
                tree_args+=("-a")
                shift
                ;;
            -d|--dirs-only)
                tree_args+=("-d")
                shift
                ;;
            -f|--full-path)
                tree_args+=("-f")
                shift
                ;;
            -e|--exclude)
                if [[ -n "$2" ]]; then
                    if [[ -n "$custom_exclude" ]]; then
                        custom_exclude="$custom_exclude|$2"
                    else
                        custom_exclude="$2"
                    fi
                    has_custom_filters=true
                    shift 2
                else
                    printf "%s --exclude requires a pattern\n" "$(error)"
                    return 1
                fi
                ;;
            -i|--include-only)
                if [[ -n "$2" ]]; then
                    if [[ -n "$custom_include" ]]; then
                        custom_include="$custom_include|$2"
                    else
                        custom_include="$2"
                    fi
                    has_custom_filters=true
                    shift 2
                else
                    printf "%s --include-only requires a pattern\n" "$(error)"
                    return 1
                fi
                ;;
            --exclude-ext)
                if [[ -n "$2" ]]; then
                    # Remove leading dot if present and add pattern
                    local ext="${2#.}"
                    if [[ -n "$exclude_extensions" ]]; then
                        exclude_extensions="$exclude_extensions|*.$ext"
                    else
                        exclude_extensions="*.$ext"
                    fi
                    has_custom_filters=true
                    shift 2
                else
                    printf "%s --exclude-ext requires an extension\n" "$(error)"
                    return 1
                fi
                ;;
            --include-ext)
                if [[ -n "$2" ]]; then
                    # Remove leading dot if present and add pattern
                    local ext="${2#.}"
                    if [[ -n "$include_extensions" ]]; then
                        include_extensions="$include_extensions|*.$ext"
                    else
                        include_extensions="*.$ext"
                    fi
                    has_custom_filters=true
                    shift 2
                else
                    printf "%s --include-ext requires an extension\n" "$(error)"
                    return 1
                fi
                ;;
            --no-defaults)
                # Don't apply default exclusions
                default_exclude=""
                shift
                ;;
            --help)
                printf "%s\n" "$(bold "Tree Copy Usage:")"
                printf "    %s tree [OPTIONS] [PATH]\n" "$(green "copy")"
                echo
                printf "%s\n" "$(bold "OPTIONS:")"
                printf "    %s        Limit depth to N levels\n" "$(cyan "-l, --level N")"
                printf "    %s           Show hidden files\n" "$(cyan "-a, --all")"
                printf "    %s     Show directories only\n" "$(cyan "-d, --dirs-only")"
                printf "    %s     Show full path names\n" "$(cyan "-f, --full-path")"
                printf "    %s      Exclude folders/files matching pattern\n" "$(cyan "-e, --exclude PATTERN")"
                printf "    %s  Show only folders/files matching pattern\n" "$(cyan "-i, --include-only PATTERN")"
                printf "    %s  Exclude files with extension\n" "$(cyan "--exclude-ext EXT")"
                printf "    %s  Include only files with extension\n" "$(cyan "--include-ext EXT")"
                printf "    %s    Don't exclude node_modules/.next by default\n" "$(cyan "--no-defaults")"
                printf "    %s         Show this help\n" "$(cyan "--help")"
                echo
                printf "%s\n" "$(bold "EXAMPLES:")"
                printf "    %s           # Tree with default settings\n" "$(green "copy tree")"
                printf "    %s        # Tree limited to 2 levels\n" "$(green "copy tree -l 2")"
                printf "    %s  # Exclude dist and build folders\n" "$(green "copy tree -e dist -e build")"
                printf "    %s      # Include only TypeScript files\n" "$(green "copy tree --include-ext ts")"
                printf "    %s     # Exclude JavaScript files\n" "$(green "copy tree --exclude-ext js")"
                printf "    %s    # Include only src and docs folders\n" "$(green "copy tree -i 'src|docs'")"
                printf "    %s # No default exclusions\n" "$(green "copy tree --no-defaults")"
                return 0
                ;;
            -*)
                printf "%s Unknown tree option: %s\n" "$(error)" "$1"
                printf "%s Use 'copy tree --help' for available options\n" "$(info)"
                return 1
                ;;
            *)
                # Treat as path
                tree_path="$1"
                shift
                ;;
        esac
    done
    
    # Validate path
    if [[ ! -d "$tree_path" ]]; then
        printf "%s Directory not found: %s\n" "$(error)" "$tree_path"
        return 1
    fi
    
    # Build final filter patterns
    local final_exclude=""
    local final_include=""
    
    # Handle include patterns (takes precedence)
    if [[ -n "$custom_include" ]] || [[ -n "$include_extensions" ]]; then
        if [[ -n "$custom_include" ]] && [[ -n "$include_extensions" ]]; then
            final_include="$custom_include|$include_extensions"
        elif [[ -n "$custom_include" ]]; then
            final_include="$custom_include"
        else
            final_include="$include_extensions"
        fi
        tree_args+=("-P" "$final_include")
    else
        # Handle exclude patterns
        local all_excludes=""
        
        # Add default exclusions unless disabled
        if [[ -n "$default_exclude" ]]; then
            all_excludes="$default_exclude"
        fi
        
        # Add custom exclusions
        if [[ -n "$custom_exclude" ]]; then
            if [[ -n "$all_excludes" ]]; then
                all_excludes="$all_excludes|$custom_exclude"
            else
                all_excludes="$custom_exclude"
            fi
        fi
        
        # Add extension exclusions
        if [[ -n "$exclude_extensions" ]]; then
            if [[ -n "$all_excludes" ]]; then
                all_excludes="$all_excludes|$exclude_extensions"
            else
                all_excludes="$exclude_extensions"
            fi
        fi
        
        # Apply exclusions if any
        if [[ -n "$all_excludes" ]]; then
            tree_args+=("-I" "$all_excludes")
            final_exclude="$all_excludes"
        fi
    fi
    
    # Generate tree output
    local tree_output
    if ! tree_output=$(tree "${tree_args[@]}" "$tree_path" 2>/dev/null); then
        printf "%s Failed to generate tree output\n" "$(error)"
        return 1
    fi
    
    # Get resolved path for title
    local resolved_path
    resolved_path=$(realpath "$tree_path" 2>/dev/null || echo "$tree_path")
    
    copy_to_clipboard "$tree_output" "Directory Tree: $resolved_path"
    
    # Display tree stats
    local dir_count file_count
    if [[ "$tree_output" =~ ([0-9]+)\ director(y|ies),\ ([0-9]+)\ files? ]]; then
        dir_count="${BASH_REMATCH[1]}"
        file_count="${BASH_REMATCH[3]}"
        printf "%s ðŸŒ³ Tree displayed above (%s directories, %s files)\n" "$(success)" "$(bold "$dir_count")" "$(bold "$file_count")"
    else
        printf "%s ðŸŒ³ Directory tree displayed above\n" "$(success)"
    fi
    
    # Show applied filters
    if [[ -n "$final_include" ]]; then
        printf "%s ðŸ“‹ Filters: Including only: %s\n" "$(info)" "$final_include"
    elif [[ -n "$final_exclude" ]]; then
        printf "%s ðŸ“‹ Filters: Excluding: %s\n" "$(info)" "$final_exclude"
    elif [[ -z "$default_exclude" ]]; then
        printf "%s ðŸ“‹ Filters: None (--no-defaults used)\n" "$(info)"
    else
        printf "%s ðŸ“‹ Filters: Default exclusions (node_modules, .next)\n" "$(info)"
    fi
    
    return 0
}

# Handle help display
function handle_help() {
    printf "%s\n" "$(bold "$(cyan "Copy Utility - Interactive display utility for development workflows")") "
    echo
    printf "%s\n" "$(bold "USAGE:")"
    printf "    %s [COMMAND] [ARGS...]\n" "$(green "copy")"
    printf "    %s                    # Interactive mode\n" "$(green "copy")"
    echo
    printf "%s\n" "$(bold "COMMANDS:")"
    printf "    %s             Display contents of file\n" "$(cyan "<filename>")"
    printf "    %s [path]             Display current directory or specified path\n" "$(cyan "pwd")"
    printf "    %s                 Display git remote URL\n" "$(cyan "remote")"
    printf "    %s [options] [path]   Display directory tree (excludes node_modules & .next)\n" "$(cyan "tree")"
    printf "    %s       Show this help message\n" "$(cyan "help, --help, -h")"
    echo
    printf "%s\n" "$(bold "EXAMPLES:")"
    printf "    %s      # Display file contents\n" "$(green "copy package.json")"
    printf "    %s               # Display current directory path\n" "$(green "copy pwd")"
    printf "    %s    # Display specific directory path\n" "$(green "copy pwd ~/projects")"
    printf "    %s            # Display git remote URL\n" "$(green "copy remote")"
    printf "    %s               # Display directory tree\n" "$(green "copy tree")"
    printf "    %s            # Tree limited to 2 levels\n" "$(green "copy tree -l 2")"
    printf "    %s                   # Interactive mode with menu\n" "$(green "copy")"
    echo
    printf "%s\n" "$(bold "INTERACTIVE MODE:")"
    printf "    When called without arguments, copy enters interactive mode with\n"
    printf "    a menu of options for easy selection.\n"
    echo
}

# Interactive mode
function interactive_mode() {
    printf "%s ðŸ”„ Entering interactive mode...\n" "$(info)"
    echo
    
    while true; do
        printf "%s\n" "$(bold "Select what to display:")"
        printf "1) %s\n" "$(cyan "File contents")"
        printf "2) %s\n" "$(cyan "Current directory path")"
        printf "3) %s\n" "$(cyan "Specific directory path")"
        printf "4) %s\n" "$(cyan "Git remote URL")"
        printf "5) %s\n" "$(cyan "Directory tree")"
        printf "6) %s\n" "$(cyan "Quit")"
        echo
        
        printf "%s " "$(bold "Choice (1-6):")"
        read -r choice
        echo
        
        case $choice in
            1)
                printf "%s " "$(blue "Enter filename:")"
                read -r filename
                if [[ -n "$filename" ]]; then
                    handle_file "$filename" && break
                else
                    printf "%s No filename provided\n" "$(warning)"
                fi
                ;;
            2)
                handle_pwd && break
                ;;
            3)
                printf "%s " "$(blue "Enter directory path:")"
                read -r dirpath
                if [[ -n "$dirpath" ]]; then
                    handle_pwd "$dirpath" && break
                else
                    printf "%s No path provided\n" "$(warning)"
                fi
                ;;
            4)
                handle_remote && break
                ;;
            5)
                printf "%s " "$(blue "Enter directory path (or press Enter for current):")"
                read -r treepath
                if [[ -z "$treepath" ]]; then
                    treepath="."
                fi
                
                printf "%s " "$(blue "Enter tree level limit (or press Enter for no limit):")"
                read -r level
                
                printf "%s " "$(blue "Exclude patterns (comma-separated, or press Enter to skip):")"
                read -r excludes
                
                printf "%s " "$(blue "Include only patterns (comma-separated, or press Enter to skip):")"
                read -r includes
                
                printf "%s " "$(blue "Exclude file extensions (comma-separated, or press Enter to skip):")"
                read -r exclude_exts
                
                printf "%s " "$(blue "Include only file extensions (comma-separated, or press Enter to skip):")"
                read -r include_exts
                
                # Build arguments array
                local tree_interactive_args=()
                
                if [[ -n "$level" ]] && [[ "$level" =~ ^[0-9]+$ ]]; then
                    tree_interactive_args+=("-l" "$level")
                fi
                
                if [[ -n "$excludes" ]]; then
                    IFS=',' read -ra exclude_array <<< "$excludes"
                    for exclude in "${exclude_array[@]}"; do
                        exclude=$(echo "$exclude" | xargs)  # trim whitespace
                        if [[ -n "$exclude" ]]; then
                            tree_interactive_args+=("-e" "$exclude")
                        fi
                    done
                fi
                
                if [[ -n "$includes" ]]; then
                    IFS=',' read -ra include_array <<< "$includes"
                    for include in "${include_array[@]}"; do
                        include=$(echo "$include" | xargs)  # trim whitespace
                        if [[ -n "$include" ]]; then
                            tree_interactive_args+=("-i" "$include")
                        fi
                    done
                fi
                
                if [[ -n "$exclude_exts" ]]; then
                    IFS=',' read -ra exclude_ext_array <<< "$exclude_exts"
                    for ext in "${exclude_ext_array[@]}"; do
                        ext=$(echo "$ext" | xargs)  # trim whitespace
                        if [[ -n "$ext" ]]; then
                            tree_interactive_args+=("--exclude-ext" "$ext")
                        fi
                    done
                fi
                
                if [[ -n "$include_exts" ]]; then
                    IFS=',' read -ra include_ext_array <<< "$include_exts"
                    for ext in "${include_ext_array[@]}"; do
                        ext=$(echo "$ext" | xargs)  # trim whitespace
                        if [[ -n "$ext" ]]; then
                            tree_interactive_args+=("--include-ext" "$ext")
                        fi
                    done
                fi
                
                tree_interactive_args+=("$treepath")
                handle_tree "${tree_interactive_args[@]}" && break
                ;;
            6)
                printf "%s Goodbye! ðŸ‘‹\n" "$(info)"
                exit 0
                ;;
            *)
                printf "%s Invalid choice. Please select 1-6.\n" "$(warning)"
                ;;
        esac
        echo
    done
}

# Main function
main() {
    # Handle no arguments - interactive mode
    if [[ $# -eq 0 ]]; then
        interactive_mode
        return 0
    fi
    
    local command="$1"
    shift
    
    case "$command" in
        help|--help|-h)
            handle_help
            ;;
        pwd)
            handle_pwd "$@"
            ;;
        remote)
            if [[ $# -gt 0 ]]; then
                printf "%s The 'remote' command does not accept arguments\n" "$(warning)"
                return 1
            fi
            handle_remote
            ;;
        tree)
            handle_tree "$@"
            ;;
        --version|-v)
            echo "$SCRIPT_NAME version $VERSION"
            ;;
        -*)
            printf "%s Unknown option: %s\n" "$(error)" "$command"
            printf "%s Use 'copy --help' for usage information\n" "$(info)"
            return 1
            ;;
        *)
            # Treat as filename
            handle_file "$command"
            ;;
    esac
}

# Run main function with all arguments
main "$@"