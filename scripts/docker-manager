#!/usr/bin/env python3

import os
import sys
import subprocess
import platform
import json
import re
from typing import List, Dict, Optional, Tuple
import datetime

class Colors:
    RESET = '\033[0m'
    BRIGHT = '\033[1m'
    DIM = '\033[2m'
    RED = '\033[31m'
    GREEN = '\033[32m'
    YELLOW = '\033[33m'
    BLUE = '\033[34m'
    MAGENTA = '\033[35m'
    CYAN = '\033[36m'
    WHITE = '\033[37m'
    BG_RED = '\033[41m'
    BG_GREEN = '\033[42m'
    BG_YELLOW = '\033[43m'
    BG_BLUE = '\033[44m'
    BG_MAGENTA = '\033[45m'
    BG_CYAN = '\033[46m'

class MenuItem:
    def __init__(self, text: str, value: str, indicator: str = ''):
        self.text = text
        self.value = value
        self.indicator = indicator

class Container:
    def __init__(self, container_id: str, name: str, image: str, status: str, ports: str = '', created: str = '', project: str = ''):
        self.id = container_id
        self.name = name
        self.image = image
        self.status = status
        self.ports = ports
        self.created = created
        self.project = project

class DockerManager:
    def __init__(self):
        self.selected_index = 0
        self.current_view = 'main'
        self.prev_view = ''
        self.is_running = True

    def start(self):
        self.check_dependencies()
        self.show_main_menu()
        self.cleanup()

    def check_dependencies(self):
        try:
            subprocess.run(['docker', '--version'], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, check=True)
        except (subprocess.CalledProcessError, FileNotFoundError):
            self.clear_screen()
            self.print_header()
            print(f"{Colors.YELLOW}âš  Warning: Docker is not installed or not running{Colors.RESET}")
            print("Please install Docker to use this tool.\n")
            input("Press Enter to exit...")
            sys.exit(1)

    def clear_screen(self):
        os.system('clear' if os.name != 'nt' else 'cls')

    def print_header(self):
        print(f"{Colors.CYAN}{Colors.BRIGHT}")
        print('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—')
        print('â•‘                                                                    â•‘')
        print('â•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—              â•‘')
        print('â•‘     â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—             â•‘')
        print('â•‘     â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•             â•‘')
        print('â•‘     â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—             â•‘')
        print('â•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘             â•‘')
        print('â•‘     â•šâ•â•â•â•â•â•  â•šâ•â•â•â•â•â•  â•šâ•â•â•â•â•â•â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•             â•‘')
        print('â•‘                                                                    â•‘')
        print('â•‘                   Docker Container Manager v1.0                   â•‘')
        print('â•‘                                                                    â•‘')
        print('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•')
        print(f"{Colors.RESET}\n")

    def print_menu_item(self, index: int, text: str, is_selected: bool):
        if is_selected:
            print(f"{Colors.BG_CYAN}{Colors.BRIGHT} â–¶ {text} {Colors.RESET}")
        else:
            print(f"   {text}")

    def print_footer(self, custom_help: str = ''):
        print('\n' + 'â”€' * 70)
        if custom_help:
            print(f"{Colors.DIM}{custom_help}{Colors.RESET}")
        else:
            print(f"{Colors.DIM}â†‘â†“: Navigate | Enter: Select | q: Quit | b: Back{Colors.RESET}")

    def show_main_menu(self):
        self.current_view = 'main'
        self.selected_index = 0
        options = [
            MenuItem('ðŸ³ View Containers', 'view'),
            MenuItem('ðŸš€ Start Container', 'start'),
            MenuItem('ðŸ›‘ Stop Container', 'stop'),
            MenuItem('ðŸ“‹ Container Logs', 'logs'),
            MenuItem('ðŸ—‘ï¸  Remove Container', 'remove'),
            MenuItem('ðŸ§¹ System Cleanup', 'cleanup'),
            MenuItem('ðŸ“Š Docker Info', 'info'),
            MenuItem('âŒ Exit', 'exit')
        ]

        while self.is_running:
            self.clear_screen()
            self.print_header()
            print(f"{Colors.BRIGHT}{Colors.WHITE}MAIN MENU{Colors.RESET}\n")

            for i, option in enumerate(options):
                self.print_menu_item(i, option.text, i == self.selected_index)

            self.print_footer()

            action = self.handle_navigation(len(options))

            if action == 'select':
                selected = options[self.selected_index]
                if selected.value == 'view':
                    self.show_containers_view()
                elif selected.value == 'start':
                    self.show_start_container_menu()
                elif selected.value == 'stop':
                    self.show_stop_container_menu()
                elif selected.value == 'logs':
                    self.show_logs_menu()
                elif selected.value == 'remove':
                    self.show_remove_container_menu()
                elif selected.value == 'cleanup':
                    self.show_cleanup_menu()
                elif selected.value == 'info':
                    self.show_docker_info()
                elif selected.value == 'exit':
                    self.is_running = False
            elif action == 'quit':
                self.is_running = False

    def show_containers_view(self):
        self.prev_view = self.current_view
        self.current_view = 'containers'
        self.selected_index = 0

        while self.current_view == 'containers':
            containers = self.get_containers()
            
            self.clear_screen()
            self.print_header()
            print(f"{Colors.BRIGHT}{Colors.WHITE}CONTAINERS{Colors.RESET}")
            print(f"{Colors.DIM}Main Menu > View Containers{Colors.RESET}\n")

            if len(containers) == 0:
                print(f"{Colors.YELLOW}No containers found.{Colors.RESET}\n")
                input("Press Enter to return...")
                self.current_view = self.prev_view
                return

            options = []
            for i, container in enumerate(containers):
                status_icon = 'ðŸŸ¢' if 'running' in container.status.lower() else 'ðŸ”´'
                port_info = f" - {container.ports}" if container.ports else ''
                project_info = f" {Colors.DIM}[{container.project}]{Colors.RESET}" if container.project else ''
                options.append(MenuItem(
                    f"{status_icon} {container.name} ({container.status}){port_info}{project_info}",
                    str(i)
                ))
            options.append(MenuItem('â¬…ï¸  Back to Main Menu', 'back'))

            for i, option in enumerate(options):
                self.print_menu_item(i, option.text, i == self.selected_index)

            self.print_footer('â†‘â†“: Navigate | Enter: Details | b: Back')

            action = self.handle_navigation(len(options))

            if action == 'select':
                if options[self.selected_index].value == 'back':
                    self.current_view = self.prev_view
                else:
                    container_index = int(options[self.selected_index].value)
                    self.show_container_details(containers[container_index])
            elif action == 'back' or action == 'quit':
                self.current_view = self.prev_view

    def show_container_details(self, container: Container):
        self.clear_screen()
        self.print_header()
        print(f"{Colors.BRIGHT}{Colors.WHITE}CONTAINER DETAILS{Colors.RESET}")
        print(f"{Colors.DIM}Main Menu > View Containers > {container.name}{Colors.RESET}\n")

        print(f"{Colors.CYAN}ID:{Colors.RESET} {container.id}")
        print(f"{Colors.CYAN}Name:{Colors.RESET} {container.name}")
        print(f"{Colors.CYAN}Image:{Colors.RESET} {container.image}")
        
        status_color = Colors.GREEN if 'running' in container.status.lower() else Colors.RED
        print(f"{Colors.CYAN}Status:{Colors.RESET} {status_color}{container.status}{Colors.RESET}")
        
        if container.ports:
            print(f"{Colors.CYAN}Ports:{Colors.RESET} {container.ports}")
        
        if container.created:
            print(f"{Colors.CYAN}Created:{Colors.RESET} {container.created}")
        
        if container.project:
            print(f"{Colors.CYAN}Project:{Colors.RESET} {container.project}")

        print('\n' + 'â”€' * 70)
        print(f"{Colors.DIM}Press any key to return...{Colors.RESET}")
        input()

    def show_start_container_menu(self):
        containers = [c for c in self.get_containers() if 'running' not in c.status.lower()]
        self.show_container_action_menu("START CONTAINER", containers, self.start_container)

    def show_stop_container_menu(self):
        containers = [c for c in self.get_containers() if 'running' in c.status.lower()]
        self.show_container_action_menu("STOP CONTAINER", containers, self.stop_container)

    def show_logs_menu(self):
        containers = self.get_containers()
        self.show_container_action_menu("CONTAINER LOGS", containers, self.show_container_logs)

    def show_remove_container_menu(self):
        containers = self.get_containers()
        self.show_container_action_menu("REMOVE CONTAINER", containers, self.remove_container)

    def show_container_action_menu(self, title: str, containers: List[Container], action_func):
        self.clear_screen()
        self.print_header()
        print(f"{Colors.BRIGHT}{Colors.WHITE}{title}{Colors.RESET}")
        print(f"{Colors.DIM}Main Menu > {title.title()}{Colors.RESET}\n")

        if len(containers) == 0:
            print(f"{Colors.YELLOW}No containers available for this action.{Colors.RESET}")
            input("Press Enter to return...")
            return

        print("Available containers:")
        for i, container in enumerate(containers, 1):
            status_icon = 'ðŸŸ¢' if 'running' in container.status.lower() else 'ðŸ”´'
            print(f"{i}. {status_icon} {container.name} ({container.status})")

        print()
        choice = input("Enter container number (or press Enter to cancel): ").strip()

        if not choice.isdigit() or int(choice) < 1 or int(choice) > len(containers):
            return

        selected_container = containers[int(choice) - 1]
        action_func(selected_container)

    def start_container(self, container: Container):
        print(f"\n{Colors.YELLOW}Starting container {container.name}...{Colors.RESET}")
        try:
            result = subprocess.run(['docker', 'start', container.id], 
                                  capture_output=True, text=True, check=True)
            print(f"{Colors.GREEN}âœ“ Container started successfully!{Colors.RESET}")
        except subprocess.CalledProcessError as e:
            print(f"{Colors.RED}âœ— Failed to start container: {e.stderr.strip()}{Colors.RESET}")
        
        print('\n' + 'â”€' * 70)
        input("Press Enter to continue...")

    def stop_container(self, container: Container):
        print(f"\n{Colors.YELLOW}Stopping container {container.name}...{Colors.RESET}")
        try:
            result = subprocess.run(['docker', 'stop', container.id], 
                                  capture_output=True, text=True, check=True)
            print(f"{Colors.GREEN}âœ“ Container stopped successfully!{Colors.RESET}")
        except subprocess.CalledProcessError as e:
            print(f"{Colors.RED}âœ— Failed to stop container: {e.stderr.strip()}{Colors.RESET}")
        
        print('\n' + 'â”€' * 70)
        input("Press Enter to continue...")

    def show_container_logs(self, container: Container):
        self.clear_screen()
        self.print_header()
        print(f"{Colors.BRIGHT}{Colors.WHITE}LOGS: {container.name}{Colors.RESET}\n")
        
        try:
            result = subprocess.run(['docker', 'logs', '--tail', '50', container.id], 
                                  capture_output=True, text=True, check=True)
            if result.stdout:
                print(result.stdout)
            else:
                print(f"{Colors.YELLOW}No logs available for this container.{Colors.RESET}")
        except subprocess.CalledProcessError as e:
            print(f"{Colors.RED}âœ— Failed to get logs: {e.stderr.strip()}{Colors.RESET}")
        
        print('\n' + 'â”€' * 70)
        input("Press Enter to continue...")

    def remove_container(self, container: Container):
        self.clear_screen()
        self.print_header()
        print(f"{Colors.RED}{Colors.BRIGHT}REMOVE CONTAINER{Colors.RESET}\n")
        
        print(f"{Colors.YELLOW}âš  Warning: You are about to remove container \"{container.name}\".{Colors.RESET}")
        print(f"{Colors.YELLOW}This action cannot be undone.{Colors.RESET}\n")
        
        confirm = input(f"Type \"{container.name}\" to confirm: ").strip()
        
        if confirm == container.name:
            try:
                # Stop container if running
                if 'running' in container.status.lower():
                    subprocess.run(['docker', 'stop', container.id], 
                                 capture_output=True, text=True, check=True)
                
                # Remove container
                subprocess.run(['docker', 'rm', container.id], 
                             capture_output=True, text=True, check=True)
                print(f"\n{Colors.GREEN}âœ“ Container removed successfully.{Colors.RESET}")
            except subprocess.CalledProcessError as e:
                print(f"\n{Colors.RED}âœ— Failed to remove container: {e.stderr.strip()}{Colors.RESET}")
        else:
            print(f"\n{Colors.YELLOW}Removal cancelled.{Colors.RESET}")

        print('\n' + 'â”€' * 70)
        input("Press Enter to continue...")

    def show_cleanup_menu(self):
        self.clear_screen()
        self.print_header()
        print(f"{Colors.BRIGHT}{Colors.WHITE}SYSTEM CLEANUP{Colors.RESET}")
        print(f"{Colors.DIM}Main Menu > System Cleanup{Colors.RESET}\n")
        
        print(f"{Colors.YELLOW}âš  This will remove:{Colors.RESET}")
        print("  - All stopped containers")
        print("  - All dangling images")
        print("  - All unused networks")
        print("  - All build cache")
        print()
        
        confirm = input("Type 'CLEANUP' to confirm: ").strip()
        
        if confirm == 'CLEANUP':
            print(f"\n{Colors.YELLOW}Cleaning up Docker system...{Colors.RESET}")
            try:
                result = subprocess.run(['docker', 'system', 'prune', '-a', '-f'], 
                                      capture_output=True, text=True, check=True)
                print(f"{Colors.GREEN}âœ“ System cleanup completed successfully!{Colors.RESET}")
                if result.stdout:
                    print(f"\n{result.stdout}")
            except subprocess.CalledProcessError as e:
                print(f"{Colors.RED}âœ— Cleanup failed: {e.stderr.strip()}{Colors.RESET}")
        else:
            print(f"\n{Colors.YELLOW}Cleanup cancelled.{Colors.RESET}")

        print('\n' + 'â”€' * 70)
        input("Press Enter to continue...")

    def show_docker_info(self):
        self.clear_screen()
        self.print_header()
        print(f"{Colors.BRIGHT}{Colors.WHITE}DOCKER SYSTEM INFO{Colors.RESET}")
        print(f"{Colors.DIM}Main Menu > Docker Info{Colors.RESET}\n")
        
        try:
            # Get Docker version
            version_result = subprocess.run(['docker', '--version'], 
                                          capture_output=True, text=True, check=True)
            print(f"{Colors.CYAN}Version:{Colors.RESET} {version_result.stdout.strip()}")
            
            # Get system info
            info_result = subprocess.run(['docker', 'system', 'df'], 
                                       capture_output=True, text=True, check=True)
            print(f"\n{Colors.CYAN}System Usage:{Colors.RESET}")
            print(info_result.stdout)
            
        except subprocess.CalledProcessError as e:
            print(f"{Colors.RED}âœ— Failed to get Docker info: {e.stderr.strip()}{Colors.RESET}")

        print('â”€' * 70)
        input("Press Enter to return...")

    def detect_project(self, container_id: str, container_name: str) -> str:
        """Detect which project a container belongs to based on various indicators."""
        try:
            # Quick pattern checks first (no docker inspect needed)
            # 1. Check container name patterns
            if '_' in container_name:
                parts = container_name.split('_')
                if len(parts) >= 2:
                    potential_project = parts[0]
                    # Skip if it looks like a service name rather than project
                    common_services = ['redis', 'mysql', 'postgres', 'nginx', 'apache', 'mongo', 'elastic', 'kibana']
                    if potential_project not in common_services:
                        return f"ðŸ“¦ {potential_project}"
            
            # 2. Check for dash-separated project names
            if '-' in container_name and not container_name.startswith('redis') and not container_name.startswith('mysql'):
                parts = container_name.split('-')
                if len(parts) >= 2:
                    potential_project = parts[0]
                    common_services = ['redis', 'mysql', 'postgres', 'nginx', 'apache', 'mongo', 'elastic', 'kibana']
                    if potential_project not in common_services:
                        return f"ðŸ“¦ {potential_project}"
            
            # 3. Check for numeric suffixes (often indicates project instances)
            numeric_match = re.match(r'^([a-zA-Z]+)[0-9]+$', container_name)
            if numeric_match:
                base_name = numeric_match.group(1)
                common_services = ['redis', 'mysql', 'postgres', 'nginx', 'apache', 'mongo', 'elastic', 'kibana']
                if base_name not in common_services:
                    return f"ðŸ“¦ {base_name}"
            
            # Get container details for deeper inspection (only if needed)
            inspect_result = subprocess.run(['docker', 'inspect', container_id], 
                                          capture_output=True, text=True, check=True)
            container_data = json.loads(inspect_result.stdout)[0]
            
            # Check for project indicators from container metadata
            labels = container_data.get('Config', {}).get('Labels', {}) or {}
            mounts = container_data.get('Mounts', [])
            networks = list(container_data.get('NetworkSettings', {}).get('Networks', {}).keys())
            working_dir = container_data.get('Config', {}).get('WorkingDir', '')
            
            # 4. Check Docker Compose project label
            if 'com.docker.compose.project' in labels:
                return f"ðŸ“ {labels['com.docker.compose.project']}"
            
            # 5. Check for custom project labels
            for key in labels:
                if 'project' in key.lower():
                    return f"ðŸ“ {labels[key]}"
            
            # 6. Check mount points for project directories
            for mount in mounts:
                if mount.get('Type') == 'bind':
                    source = mount.get('Source', '')
                    # Look for common project directory patterns
                    project_paths = [
                        '/home/remco-stoeten/dev/', 
                        '/home/remco-stoeten/projects/', 
                        '/home/remco-stoeten/work/',
                        '/workspace/', 
                        '/app/'
                    ]
                    for common_path in project_paths:
                        if source.startswith(common_path):
                            project_name = source.replace(common_path, '').split('/')[0]
                            if project_name and project_name not in ['.', '..', 'node_modules']:
                                return f"ðŸ“ {project_name}"
            
            # 7. Check network names for project hints
            for network in networks:
                if network not in ['bridge', 'host', 'none', 'default']:
                    # Clean up common network naming patterns
                    clean_network = network
                    for suffix in ['_default', '_network', '-network', '-net']:
                        clean_network = clean_network.replace(suffix, '')
                    if clean_network and clean_network != network:
                        return f"ðŸŒ {clean_network}"
            
            # 8. Check environment variables for project hints
            env_vars = container_data.get('Config', {}).get('Env', [])
            for env_var in env_vars:
                if env_var.startswith('PROJECT_NAME=') or env_var.startswith('APP_NAME='):
                    project_name = env_var.split('=', 1)[1]
                    if project_name:
                        return f"ðŸŒ {project_name}"
            
            # 9. Check working directory
            if working_dir and not any(path in working_dir for path in ['/app', '/usr', '/var', '/opt']):
                parts = working_dir.strip('/').split('/')
                if parts and parts[0] and parts[0] not in ['tmp', 'home']:
                    return f"ðŸ’¼ {parts[0]}"
            
        except (subprocess.CalledProcessError, json.JSONDecodeError, KeyError, IndexError):
            pass
        
        return ''

    def get_containers(self) -> List[Container]:
        containers = []
        try:
            result = subprocess.run(['docker', 'ps', '-a', '--format', 
                                   '{{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Status}}\t{{.Ports}}\t{{.CreatedAt}}'],
                                  capture_output=True, text=True, check=True)
            
            for line in result.stdout.strip().split('\n'):
                if line:
                    parts = line.split('\t')
                    if len(parts) >= 4:
                        container_id = parts[0]
                        container_name = parts[1]
                        project = self.detect_project(container_id, container_name)
                        
                        containers.append(Container(
                            container_id=container_id,
                            name=container_name,
                            image=parts[2],
                            status=parts[3],
                            ports=parts[4] if len(parts) > 4 else '',
                            created=parts[5] if len(parts) > 5 else '',
                            project=project
                        ))
        except subprocess.CalledProcessError:
            pass
        
        return containers

    def handle_navigation(self, num_options: int, extra_keys: List[str] = []) -> str:
        import sys
        import tty
        import termios

        fd = sys.stdin.fileno()
        old_settings = termios.tcgetattr(fd)
        
        try:
            tty.setraw(sys.stdin.fileno())
            ch = sys.stdin.read(1)
            
            if ch == '\x1b':
                ch2 = sys.stdin.read(1)
                ch3 = sys.stdin.read(1)
                if ch2 == '[':
                    if ch3 == 'A':
                        self.selected_index = max(0, self.selected_index - 1)
                        return 'navigate'
                    elif ch3 == 'B':
                        self.selected_index = min(num_options - 1, self.selected_index + 1)
                        return 'navigate'
            elif ch == '\r' or ch == '\n':
                return 'select'
            elif ch == 'q' or ch == '\x03':
                return 'quit'
            elif ch == 'b' or ch == '\x7f':
                return 'back'
            elif ch in extra_keys:
                return ch
            
            return 'navigate'
        finally:
            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)

    def cleanup(self):
        self.clear_screen()
        print(f"{Colors.CYAN}Thank you for using Docker Container Manager!{Colors.RESET}\n")

def main():
    try:
        manager = DockerManager()
        manager.start()
    except KeyboardInterrupt:
        print(f"\n{Colors.CYAN}Goodbye!{Colors.RESET}\n")
        sys.exit(0)
    except Exception as e:
        print(f"{Colors.RED}Fatal error: {e}{Colors.RESET}")
        sys.exit(1)

if __name__ == '__main__':
    main()