#!/usr/bin/env bash

source "${HOME}/.config/dotfiles/core/env"
source "${HOME}/.config/dotfiles/core/colors"
source "${HOME}/.config/dotfiles/core/safety"

# Secret manager configuration
export DOTFILES_SECRETS_DB="${DOTFILES_UTILS}/secrets.json"
export DOTFILES_SECRETS_KEY="${DOTFILES_UTILS}/.secrets.key"
export DOTFILES_SECRETS_SALT="${DOTFILES_UTILS}/.secrets.salt"

# Initialize secrets database if it doesn't exist
[[ ! -f "$DOTFILES_SECRETS_DB" ]] && echo '{}' > "$DOTFILES_SECRETS_DB"

# Generate encryption key and salt if they don't exist
function secrets_init() {
    if [[ ! -f "$DOTFILES_SECRETS_KEY" ]]; then
        echo.info "Generating encryption key..."
        openssl rand -hex 32 > "$DOTFILES_SECRETS_KEY"
        chmod 600 "$DOTFILES_SECRETS_KEY"
        echo.success "Encryption key generated"
    fi
    
    if [[ ! -f "$DOTFILES_SECRETS_SALT" ]]; then
        echo.info "Generating salt..."
        openssl rand -hex 16 > "$DOTFILES_SECRETS_SALT"
        chmod 600 "$DOTFILES_SECRETS_SALT"
        echo.success "Salt generated"
    fi
}

# Encrypt a value
function secrets_encrypt() {
    local value="$1"
    local key=$(cat "$DOTFILES_SECRETS_KEY")
    
    echo "$value" | openssl enc -aes-256-cbc -a -salt -pbkdf2 -iter 10000 -pass "pass:$key" 2>/dev/null
}

# Decrypt a value
function secrets_decrypt() {
    local encrypted_value="$1"
    local key=$(cat "$DOTFILES_SECRETS_KEY")
    echo "$encrypted_value" | openssl enc -aes-256-cbc -a -d -salt -pbkdf2 -iter 10000 -pass "pass:$key" 2>/dev/null
}

# List all secrets
function secrets_list() {
    echo.header "Stored Secrets"
    
    if [[ ! -f "$DOTFILES_SECRETS_DB" ]] || [[ $(stat -c%s "$DOTFILES_SECRETS_DB") -le 2 ]]; then
        echo.warning "No secrets stored"
        return 0
    fi
    
    jq -r 'to_entries | .[] | "\(.key) (\(.value.type)) - \(.value.description // "No description")"' "$DOTFILES_SECRETS_DB" 2>/dev/null | \
    while IFS=' ' read -r key type description; do
        echo.cyan "$key" | tr '\n' ' '
        echo "($type) - $description"
    done
}

# Resolve a clipboard command
function _secrets_clip_cmd() {
    if command -v wl-copy &>/dev/null; then
        echo "wl-copy"
        return 0
    fi
    if command -v xclip &>/dev/null; then
        echo "xclip -selection clipboard"
        return 0
    fi
    if command -v xsel &>/dev/null; then
        echo "xsel --clipboard --input"
        return 0
    fi
    if command -v pbcopy &>/dev/null; then
        echo "pbcopy"
        return 0
    fi
    return 1
}

# Copy provided text to the system clipboard
function _secrets_copy_to_clipboard() {
    local text="$1"
    local cmd=$(_secrets_clip_cmd)
    if [[ -n "$cmd" ]]; then
        # shellcheck disable=SC2086
        printf "%s" "$text" | eval $cmd
        return $?
    fi
    return 1
}

# Interactive picker for secret key using fzf
function _secrets_pick_key() {
    if ! command -v fzf &>/dev/null; then
        return 1
    fi
    if [[ ! -s "$DOTFILES_SECRETS_DB" ]]; then
        return 1
    fi
    local choice
    choice=$(jq -r 'to_entries | .[] | "\(.key)\t\(.value.type)\t\(.value.description // "")"' "$DOTFILES_SECRETS_DB" 2>/dev/null | \
        fzf --prompt="Select secret > " --with-nth=1,2,3 --ansi --delimiter='\t' --height=40% --layout=reverse --border)
    if [[ -n "$choice" ]]; then
        echo "$choice" | awk -F '\t' '{print $1}'
        return 0
    fi
    return 1
}

# Get a secret value
function secrets_get() {
    local copy_only=0
    local key=""
    local use_prefix=0
    local prefix_override=""
    local interactive_was_used=0

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -c|--copy) 
                copy_only=1
                shift
                ;; 
            -p|p|--pre) 
                use_prefix=1
                shift
                ;; 
            --prefix) 
                use_prefix=1
                shift
                if [[ -n "${1:-}" && ! "${1:-}" =~ ^- ]]; then
                    prefix_override="$1"; shift
                fi
                ;; 
            --prefix=*) 
                use_prefix=1
                prefix_override="${1#--prefix=}"
                shift
                ;; 
            *)
                if [[ -z "$key" ]]; then
                    key="$1"
                fi
                shift
                ;; 
        esac
    done

    if [[ -z "$key" ]]; then
        key=$(_secrets_pick_key)
        if [[ -z "$key" ]]; then
            echo.error "Provide a key or install fzf for interactive selection"
            return 1
        fi
        interactive_was_used=1
    fi
    
    local encrypted_value=$(jq -r --arg key "$key" '.[$key].value // empty' "$DOTFILES_SECRETS_DB" 2>/dev/null)
    local type=$(jq -r --arg key "$key" '.[$key].type // empty' "$DOTFILES_SECRETS_DB" 2>/dev/null)
    local stored_prefix=$(jq -r --arg key "$key" '.[$key].prefix // empty' "$DOTFILES_SECRETS_DB" 2>/dev/null)
    
    if [[ -n "$encrypted_value" ]]; then
        local decrypted_value=$(secrets_decrypt "$encrypted_value")
        if [[ -n "$decrypted_value" ]]; then
            local to_copy="$decrypted_value"

            # Interactive prompt for prefix if interactive mode and prefix desired
            if [[ $interactive_was_used -eq 1 && $use_prefix -eq 0 ]]; then
                read -r -p "Use prefix for '$key'? [y/N] " yn
                case "$yn" in
                    [Yy]*) use_prefix=1 ;; 
                    *)
                        use_prefix=0 ;; 
                esac
                if [[ $use_prefix -eq 1 && -z "$prefix_override" && -z "$stored_prefix" ]]; then
                    read -r -p "Enter prefix name: " prefix_override
                fi
            fi

            if [[ $use_prefix -eq 1 ]]; then
                local final_prefix="$prefix_override"
                if [[ -z "$final_prefix" ]]; then
                    final_prefix="$stored_prefix"
                fi
                if [[ -z "$final_prefix" ]]; then
                    echo.warning "No prefix provided or stored for '$key'; copying plain value"
                else
                    to_copy="${final_prefix}=${decrypted_value}"
                fi
            fi

            if _secrets_copy_to_clipboard "$to_copy"; then
                if [[ $use_prefix -eq 1 && -n "${prefix_override}${stored_prefix}" ]]; then
                    echo.success "Copied '${key}' as ${to_copy%%=*}=****** to clipboard ($type)"
                else
                    echo.success "Copied '$key' to clipboard ($type)"
                fi
            else
                echo.warning "Clipboard tool not found; printing secret"
                echo "$to_copy"
            fi
            if [[ $copy_only -eq 0 ]]; then
                echo.info "Secret: $key ($type)"
                echo "$to_copy"
            fi
        else
            echo.error "Failed to decrypt secret: $key"
            return 1
        fi
    else
        echo.error "Secret not found: $key"
        return 1
    fi
}

# Set a secret value
function secrets_set() {
    local key=""
    local value=""
    local type="generic"
    local prefix=""
    local description=""

    # Parse args: dotfiles-secrets set <key> <value> [type] [--prefix|-p <name>] [--desc <description>]
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --prefix|--pre|-p) 
                shift
                prefix="${1:-}"
                if [[ -z "$prefix" ]]; then
                    echo.error "Missing value for --prefix"
                    return 1
                fi
                shift
                ;; 
            --desc|--description) 
                shift
                description="${1:-}"
                shift
                ;; 
            *)
                if [[ -z "$key" ]]; then
                    key="$1"; shift; continue
                fi
                if [[ -z "$value" ]]; then
                    value="$1"; shift; continue
                fi
                if [[ "$type" == "generic" ]]; then
                    type="$1"; shift; continue
                fi
                shift
                ;; 
        esac
    done

    if [[ -z "$key" || -z "$value" ]]; then
        echo.error "Usage: dotfiles-secrets set <key> <value> [type] [--prefix <name>] [--desc <description>]"
        return 1
    fi
    
    if [[ "$key" =~ [^a-zA-Z0-9_-] ]]; then
        echo.error "Invalid secret name: $key (use only alphanumeric, underscore, and hyphen)"
        return 1
    fi
    
    # Initialize encryption if needed
    secrets_init
    
    local encrypted_value=$(secrets_encrypt "$value")
    if [[ -z "$encrypted_value" ]]; then
        echo.error "Failed to encrypt secret"
        return 1
    fi
    
    local now=$(date -Iseconds)
    jq --arg key "$key" \
       --arg value "$encrypted_value" \
       --arg type "$type" \
       --arg prefix "$prefix" \
       --arg description "$description" \
       --arg now "$now" \
       '.[$key] = {"value": $value, "type": $type, "prefix": $prefix, "description": $description, "created": $now}' \
       "$DOTFILES_SECRETS_DB" > "${DOTFILES_SECRETS_DB}.tmp" && \
    mv "${DOTFILES_SECRETS_DB}.tmp" "$DOTFILES_SECRETS_DB"
    
    echo.success "Secret '$key' stored as $type"
}

# Remove a secret
function secrets_remove() {
    local key="$1"
    
    if [[ -z "$key" ]]; then
        echo.error "Usage: dotfiles-secrets remove <key>"
        return 1
    fi
    
    jq --arg key "$key" 'del(.[$key])' "$DOTFILES_SECRETS_DB" > "${DOTFILES_SECRETS_DB}.tmp" && \
    mv "${DOTFILES_SECRETS_DB}.tmp" "$DOTFILES_SECRETS_DB"
    
    echo.success "Secret '$key' removed"
}

# Export secrets to environment variables (simplified approach)
function secrets_export() {
    echo.info "Exporting secrets to environment variables..."
    
    local count=0
    local temp_file=$(mktemp)
    jq -r 'to_entries | .[] | "\(.key):\(.value.value)"' "$DOTFILES_SECRETS_DB" 2>/dev/null > "$temp_file"
    
    while IFS=':' read -r key encrypted_value; do
        if [[ -n "$key" && -n "$encrypted_value" ]]; then
            local decrypted_value=$(secrets_decrypt "$encrypted_value")
            if [[ -n "$decrypted_value" ]]; then
                printf 'export %s="%s";\n' "$key" "$decrypted_value"
                ((count++))
            fi
        fi
    done < "$temp_file"
    
    rm -f "$temp_file"
    echo.success "Exported $count secrets"
}

# Import secrets from a file
function secrets_import() {
    local file="${1:-$HOME/.secrets}"
    
    if [[ ! -f "$file" ]]; then
        echo.error "File not found: $file"
        return 1
    fi
    
    echo.info "Importing secrets from: $file"
    
    local count=0
    while IFS='=' read -r key value; do
        [[ -z "$key" || "$key" =~ ^[[:space:]]*# ]] && continue
        
        key="${key#export }"
        key="${key// /}"
        value="${value//\"/}"
        
        if [[ -n "$key" && -n "$value" ]]; then
            secrets_set "$key" "$value" "imported"
            ((count++))
        fi
    done < "$file"
    
    echo.success "Imported $count secrets"
}

# Generate a random secret
function secrets_generate() {
    local key="$1"
    local length="${2:-32}"
    local type="${3:-random}"
    
    if [[ -z "$key" ]]; then
        echo.error "Usage: dotfiles-secrets generate <key> [length] [type]"
        return 1
    fi
    
    local random_value=$(openssl rand -base64 "$length" | tr -d "=+/" | cut -c1-"$length")
    secrets_set "$key" "$random_value" "$type"
    
    echo.success "Generated random secret '$key' with length $length"
}

# Search secrets (using pattern from tokens)
function secrets_search() {
    local query="$1"
    
    if [[ -z "$query" ]]; then
        echo.error "Usage: dotfiles-secrets search <query>"
        return 1
    fi
    
    echo.info "Searching for secrets matching: $query"
    
    jq -r --arg query "$query" 'to_entries | .[] | select(.key | contains($query) or .value.type | contains($query) or .value.description | contains($query)) | "\(.key) (\(.value.type)) - \(.value.description // "No description")"' "$DOTFILES_SECRETS_DB" 2>/dev/null | \
    while IFS=' ' read -r key type description; do
        if [[ -n "$key" ]]; then
            echo.cyan "$key" | tr '\n' ' '
            echo "($type) - $description"
        fi
    done
}

# Backup secrets database
function secrets_backup() {
    local backup_dir="${DOTFILES_UTILS}/backups"
    local timestamp=$(date +%Y%m%d_%H%M%S)
    local backup_file="${backup_dir}/secrets_${timestamp}.json"
    
    [[ ! -d "$backup_dir" ]] && mkdir -p "$backup_dir"
    
    cp "$DOTFILES_SECRETS_DB" "$backup_file"
    echo.success "Secrets backed up to: $backup_file"
}

# Restore secrets database
function secrets_restore() {
    local backup_file="$1"
    
    if [[ -z "$backup_file" ]]; then
        echo.error "Usage: dotfiles-secrets restore <backup_file>"
        return 1
    fi
    
    if [[ ! -f "$backup_file" ]]; then
        echo.error "Backup file not found: $backup_file"
        return 1
    fi
    
    cp "$backup_file" "$DOTFILES_SECRETS_DB"
    echo.success "Secrets restored from: $backup_file"
}

# Show secrets info
function secrets_info() {
    local key="$1"
    
    if [[ -z "$key" ]]; then
        echo.header "Secrets Database Info"
        echo.info "Database: $DOTFILES_SECRETS_DB"
        echo.info "Encryption: AES-256-CBC with PBKDF2"
        echo.info "Total secrets: $(jq 'length' "$DOTFILES_SECRETS_DB" 2>/dev/null || echo '0')"
        echo.info "Last modified: $(stat -c %y "$DOTFILES_SECRETS_DB" 2>/dev/null || echo 'Unknown')"
    else
        local secret_info=$(jq --arg key "$key" '.[$key]' "$DOTFILES_SECRETS_DB" 2>/dev/null)
        if [[ "$secret_info" != "null" ]]; then
            echo.header "Secret: $key"
            echo "$secret_info" | jq -r 'to_entries | .[] | "\(.key): \(.value)"'
        else
            echo.error "Secret not found: $key"
            return 1
        fi
    fi
}

# Main function
function main() {
    local command="$1"
    shift
    
    case "$command" in
        "list"|"ls")
            secrets_list
            ;; 
        "get")
            secrets_get "$@"
            ;; 
        "set")
            secrets_set "$@"
            ;; 
        "remove"|"rm")
            secrets_remove "$@"
            ;; 
        "export")
            secrets_export
            ;; 
        "import")
            secrets_import "$@"
            ;; 
        "generate"|"gen")
            secrets_generate "$@"
            ;; 
        "search")
            secrets_search "$@"
            ;; 
        "backup")
            secrets_backup
            ;; 
        "restore")
            secrets_restore "$@"
            ;; 
        "info")
            secrets_info "$@"
            ;; 
        "init")
            secrets_init
            ;; 
        "help"|"--help"|"-h"|"")
            echo.header "Dotfiles Secrets Manager"
            echo
            echo.info "Usage: dotfiles-secrets <command> [options]"
            echo
            echo.info "Commands:"
            echo.cyan "  list, ls" | tr '\n' ' '
            echo "     - List all stored secrets"
            echo.cyan "  get [--copy|-c] [--prefix|-p[=NAME]] [key]" | tr '\n' ' '
            echo "     - Get a secret value; interactive if key omitted; copies to clipboard"
            echo.cyan "  set <key> <value> [type] [--prefix <name>] [--desc <description>]" | tr '\n' ' '
            echo "     - Store a secret with optional type, prefix and description"
            echo.cyan "  remove, rm <key>" | tr '\n' ' '
            echo "     - Remove a secret"
            echo.cyan "  export" | tr '\n' ' '
            echo "     - Export secrets to environment variables"
            echo.cyan "  import [file]" | tr '\n' ' '
            echo "     - Import secrets from file"
            echo.cyan "  generate, gen <key> [length] [type]" | tr '\n' ' '
            echo "     - Generate a random secret"
            echo.cyan "  search <query>" | tr '\n' ' '
            echo "     - Search secrets by name, type or description"
            echo.cyan "  backup" | tr '\n' ' '
            echo "     - Backup secrets database"
            echo.cyan "  restore <file>" | tr '\n' ' '
            echo "     - Restore secrets from backup"
            echo.cyan "  info [key]" | tr '\n' ' '
            echo "     - Show database info or secret details"
            echo.cyan "  init" | tr '\n' ' '
            echo "     - Initialize encryption keys"
            echo.cyan "  help" | tr '\n' ' '
            echo "     - Show this help message"
            echo
            echo.info "Examples:"
            echo "  dotfiles-secrets set GITHUB_TOKEN abc123 api --desc 'GitHub API token'"
            echo "  dotfiles-secrets get GITHUB_TOKEN"
            echo "  dotfiles-secrets get                    # Interactive selection"
            echo "  dotfiles-secrets get --copy             # Interactive selection, copy only"
            echo "  dotfiles-secrets set API_KEY abc api --prefix MYAPI"
            echo "  dotfiles-secrets get -p API_KEY         # Copies as MYAPI=<value> if prefix stored"
            echo "  dotfiles-secrets get --prefix=FOO API_KEY  # Copies as FOO=<value>"
            ;; 
        *)
            echo.error "Unknown command: $command"
            echo.info "Run 'dotfiles-secrets help' for usage information"
            return 1
            ;; 
    esac
}

# Run main function with all arguments
main "$@"
