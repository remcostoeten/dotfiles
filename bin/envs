#!/usr/bin/env bash

source "$HOME/.config/dotfiles/core/_constants"
source "$HOME/.config/dotfiles/core/_constants"
source "$DOTFILES_UTILS/colors"

function envs_help() {
    echo.header "Dotfiles Environment Manager"
    echo
    echo "Usage: $(basename $0) [command] [options]"
    echo
    echo "Commands:"
    echo "  list              List all managed environment variables"
    echo "  get <key>         Get value of an environment variable"
    echo "  set <key> <value> Set an environment variable"
    echo "  unset <key>       Remove an environment variable"
    echo "  search <pattern>  Search for variables matching pattern"
    echo "  export            Export all variables to current shell"
    echo "  import <file>     Import variables from .env file"
    echo
    echo "Examples:"
    echo "  $(basename $0) list"
    echo "  $(basename $0) set EDITOR nvim"
    echo "  $(basename $0) get PATH"
    echo "  $(basename $0) search API"
    echo "  $(basename $0) import ~/project/.env"
}

function envs_read_db() {
    if [[ -f "$DOTFILES_ENV_DB" ]]; then
        cat "$DOTFILES_ENV_DB"
    else
        echo '{}'
    fi
}

function envs_write_db() {
    local data="$1"
    echo "$data" > "$DOTFILES_ENV_DB"
}

function envs_list() {
    echo.header "Environment Variables"
    
    local db=$(envs_read_db)
    
    if [[ "$db" == "{}" ]]; then
        echo.warning "No environment variables defined"
        return 0
    fi
    
    echo "$db" | jq -r 'to_entries | .[] | "\(.key)=\(.value)"' | while IFS= read -r line; do
        local key="${line%%=*}"
        local value="${line#*=}"
        
        if [[ "${#value}" -gt 50 ]]; then
            value="${value:0:47}..."
        fi
        
        printf "${COLOR_CYAN}%-20s${COLOR_RESET} = ${COLOR_GREEN}%s${COLOR_RESET}\n" "$key" "$value"
    done
}

function envs_get() {
    local key="$1"
    
    if [[ -z "$key" ]]; then
        echo.error "Usage: $(basename $0) get <key>"
        return 1
    fi
    
    local db=$(envs_read_db)
    local value=$(echo "$db" | jq -r --arg key "$key" '.[$key] // empty')
    
    if [[ -n "$value" ]]; then
        echo.info "$key = $value"
        
        if [[ -n "${!key}" ]]; then
            local current="${!key}"
            if [[ "$current" != "$value" ]]; then
                echo.warning "Current shell value differs: $current"
            fi
        else
            echo.warning "Not exported in current shell"
        fi
    else
        echo.error "Variable not found: $key"
        
        if [[ -n "${!key}" ]]; then
            echo.info "Current shell value: ${!key}"
        fi
        
        return 1
    fi
}

function envs_set() {
    local key="$1"
    local value="$2"
    
    if [[ -z "$key" || -z "$value" ]]; then
        echo.error "Usage: $(basename $0) set <key> <value>"
        return 1
    fi
    
    if [[ ! "$key" =~ ^[A-Za-z_][A-Za-z0-9_]*$ ]]; then
        echo.error "Invalid variable name: $key"
        echo.info "Variable names must start with a letter or underscore"
        return 1
    fi
    
    local db=$(envs_read_db)
    local old_value=$(echo "$db" | jq -r --arg key "$key" '.[$key] // empty')
    
    if [[ -n "$old_value" ]]; then
        echo.warning "Overwriting existing value:"
        echo.dim "  Old: $old_value"
        echo.bright_green "  New: $value"
    fi
    
    local new_db=$(echo "$db" | jq --arg key "$key" --arg value "$value" '. + {($key): $value}')
    envs_write_db "$new_db"
    
    export "$key=$value"
    
    echo.success "Set $key = $value"
    echo.info "Exported to current shell"
    echo.warning "Run 'reload' to persist in new shells"
}

function envs_unset() {
    local key="$1"
    
    if [[ -z "$key" ]]; then
        echo.error "Usage: $(basename $0) unset <key>"
        return 1
    fi
    
    local db=$(envs_read_db)
    local value=$(echo "$db" | jq -r --arg key "$key" '.[$key] // empty')
    
    if [[ -z "$value" ]]; then
        echo.warning "Variable not found: $key"
        return 1
    fi
    
    local new_db=$(echo "$db" | jq --arg key "$key" 'del(.[$key])')
    envs_write_db "$new_db"
    
    unset "$key"
    
    echo.success "Removed $key"
    echo.info "Unset from current shell"
}

function envs_search() {
    local pattern="$1"
    
    if [[ -z "$pattern" ]]; then
        echo.error "Usage: $(basename $0) search <pattern>"
        return 1
    fi
    
    echo.header "Search Results for: $pattern"
    
    local db=$(envs_read_db)
    local results=$(echo "$db" | jq -r --arg pattern "$pattern" '
        to_entries | 
        map(select(.key | test($pattern; "i")) + select(.value | test($pattern; "i"))) |
        unique |
        .[] | 
        "\(.key)=\(.value)"
    ')
    
    if [[ -z "$results" ]]; then
        echo.warning "No matches found"
        return 0
    fi
    
    echo "$results" | while IFS= read -r line; do
        local key="${line%%=*}"
        local value="${line#*=}"
        
        if [[ "${#value}" -gt 50 ]]; then
            value="${value:0:47}..."
        fi
        
        key_colored=$(echo "$key" | sed "s/$pattern/${COLOR_YELLOW}${COLOR_BOLD}&${COLOR_RESET}${COLOR_CYAN}/gi")
        value_colored=$(echo "$value" | sed "s/$pattern/${COLOR_YELLOW}${COLOR_BOLD}&${COLOR_RESET}${COLOR_GREEN}/gi")
        
        printf "${COLOR_CYAN}%-20s${COLOR_RESET} = ${COLOR_GREEN}%s${COLOR_RESET}\n" "$key_colored" "$value_colored"
    done
}

function envs_export() {
    echo.header "Exporting All Variables"
    
    local db=$(envs_read_db)
    
    if [[ "$db" == "{}" ]]; then
        echo.warning "No variables to export"
        return 0
    fi
    
    local count=0
    echo "$db" | jq -r 'to_entries | .[] | "\(.key)=\(.value)"' | while IFS= read -r line; do
        export "$line"
        count=$((count + 1))
        echo.success "Exported: ${line%%=*}"
    done
    
    echo
    echo.info "Exported $count variables to current shell"
}

function envs_import() {
    local file="$1"
    
    if [[ -z "$file" ]]; then
        echo.error "Usage: $(basename $0) import <file>"
        return 1
    fi
    
    if [[ ! -f "$file" ]]; then
        echo.error "File not found: $file"
        return 1
    fi
    
    echo.header "Importing from: $file"
    
    local db=$(envs_read_db)
    local count=0
    local skipped=0
    
    while IFS= read -r line; do
        [[ -z "$line" ]] && continue
        [[ "$line" =~ ^[[:space:]]*# ]] && continue
        [[ ! "$line" =~ = ]] && continue
        
        local key="${line%%=*}"
        local value="${line#*=}"
        
        key=$(echo "$key" | tr -d '[:space:]')
        value=$(echo "$value" | sed 's/^["'\'']\(.*\)["'\'']$/\1/')
        
        if [[ ! "$key" =~ ^[A-Za-z_][A-Za-z0-9_]*$ ]]; then
            echo.warning "Skipping invalid key: $key"
            skipped=$((skipped + 1))
            continue
        fi
        
        db=$(echo "$db" | jq --arg key "$key" --arg value "$value" '. + {($key): $value}')
        count=$((count + 1))
        echo.success "Imported: $key"
    done < "$file"
    
    envs_write_db "$db"
    
    echo
    echo.info "Imported: $count, Skipped: $skipped"
    echo.warning "Run 'reload' to load in new shells"
}

if ! command -v jq &>/dev/null; then
    echo.error "jq is required for JSON operations"
    echo.info "Install with: sudo apt install jq"
    exit 1
fi

case "${1:-help}" in
    list|ls)
        envs_list
        ;;
    get)
        envs_get "$2"
        ;;
    set)
        envs_set "$2" "$3"
        ;;
    unset|rm)
        envs_unset "$2"
        ;;
    search|find)
        envs_search "$2"
        ;;
    export)
        envs_export
        ;;
    import)
        envs_import "$2"
        ;;
    help|--help|-h)
        envs_help
        ;;
    *)
        echo.error "Unknown command: $1"
        envs_help
        exit 1
        ;;
esac
