#!/usr/bin/env bash

# dotfiles-env - Environment Variable Manager
# Provides CRUD operations for environment variables with JSON persistence
# Usage: dotfiles-env <command> [args...]

set -euo pipefail

# Source core functions
DOTFILES_ROOT="${DOTFILES_ROOT:-$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)}"
source "$DOTFILES_ROOT/core/_colors" 2>/dev/null || true
source "$DOTFILES_ROOT/core/_safety" 2>/dev/null || true

# Configuration
ENV_FILE="${DOTFILES_ROOT}/utils/env.json"
ENV_BACKUP_DIR="${DOTFILES_ROOT}/backups/env"

# Ensure directories exist
ensure_dir() {
    [[ -d "$1" ]] || mkdir -p "$1"
}

# Initialize env.json if it doesn't exist
init_env_file() {
    if [[ ! -f "$ENV_FILE" ]]; then
        ensure_dir "$(dirname "$ENV_FILE")"
        echo '{}' > "$ENV_FILE"
        echo.success "Initialized environment registry at $ENV_FILE"
    fi
}

# Validate JSON file
validate_json() {
    if ! jq empty "$ENV_FILE" 2>/dev/null; then
        echo.error "Invalid JSON in $ENV_FILE"
        return 1
    fi
}

# Generate random value
generate_random() {
    local length="${1:-32}"
    openssl rand -hex "$length" 2>/dev/null || \
    head -c "$length" /dev/urandom | base64 | tr -d '/+=' | head -c "$length"
}

# Generate OAuth key pair
generate_oauth() {
    local name="$1"
    local type="${2:-rsa}"
    local bits="${3:-4096}"
    local description="${4:-OAuth Key Pair}"
    
    local private_key public_key
    
    case "$type" in
        rsa)
            private_key=$(openssl genrsa "$bits" 2>/dev/null | base64 -w 0)
            public_key=$(echo "$private_key" | base64 -d | openssl rsa -pubout 2>/dev/null | base64 -w 0)
            ;;
        *)
            echo.error "Unsupported key type: $type"
            return 1
            ;;
    esac
    
    # Store both keys
    set_env_var "${name}_PRIVATE_KEY" "$private_key" "OAuth Private Key - $description"
    set_env_var "${name}_PUBLIC_KEY" "$public_key" "OAuth Public Key - $description"
    
    echo.success "Generated OAuth key pair: ${name}_PRIVATE_KEY and ${name}_PUBLIC_KEY"
}

# Set environment variable
set_env_var() {
    local key="$1"
    local value="$2"
    local description="${3:-}"
    
    init_env_file
    validate_json
    
    local timestamp=$(date -Iseconds)
    local entry
    
    if [[ -n "$description" ]]; then
        entry=$(jq -n --arg key "$key" --arg value "$value" --arg desc "$description" --arg ts "$timestamp" \
            '{key: $key, value: $value, description: $desc, created: $ts, updated: $ts}')
    else
        entry=$(jq -n --arg key "$key" --arg value "$value" --arg ts "$timestamp" \
            '{key: $key, value: $value, created: $ts, updated: $ts}')
    fi
    
    # Update or create entry
    if jq -e --arg key "$key" '.[$key]' "$ENV_FILE" > /dev/null; then
        # Update existing
        local created=$(jq -r --arg key "$key" '.[$key].created // ""' "$ENV_FILE")
        if [[ -n "$description" ]]; then
            jq --arg key "$key" --arg value "$value" --arg desc "$description" --arg ts "$timestamp" --arg created "$created" \
                '.[$key] = {key: $key, value: $value, description: $desc, created: ($created // $ts), updated: $ts}' \
                "$ENV_FILE" > "$ENV_FILE.tmp" && mv "$ENV_FILE.tmp" "$ENV_FILE"
        else
            jq --arg key "$key" --arg value "$value" --arg ts "$timestamp" --arg created "$created" \
                '.[$key] = {key: $key, value: $value, created: ($created // $ts), updated: $ts}' \
                "$ENV_FILE" > "$ENV_FILE.tmp" && mv "$ENV_FILE.tmp" "$ENV_FILE"
        fi
        echo.success "Updated environment variable: $key"
    else
        # Create new
        jq --arg key "$key" --argjson entry "$entry" '.[$key] = $entry' \
            "$ENV_FILE" > "$ENV_FILE.tmp" && mv "$ENV_FILE.tmp" "$ENV_FILE"
        echo.success "Set environment variable: $key"
    fi
    
    # Export for current session
    export "$key=$value"
}

# Get environment variable
get_env_var() {
    local key="$1"
    
    init_env_file
    validate_json
    
    local value
    if [[ -n "$key" ]]; then
        value=$(jq -r --arg key "$key" '.[$key].value // empty' "$ENV_FILE")
        if [[ -n "$value" ]]; then
            echo "$value"
            # Copy to clipboard if available
            if command -v xclip >/dev/null 2>&1; then
                echo -n "$value" | xclip -selection clipboard
                echo.info "Value copied to clipboard"
            elif command -v pbcopy >/dev/null 2>&1; then
                echo -n "$value" | pbcopy
                echo.info "Value copied to clipboard"
            fi
        else
            echo.error "Environment variable not found: $key"
            return 1
        fi
    else
        # Interactive selection with fzf if available
        if command -v fzf >/dev/null 2>&1; then
            local selected
            selected=$(jq -r 'to_entries[] | "\(.key)\t\(.value.description // "No description")"' "$ENV_FILE" | \
                fzf --delimiter='\t' --with-nth=1,2 --preview 'echo {2}' | cut -f1)
            if [[ -n "$selected" ]]; then
                get_env_var "$selected"
            fi
        else
            echo.error "No key specified and fzf not available for interactive selection"
            return 1
        fi
    fi
}

# Remove environment variable
remove_env_var() {
    local key="$1"
    
    init_env_file
    validate_json
    
    if [[ -n "$key" ]]; then
        if jq -e --arg key "$key" '.[$key]' "$ENV_FILE" > /dev/null; then
            jq --arg key "$key" 'del(.[$key])' "$ENV_FILE" > "$ENV_FILE.tmp" && mv "$ENV_FILE.tmp" "$ENV_FILE"
            echo.success "Removed environment variable: $key"
            # Unset from current session
            unset "$key" 2>/dev/null || true
        else
            echo.error "Environment variable not found: $key"
            return 1
        fi
    else
        # Interactive selection with fzf if available
        if command -v fzf >/dev/null 2>&1; then
            local selected
            selected=$(jq -r 'to_entries[] | "\(.key)\t\(.value.description // "No description")"' "$ENV_FILE" | \
                fzf --delimiter='\t' --with-nth=1,2 --preview 'echo {2}' | cut -f1)
            if [[ -n "$selected" ]]; then
                remove_env_var "$selected"
            fi
        else
            echo.error "No key specified and fzf not available for interactive selection"
            return 1
        fi
    fi
}

# List environment variables
list_env_vars() {
    init_env_file
    validate_json
    
    local count
    count=$(jq 'length' "$ENV_FILE")
    
    if [[ "$count" -eq 0 ]]; then
        echo.info "No environment variables stored"
        return 0
    fi
    
    echo.header "Environment Variables ($count)"
    echo
    
    # Format output
    jq -r 'to_entries[] | 
        "\(.key):\n  Value: \(.value.value | if length > 50 then .[:47] + "..." else . end)\n  Description: \(.value.description // "No description")\n  Created: \(.value.created // "Unknown")\n  Updated: \(.value.updated // "Unknown")\n"' \
        "$ENV_FILE"
}

# Search environment variables
search_env_vars() {
    local query="$1"
    
    init_env_file
    validate_json
    
    echo.header "Search Results for: $query"
    echo
    
    jq -r --arg query "$query" '
        to_entries[] | 
        select(
            (.key | ascii_downcase | contains($query | ascii_downcase)) or 
            (.value.description // "" | ascii_downcase | contains($query | ascii_downcase)) or
            (.value.value | ascii_downcase | contains($query | ascii_downcase))
        ) |
        "\(.key):\n  Value: \(.value.value | if length > 50 then .[:47] + "..." else . end)\n  Description: \(.value.description // "No description")\n"' \
        "$ENV_FILE"
}

# Export to file
export_env_vars() {
    local output_file="$1"
    
    init_env_file
    validate_json
    
    case "${output_file##*.}" in
        json)
            cp "$ENV_FILE" "$output_file"
            echo.success "Exported environment variables to: $output_file"
            ;;
        env)
            jq -r 'to_entries[] | "\(.key)=\(.value.value)"' "$ENV_FILE" > "$output_file"
            echo.success "Exported environment variables to: $output_file"
            ;;
        *)
            # Default to .env format
            jq -r 'to_entries[] | "\(.key)=\(.value.value)"' "$ENV_FILE" > "$output_file"
            echo.success "Exported environment variables to: $output_file"
            ;;
    esac
}

# Import from file
import_env_vars() {
    local input_file="$1"
    
    if [[ ! -f "$input_file" ]]; then
        echo.error "File not found: $input_file"
        return 1
    fi
    
    init_env_file
    
    local count=0
    case "${input_file##*.}" in
        json)
            # Import JSON format
            if jq empty "$input_file" 2>/dev/null; then
                jq -s '.[0] * .[1]' "$ENV_FILE" "$input_file" > "$ENV_FILE.tmp" && mv "$ENV_FILE.tmp" "$ENV_FILE"
                count=$(jq 'length' "$input_file")
                echo.success "Imported $count environment variables from: $input_file"
            else
                echo.error "Invalid JSON file: $input_file"
                return 1
            fi
            ;;
        *)
            # Import .env format
            while IFS='=' read -r key value; do
                if [[ -n "$key" && ! "$key" =~ ^# ]]; then
                    set_env_var "$key" "$value" "Imported from $input_file"
                    ((count++))
                fi
            done < "$input_file"
            echo.success "Imported $count environment variables from: $input_file"
            ;;
    esac
}

# Backup environment variables
backup_env_vars() {
    ensure_dir "$ENV_BACKUP_DIR"
    
    local timestamp=$(date +%Y%m%d_%H%M%S)
    local backup_file="$ENV_BACKUP_DIR/env_backup_$timestamp.json"
    
    if [[ -f "$ENV_FILE" ]]; then
        cp "$ENV_FILE" "$backup_file"
        echo.success "Backup created: $backup_file"
    else
        echo.warning "No environment file to backup"
    fi
}

# Restore from backup
restore_env_vars() {
    local backup_file="$1"
    
    if [[ ! -f "$backup_file" ]]; then
        echo.error "Backup file not found: $backup_file"
        return 1
    fi
    
    if jq empty "$backup_file" 2>/dev/null; then
        cp "$backup_file" "$ENV_FILE"
        echo.success "Restored environment variables from: $backup_file"
    else
        echo.error "Invalid backup file: $backup_file"
        return 1
    fi
}

# Show enhanced help
show_help() {
    echo.header "üîê Environment Variable Manager (dotfiles-env)"
    echo
    echo.cyan "USAGE:"
    echo "  dotfiles-env <command> [arguments]"
    echo "  dotfiles-env interactive            # Interactive mode"
    echo
    echo.purple "INTERACTIVE MODE:"
    echo "  env i                        # Start interactive mode"
    echo "  env interactive              # Start interactive mode"
    echo "  env --i                      # Start interactive mode"
    echo "  env --interactive            # Start interactive mode"
    echo
    echo.purple "BASIC OPERATIONS:"
    echo "  list                         List all environment variables"
    echo "  get [key]                    Get environment variable (interactive if no key)"
    echo "  set <key> <value> [desc]     Set environment variable with optional description"
    echo "  remove [key]                 Remove environment variable (interactive if no key)"
    echo "  search <query>               Search variables by key, value, or description"
    echo
    echo.purple "ADVANCED FEATURES:"
    echo "  generate <key> [length]      Generate random secret (default: 32 chars)"
    echo "  generate-oauth <name> [type] [bits] [desc]  Generate OAuth key pair"
    echo
    echo.purple "DATA MANAGEMENT:"
    echo "  export <file>                Export to .env or .json format"
    echo "  import <file>                Import from .env or .json file"
    echo "  backup                       Create timestamped backup"
    echo "  restore <backup_file>        Restore from backup file"
    echo
    echo.purple "BASIC EXAMPLES:"
    echo "  env set API_KEY 'abc123' 'Production API key'"
    echo "  env get API_KEY                              # Returns value + copies to clipboard"
    echo "  env list                                     # Show all variables with details"
    echo "  env search 'github'                         # Find GitHub-related variables"
    echo
    echo.purple "ADVANCED EXAMPLES:"
    echo "  env generate SESSION_SECRET 64               # Generate 64-char random secret"
    echo "  env generate-oauth GITHUB_APP rsa 4096 'App keys'  # Generate OAuth key pair"
    echo "  env export ~/.env.backup                     # Export to .env format"
    echo "  env import ~/.env.production                 # Import production variables"
    echo
    echo.purple "ALIASES & SHORTCUTS:"
    echo "  envs list                    # Quick list command"
    echo "  envs get [key]               # Quick get command (interactive if no key)"
    echo "  envs set <key> <value>       # Quick set command"
    echo
    echo.cyan "INTERACTIVE FEATURES:"
    echo "‚Ä¢ Beautiful menu-driven interface with numbered options"
    echo "‚Ä¢ Smart fuzzy search integration (fzf) for variable selection"
    echo "‚Ä¢ Confirmation dialogs for destructive operations"
    echo "‚Ä¢ Built-in help for each operation"
    echo "‚Ä¢ Clipboard integration - retrieved values copied automatically"
    echo
    echo.cyan "FILE FORMATS:"
    echo "‚Ä¢ JSON: Full metadata preservation (recommended for backups)"
    echo "‚Ä¢ .env: Standard format for application configuration"
    echo "‚Ä¢ Auto-detection based on file extension"
    echo
    echo.info "üí° Pro tip: Use interactive mode (env i) for the best user experience!"
    echo.warning "‚ö†  All values are stored as-is - consider encryption for sensitive data"
}

# Wait for user input
wait_for_input() {
    echo
    echo -n "$(echo.purple 'Press any key to continue...')" 
    read -n 1 -s
    echo
}

# Interactive mode main menu
show_interactive_menu() {
    clear
    echo.header "üîê Environment Variable Manager - Interactive Mode"
    echo
    
    local count
    count=$(jq 'length' "$ENV_FILE" 2>/dev/null || echo "0")
    echo.cyan "üìä Current Status: $count environment variables stored"
    echo
    
    echo.purple "MAIN MENU:"
    echo "  1) üìã List all variables"
    echo "  2) üîç Search variables"
    echo "  3) ‚ûï Add new variable"
    echo "  4) üìñ Get variable value"
    echo "  5) ‚úèÔ∏è  Edit/Update variable"
    echo "  6) üóëÔ∏è  Remove variable"
    echo
    echo "  7) üé≤ Generate random secret"
    echo "  8) üîë Generate OAuth key pair"
    echo
    echo "  9) üíæ Data management (backup, restore, import, export)"
    echo "  0) ‚ùì Help"
    echo
    echo "  q) üö™ Quit"
    echo
}

# Interactive data management submenu
show_data_management_menu() {
    clear
    echo.header "üíæ Data Management"
    echo
    
    echo.purple "DATA OPERATIONS:"
    echo "  1) üì§ Export variables"
    echo "  2) üì• Import variables"
    echo "  3) üíæ Create backup"
    echo "  4) üîÑ Restore from backup"
    echo "  5) üìä Show storage info"
    echo
    echo "  b) ‚¨ÖÔ∏è  Back to main menu"
    echo "  q) üö™ Quit"
    echo
}

# Interactive list with pagination
interactive_list() {
    clear
    echo.header "üìã Environment Variables List"
    echo
    
    init_env_file
    validate_json
    
    local count
    count=$(jq 'length' "$ENV_FILE")
    
    if [[ "$count" -eq 0 ]]; then
        echo.info "No environment variables stored yet."
        echo.cyan "Use option 3 from the main menu to add your first variable!"
        wait_for_input
        return 0
    fi
    
    echo.cyan "Found $count environment variable(s):"
    echo
    
    # Enhanced listing with better formatting
    jq -r 'to_entries[] | 
        "üîπ \(.key)\n  üìù Value: \(.value.value | if length > 60 then .[:57] + "..." else . end)\n  üìñ Description: \(.value.description // "No description")\n  üìÖ Created: \(.value.created // "Unknown")\n  üîÑ Updated: \(.value.updated // "Unknown")\n"' \
        "$ENV_FILE"
    
    wait_for_input
}

# Interactive search
interactive_search() {
    clear
    echo.header "üîç Search Environment Variables"
    echo
    
    echo.cyan "Enter search term (searches keys, values, and descriptions):"
    echo -n "$(echo.purple 'Search'): "
    read -r query
    
    if [[ -z "$query" ]]; then
        echo.warning "Search query cannot be empty"
        wait_for_input
        return 1
    fi
    
    echo
    echo.info "Searching for: '$query'"
    echo
    
    local results
    results=$(jq -r --arg query "$query" '
        to_entries[] | 
        select(
            (.key | ascii_downcase | contains($query | ascii_downcase)) or 
            (.value.description // "" | ascii_downcase | contains($query | ascii_downcase)) or
            (.value.value | ascii_downcase | contains($query | ascii_downcase))
        ) |
        "üîπ \(.key)\n  üìù Value: \(.value.value | if length > 60 then .[:57] + "..." else . end)\n  üìñ Description: \(.value.description // "No description")\n"' \
        "$ENV_FILE")
    
    if [[ -z "$results" ]]; then
        echo.warning "No matches found for '$query'"
    else
        echo.success "Search results:"
        echo
        echo "$results"
    fi
    
    wait_for_input
}

# Interactive add variable
interactive_add() {
    clear
    echo.header "‚ûï Add New Environment Variable"
    echo
    
    local key value description
    
    # Get key
    while true; do
        echo -n "$(echo.cyan 'Variable name'): "
        read -r key
        
        if [[ -z "$key" ]]; then
            echo.error "Variable name cannot be empty"
            continue
        fi
        
        if [[ "$key" =~ [[:space:]] ]]; then
            echo.error "Variable name cannot contain spaces"
            continue
        fi
        
        # Check if exists
        if jq -e --arg key "$key" '.[$key]' "$ENV_FILE" > /dev/null 2>&1; then
            echo.warning "Variable '$key' already exists"
            echo -n "$(echo.purple 'Overwrite? (y/n)'): "
            read -r overwrite
            case "$overwrite" in
                y|Y|yes|YES) break ;;
                *) continue ;;
            esac
        fi
        break
    done
    
    # Get value
    echo -n "$(echo.cyan 'Variable value'): "
    read -r value
    
    if [[ -z "$value" ]]; then
        echo.warning "Empty value - are you sure?"
        echo -n "$(echo.purple 'Continue with empty value? (y/n)'): "
        read -r continue_empty
        case "$continue_empty" in
            y|Y|yes|YES) ;;
            *) echo.info "Cancelled"; wait_for_input; return 1 ;;
        esac
    fi
    
    # Get description
    echo -n "$(echo.cyan 'Description (optional)'): "
    read -r description
    
    # Confirm
    echo
    echo.header "Confirm Variable Details"
    echo "  Name: $key"
    echo "  Value: ${value:0:50}$([ ${#value} -gt 50 ] && echo '...')"
    echo "  Description: ${description:-'(none)'}"
    echo
    
    echo -n "$(echo.purple 'Save this variable? (y/n)'): "
    read -r confirm
    
    case "$confirm" in
        y|Y|yes|YES)
            if set_env_var "$key" "$value" "$description"; then
                echo.success "‚úÖ Variable '$key' saved successfully!"
            else
                echo.error "‚ùå Failed to save variable"
            fi
            ;;
        *)
            echo.info "Cancelled"
            ;;
    esac
    
    wait_for_input
}

# Interactive get variable
interactive_get() {
    clear
    echo.header "üìñ Get Environment Variable Value"
    echo
    
    # Use existing fzf integration if available
    if command -v fzf >/dev/null 2>&1; then
        echo.info "Use fuzzy search to select a variable:"
        echo
        get_env_var ""
    else
        echo.warning "fzf not available - showing all variables for manual selection"
        echo
        
        local vars
        vars=($(jq -r 'keys[]' "$ENV_FILE" 2>/dev/null))
        
        if [[ ${#vars[@]} -eq 0 ]]; then
            echo.warning "No environment variables stored"
            wait_for_input
            return 1
        fi
        
        echo.cyan "Available variables:"
        for i in "${!vars[@]}"; do
            echo "  $((i+1))) ${vars[i]}"
        done
        echo
        
        echo -n "$(echo.purple 'Enter variable name'): "
        read -r key
        
        if [[ -n "$key" ]]; then
            get_env_var "$key"
        else
            echo.warning "No variable specified"
        fi
    fi
    
    wait_for_input
}

# Interactive remove variable
interactive_remove() {
    clear
    echo.header "üóëÔ∏è Remove Environment Variable"
    echo
    
    # Use existing fzf integration if available
    if command -v fzf >/dev/null 2>&1; then
        echo.info "Use fuzzy search to select a variable to remove:"
        echo.warning "‚ö†  This action cannot be undone!"
        echo
        remove_env_var ""
    else
        echo.warning "fzf not available - showing all variables for manual selection"
        echo
        
        local vars
        vars=($(jq -r 'keys[]' "$ENV_FILE" 2>/dev/null))
        
        if [[ ${#vars[@]} -eq 0 ]]; then
            echo.warning "No environment variables stored"
            wait_for_input
            return 1
        fi
        
        echo.cyan "Variables available for removal:"
        for i in "${!vars[@]}"; do
            echo "  $((i+1))) ${vars[i]}"
        done
        echo
        echo.warning "‚ö†  This action cannot be undone!"
        
        echo -n "$(echo.purple 'Enter variable name to remove'): "
        read -r key
        
        if [[ -n "$key" ]]; then
            remove_env_var "$key"
        else
            echo.warning "No variable specified"
        fi
    fi
    
    wait_for_input
}

# Interactive generate random
interactive_generate_random() {
    clear
    echo.header "üé≤ Generate Random Secret"
    echo
    
    local key length
    
    # Get key
    echo -n "$(echo.cyan 'Variable name'): "
    read -r key
    
    if [[ -z "$key" ]]; then
        echo.error "Variable name cannot be empty"
        wait_for_input
        return 1
    fi
    
    # Get length
    echo -n "$(echo.cyan 'Secret length (default: 32)'): "
    read -r length
    length=${length:-32}
    
    if ! [[ "$length" =~ ^[0-9]+$ ]] || [[ $length -lt 1 ]]; then
        echo.error "Length must be a positive number"
        wait_for_input
        return 1
    fi
    
    # Generate and confirm
    local value
    value=$(generate_random "$length")
    
    echo
    echo.header "Generated Secret Preview"
    echo "  Name: $key"
    echo "  Length: $length characters"
    echo "  Value: ${value:0:20}...${value: -10}"  # Show first 20 and last 10 chars
    echo
    
    echo -n "$(echo.purple 'Save this secret? (y/n)'): "
    read -r confirm
    
    case "$confirm" in
        y|Y|yes|YES)
            if set_env_var "$key" "$value" "Generated random secret ($length chars)"; then
                echo.success "‚úÖ Random secret '$key' generated and saved!"
            else
                echo.error "‚ùå Failed to save secret"
            fi
            ;;
        *)
            echo.info "Cancelled - secret not saved"
            ;;
    esac
    
    wait_for_input
}

# Interactive generate OAuth
interactive_generate_oauth() {
    clear
    echo.header "üîë Generate OAuth Key Pair"
    echo
    
    local name type bits description
    
    # Get name
    echo -n "$(echo.cyan 'Key pair name (e.g., GITHUB_OAUTH)'): "
    read -r name
    
    if [[ -z "$name" ]]; then
        echo.error "Key pair name cannot be empty"
        wait_for_input
        return 1
    fi
    
    # Get type
    echo -n "$(echo.cyan 'Key type (rsa/default: rsa)'): "
    read -r type
    type=${type:-rsa}
    
    # Get bits
    echo -n "$(echo.cyan 'Key size in bits (default: 4096)'): "
    read -r bits
    bits=${bits:-4096}
    
    if ! [[ "$bits" =~ ^[0-9]+$ ]] || [[ $bits -lt 1024 ]]; then
        echo.error "Key size must be at least 1024 bits"
        wait_for_input
        return 1
    fi
    
    # Get description
    echo -n "$(echo.cyan 'Description (optional)'): "
    read -r description
    description=${description:-"OAuth Key Pair"}
    
    # Confirm
    echo
    echo.header "OAuth Key Pair Configuration"
    echo "  Name: $name (will create ${name}_PRIVATE_KEY and ${name}_PUBLIC_KEY)"
    echo "  Type: $type"
    echo "  Size: $bits bits"
    echo "  Description: $description"
    echo
    
    echo -n "$(echo.purple 'Generate OAuth key pair? (y/n)'): "
    read -r confirm
    
    case "$confirm" in
        y|Y|yes|YES)
            echo.info "Generating OAuth key pair (this may take a moment)..."
            if generate_oauth "$name" "$type" "$bits" "$description"; then
                echo.success "‚úÖ OAuth key pair generated successfully!"
            else
                echo.error "‚ùå Failed to generate OAuth key pair"
            fi
            ;;
        *)
            echo.info "Cancelled - no keys generated"
            ;;
    esac
    
    wait_for_input
}

# Interactive data management
interactive_data_management() {
    while true; do
        show_data_management_menu
        echo -n "$(echo.cyan 'Choose an option'): "
        read -r choice
        
        case "$choice" in
            1)
                clear
                echo.header "üì§ Export Variables"
                echo
                echo -n "$(echo.cyan 'Export file path (.json or .env)'): "
                read -r export_file
                
                if [[ -n "$export_file" ]]; then
                    if export_env_vars "$export_file"; then
                        echo.success "‚úÖ Variables exported successfully!"
                    else
                        echo.error "‚ùå Export failed"
                    fi
                    wait_for_input
                fi
                ;;
            2)
                clear
                echo.header "üì• Import Variables"
                echo
                echo -n "$(echo.cyan 'Import file path'): "
                read -r import_file
                
                if [[ -n "$import_file" ]]; then
                    echo.warning "‚ö†  This will merge with existing variables (may overwrite)"
                    echo -n "$(echo.purple 'Continue? (y/n)'): "
                    read -r confirm
                    
                    case "$confirm" in
                        y|Y|yes|YES)
                            if import_env_vars "$import_file"; then
                                echo.success "‚úÖ Variables imported successfully!"
                            else
                                echo.error "‚ùå Import failed"
                            fi
                            ;;
                        *)
                            echo.info "Import cancelled"
                            ;;
                    esac
                    wait_for_input
                fi
                ;;
            3)
                clear
                echo.header "üíæ Create Backup"
                echo
                if backup_env_vars; then
                    echo.success "‚úÖ Backup created successfully!"
                else
                    echo.error "‚ùå Backup failed"
                fi
                wait_for_input
                ;;
            4)
                clear
                echo.header "üîÑ Restore from Backup"
                echo
                
                # Show available backups
                if [[ -d "$ENV_BACKUP_DIR" ]]; then
                    local backups=("$ENV_BACKUP_DIR"/env_backup_*.json)
                    if [[ -f "${backups[0]}" ]]; then
                        echo.cyan "Available backups:"
                        for backup in "${backups[@]}"; do
                            local filename=$(basename "$backup")
                            local date_part=${filename#env_backup_}
                            local date_formatted=${date_part%.json}
                            echo "  üìÑ $filename (${date_formatted})"
                        done
                        echo
                    fi
                fi
                
                echo -n "$(echo.cyan 'Backup file path'): "
                read -r backup_file
                
                if [[ -n "$backup_file" ]]; then
                    echo.warning "‚ö†  This will replace ALL current variables!"
                    echo -n "$(echo.purple 'Are you sure? (y/n)'): "
                    read -r confirm
                    
                    case "$confirm" in
                        y|Y|yes|YES)
                            if restore_env_vars "$backup_file"; then
                                echo.success "‚úÖ Variables restored successfully!"
                            else
                                echo.error "‚ùå Restore failed"
                            fi
                            ;;
                        *)
                            echo.info "Restore cancelled"
                            ;;
                    esac
                    wait_for_input
                fi
                ;;
            5)
                clear
                echo.header "üìä Storage Information"
                echo
                
                local count size backup_count
                count=$(jq 'length' "$ENV_FILE" 2>/dev/null || echo "0")
                size=$(du -h "$ENV_FILE" 2>/dev/null | cut -f1 || echo "0B")
                
                echo.cyan "Environment Variables:"
                echo "  üìù Variables stored: $count"
                echo "  üíæ Storage file size: $size"
                echo "  üìç Storage location: $ENV_FILE"
                echo
                
                if [[ -d "$ENV_BACKUP_DIR" ]]; then
                    backup_count=$(find "$ENV_BACKUP_DIR" -name "env_backup_*.json" 2>/dev/null | wc -l)
                    echo.cyan "Backups:"
                    echo "  üì¶ Backup count: $backup_count"
                    echo "  üìÇ Backup location: $ENV_BACKUP_DIR"
                    
                    if [[ $backup_count -gt 0 ]]; then
                        local latest_backup
                        latest_backup=$(find "$ENV_BACKUP_DIR" -name "env_backup_*.json" -printf '%T@ %p\n' 2>/dev/null | sort -n | tail -1 | cut -d' ' -f2-)
                        if [[ -n "$latest_backup" ]]; then
                            local backup_date
                            backup_date=$(stat -c %y "$latest_backup" 2>/dev/null | cut -d' ' -f1)
                            echo "  üïê Latest backup: $backup_date"
                        fi
                    fi
                else
                    echo.cyan "Backups:"
                    echo "  üì¶ No backups created yet"
                fi
                
                wait_for_input
                ;;
            b|B|back|BACK)
                break
                ;;
            q|Q|quit|QUIT|exit|EXIT)
                echo.info "üëã Goodbye!"
                exit 0
                ;;
            *)
                echo.error "Invalid option: $choice"
                sleep 1
                ;;
        esac
    done
}

# Main interactive mode
interactive_mode() {
    while true; do
        show_interactive_menu
        echo -n "$(echo.cyan 'Choose an option'): "
        read -r choice
        
        case "$choice" in
            1) interactive_list ;;
            2) interactive_search ;;
            3) interactive_add ;;
            4) interactive_get ;;
            5) interactive_add ;;  # Edit is same as add with overwrite
            6) interactive_remove ;;
            7) interactive_generate_random ;;
            8) interactive_generate_oauth ;;
            9) interactive_data_management ;;
            0) show_help; wait_for_input ;;
            q|Q|quit|QUIT|exit|EXIT)
                echo.info "üëã Goodbye!"
                exit 0
                ;;
            *)
                echo.error "Invalid option: $choice"
                sleep 1
                ;;
        esac
    done
}

# Main function
main() {
    local command="${1:-help}"
    
    # Check for interactive mode triggers first
    case "$command" in
        i|interactive|--i|--interactive)
            interactive_mode
            return $?
            ;;
    esac
    
    case "$command" in
        set)
            if [[ $# -lt 3 ]]; then
                echo.error "Usage: dotfiles-env set <key> <value> [description]"
                return 1
            fi
            set_env_var "$2" "$3" "${4:-}"
            ;;
        get)
            get_env_var "${2:-}"
            ;;
        remove|rm)
            remove_env_var "${2:-}"
            ;;
        list|ls)
            list_env_vars
            ;;
        search)
            if [[ $# -lt 2 ]]; then
                echo.error "Usage: dotfiles-env search <query>"
                return 1
            fi
            search_env_vars "$2"
            ;;
        generate)
            if [[ $# -lt 2 ]]; then
                echo.error "Usage: dotfiles-env generate <key> [length]"
                return 1
            fi
            local value
            value=$(generate_random "${3:-32}")
            set_env_var "$2" "$value" "Generated random value"
            ;;
        generate-oauth)
            if [[ $# -lt 2 ]]; then
                echo.error "Usage: dotfiles-env generate-oauth <name> [type] [bits] [description]"
                return 1
            fi
            generate_oauth "$2" "${3:-rsa}" "${4:-4096}" "${5:-OAuth Key Pair}"
            ;;
        export)
            if [[ $# -lt 2 ]]; then
                echo.error "Usage: dotfiles-env export <file>"
                return 1
            fi
            export_env_vars "$2"
            ;;
        import)
            if [[ $# -lt 2 ]]; then
                echo.error "Usage: dotfiles-env import <file>"
                return 1
            fi
            import_env_vars "$2"
            ;;
        backup)
            backup_env_vars
            ;;
        restore)
            if [[ $# -lt 2 ]]; then
                echo.error "Usage: dotfiles-env restore <backup_file>"
                return 1
            fi
            restore_env_vars "$2"
            ;;
        help|--help|-h)
            show_help
            ;;
        *)
            echo.error "Unknown command: $command"
            show_help
            return 1
            ;;
    esac
}

# Check dependencies
check_dependencies() {
    local missing_deps=()
    
    if ! command -v jq >/dev/null 2>&1; then
        missing_deps+=(jq)
    fi
    
    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        echo.error "Missing required dependencies: ${missing_deps[*]}"
        echo.info "Install with: sudo apt install ${missing_deps[*]}"
        return 1
    fi
}

# Initialize and run
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    check_dependencies || exit 1
    main "$@"
fi
