#!/usr/bin/env bash

source "${HOME}/.config/dotfiles/core/_env"
source "${HOME}/.config/dotfiles/core/_colors"
source "${HOME}/.config/dotfiles/core/_safety"

# Environment variables & secrets manager configuration
export DOTFILES_ENV_DB="${DOTFILES_UTILS}/env.json"
export DOTFILES_ENV_KEY="${DOTFILES_UTILS}/.env.key"
export DOTFILES_ENV_SALT="${DOTFILES_UTILS}/.env.salt"

# Initialize env database if it doesn't exist
[[ ! -f "$DOTFILES_ENV_DB" ]] && echo '{}' > "$DOTFILES_ENV_DB"

# Generate encryption key and salt if they don't exist
function env_init() {
    if [[ ! -f "$DOTFILES_ENV_KEY" ]]; then
        echo.info "Generating encryption key..."
        openssl rand -hex 32 > "$DOTFILES_ENV_KEY"
        chmod 600 "$DOTFILES_ENV_KEY"
        echo.success "Encryption key generated"
    fi
    
    if [[ ! -f "$DOTFILES_ENV_SALT" ]]; then
        echo.info "Generating salt..."
        openssl rand -hex 16 > "$DOTFILES_ENV_SALT"
        chmod 600 "$DOTFILES_ENV_SALT"
        echo.success "Salt generated"
    fi
}

# Encrypt a value
function env_encrypt() {
    local value="$1"
    local key=$(cat "$DOTFILES_ENV_KEY")
    
    echo "$value" | openssl enc -aes-256-cbc -a -salt -pbkdf2 -iter 10000 -pass "pass:$key" 2>/dev/null
}

# Decrypt a value
function env_decrypt() {
    local encrypted_value="$1"
    local key=$(cat "$DOTFILES_ENV_KEY")
    echo "$encrypted_value" | openssl enc -aes-256-cbc -a -d -salt -pbkdf2 -iter 10000 -pass "pass:$key" 2>/dev/null
}

# List all environment variables & secrets
function env_list() {
    echo.header "Environment Variables & Secrets"
    
    if [[ ! -f "$DOTFILES_ENV_DB" ]] || [[ $(stat -c%s "$DOTFILES_ENV_DB") -le 2 ]]; then
        echo.warning "No environment variables stored"
        return 0
    fi
    
    jq -r 'to_entries | .[] | "\(.key) (\(.value.type)) - \(.value.description // "No description")"' "$DOTFILES_ENV_DB" 2>/dev/null | \
    while IFS=' ' read -r key type description; do
        echo.cyan "$key" | tr '\n' ' '
        echo "($type) - $description"
    done
}

# Resolve a clipboard command
function _env_clip_cmd() {
    if command -v wl-copy &>/dev/null; then
        echo "wl-copy"
        return 0
    fi
    if command -v xclip &>/dev/null; then
        echo "xclip -selection clipboard"
        return 0
    fi
    if command -v xsel &>/dev/null; then
        echo "xsel --clipboard --input"
        return 0
    fi
    if command -v pbcopy &>/dev/null; then
        echo "pbcopy"
        return 0
    fi
    return 1
}

# Copy provided text to the system clipboard
function _env_copy_to_clipboard() {
    local text="$1"
    local cmd=$(_env_clip_cmd)
    if [[ -n "$cmd" ]]; then
        # shellcheck disable=SC2086
        printf "%s" "$text" | eval $cmd
        return $?
    fi
    return 1
}

# Interactive picker for environment variable using fzf
function _env_pick_key() {
    if ! command -v fzf &>/dev/null; then
        return 1
    fi
    if [[ ! -s "$DOTFILES_ENV_DB" ]]; then
        return 1
    fi
    local choice
    choice=$(jq -r 'to_entries | .[] | "\(.key)\t\(.value.type)\t\(.value.description // "")"' "$DOTFILES_ENV_DB" 2>/dev/null | \
        fzf --prompt="Select environment variable > " --with-nth=1,2,3 --ansi --delimiter='\t' --height=40% --layout=reverse --border)
    if [[ -n "$choice" ]]; then
        echo "$choice" | awk -F '\t' '{print $1}'
        return 0
    fi
    return 1
}

# Get an environment variable/secret value
function env_get() {
    local copy_only=0
    local key=""
    local use_prefix=0
    local prefix_override=""
    local interactive_was_used=0

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -c|--copy) 
                copy_only=1
                shift
                ;; 
            -p|p|--pre) 
                use_prefix=1
                shift
                ;; 
            --prefix) 
                use_prefix=1
                shift
                if [[ -n "${1:-}" && ! "${1:-}" =~ ^- ]]; then
                    prefix_override="$1"; shift
                fi
                ;; 
            --prefix=*) 
                use_prefix=1
                prefix_override="${1#--prefix=}"
                shift
                ;; 
            *)
                if [[ -z "$key" ]]; then
                    key="$1"
                fi
                shift
                ;; 
        esac
    done

    if [[ -z "$key" ]]; then
        key=$(_env_pick_key)
        if [[ -z "$key" ]]; then
            echo.error "Provide a key or install fzf for interactive selection"
            return 1
        fi
        interactive_was_used=1
    fi
    
    local encrypted_value=$(jq -r --arg key "$key" '.[$key].value // empty' "$DOTFILES_ENV_DB" 2>/dev/null)
    local type=$(jq -r --arg key "$key" '.[$key].type // empty' "$DOTFILES_ENV_DB" 2>/dev/null)
    local stored_prefix=$(jq -r --arg key "$key" '.[$key].prefix // empty' "$DOTFILES_ENV_DB" 2>/dev/null)
    
    if [[ -n "$encrypted_value" ]]; then
        local decrypted_value=$(env_decrypt "$encrypted_value")
        if [[ -n "$decrypted_value" ]]; then
            local to_copy="$decrypted_value"

            # Interactive prompt for prefix if interactive mode and prefix desired
            if [[ $interactive_was_used -eq 1 && $use_prefix -eq 0 ]]; then
                read -r -p "Use prefix for '$key'? [y/N] " yn
                case "$yn" in
                    [Yy]*) use_prefix=1 ;; 
                    *)
                        use_prefix=0 ;; 
                esac
                if [[ $use_prefix -eq 1 && -z "$prefix_override" && -z "$stored_prefix" ]]; then
                    read -r -p "Enter prefix name: " prefix_override
                fi
            fi

            if [[ $use_prefix -eq 1 ]]; then
                local final_prefix="$prefix_override"
                if [[ -z "$final_prefix" ]]; then
                    final_prefix="$stored_prefix"
                fi
                if [[ -z "$final_prefix" ]]; then
                    echo.warning "No prefix provided or stored for '$key'; copying plain value"
                else
                    to_copy="${final_prefix}=${decrypted_value}"
                fi
            fi

            if _env_copy_to_clipboard "$to_copy"; then
                if [[ $use_prefix -eq 1 && -n "${prefix_override}${stored_prefix}" ]]; then
                    echo.success "Copied '${key}' as ${to_copy%%=*}=****** to clipboard ($type)"
                else
                    echo.success "Copied '$key' to clipboard ($type)"
                fi
            else
                echo.warning "Clipboard tool not found; printing value"
                echo "$to_copy"
            fi
            if [[ $copy_only -eq 0 ]]; then
                echo.info "Environment variable: $key ($type)"
                echo "$to_copy"
            fi
        else
            echo.error "Failed to decrypt value: $key"
            return 1
        fi
    else
        echo.error "Environment variable not found: $key"
        return 1
    fi
}

# Set an environment variable/secret value
function env_set() {
    local key=""
    local value=""
    local type="generic"
    local prefix=""
    local description=""

    # Parse args: dotfiles env set <key> <value> [type] [--prefix|-p <name>] [--desc <description>]
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --prefix|--pre|-p) 
                shift
                prefix="${1:-}"
                if [[ -z "$prefix" ]]; then
                    echo.error "Missing value for --prefix"
                    return 1
                fi
                shift
                ;; 
            --desc|--description) 
                shift
                description="${1:-}"
                shift
                ;; 
            *)
                if [[ -z "$key" ]]; then
                    key="$1"; shift; continue
                fi
                if [[ -z "$value" ]]; then
                    value="$1"; shift; continue
                fi
                if [[ "$type" == "generic" ]]; then
                    type="$1"; shift; continue
                fi
                shift
                ;; 
        esac
    done

    if [[ -z "$key" || -z "$value" ]]; then
        echo.error "Usage: dotfiles env set <key> <value> [type] [--prefix <name>] [--desc <description>]"
        return 1
    fi
    
    if [[ "$key" =~ [^a-zA-Z0-9_-] ]]; then
        echo.error "Invalid variable name: $key (use only alphanumeric, underscore, and hyphen)"
        return 1
    fi
    
    # Initialize encryption if needed
    env_init
    
    local encrypted_value=$(env_encrypt "$value")
    if [[ -z "$encrypted_value" ]]; then
        echo.error "Failed to encrypt value"
        return 1
    fi
    
    local now=$(date -Iseconds)
    jq --arg key "$key" \
       --arg value "$encrypted_value" \
       --arg type "$type" \
       --arg prefix "$prefix" \
       --arg description "$description" \
       --arg now "$now" \
       '.[$key] = {"value": $value, "type": $type, "prefix": $prefix, "description": $description, "created": $now}' \
       "$DOTFILES_ENV_DB" > "${DOTFILES_ENV_DB}.tmp" && \
    mv "${DOTFILES_ENV_DB}.tmp" "$DOTFILES_ENV_DB"
    
    echo.success "Environment variable '$key' stored as $type"
}

# Remove an environment variable/secret
function env_remove() {
    local key="$1"
    
    if [[ -z "$key" ]]; then
        echo.error "Usage: dotfiles env remove <key>"
        return 1
    fi
    
    jq --arg key "$key" 'del(.[$key])' "$DOTFILES_ENV_DB" > "${DOTFILES_ENV_DB}.tmp" && \
    mv "${DOTFILES_ENV_DB}.tmp" "$DOTFILES_ENV_DB"
    
    echo.success "Environment variable '$key' removed"
}

# Export environment variables to shell
function env_export() {
    echo.info "Exporting environment variables to shell..."
    
    local count=0
    local temp_file=$(mktemp)
    jq -r 'to_entries | .[] | "\(.key):\(.value.value)"' "$DOTFILES_ENV_DB" 2>/dev/null > "$temp_file"
    
    while IFS=':' read -r key encrypted_value; do
        if [[ -n "$key" && -n "$encrypted_value" ]]; then
            local decrypted_value=$(env_decrypt "$encrypted_value")
            if [[ -n "$decrypted_value" ]]; then
                printf 'export %s="%s";\n' "$key" "$decrypted_value"
                ((count++))
            fi
        fi
    done < "$temp_file"
    
    rm -f "$temp_file"
    echo.success "Exported $count environment variables"
}

# Import environment variables from a file
function env_import() {
    local file="${1:-$HOME/.env}"
    
    if [[ ! -f "$file" ]]; then
        echo.error "File not found: $file"
        return 1
    fi
    
    echo.info "Importing environment variables from: $file"
    
    local count=0
    while IFS='=' read -r key value; do
        [[ -z "$key" || "$key" =~ ^[[:space:]]*# ]] && continue
        
        key="${key#export }"
        key="${key// /}"
        value="${value//\"/}"
        
        if [[ -n "$key" && -n "$value" ]]; then
            env_set "$key" "$value" "imported"
            ((count++))
        fi
    done < "$file"
    
    echo.success "Imported $count environment variables"
}

# Generate a random environment variable/secret
function env_generate() {
    local key="$1"
    local length="${2:-32}"
    local type="${3:-random}"
    
    if [[ -z "$key" ]]; then
        echo.error "Usage: dotfiles env generate <key> [length] [type]"
        return 1
    fi
    
    local random_value=$(openssl rand -base64 "$length" | tr -d "=+/" | cut -c1-"$length")
    env_set "$key" "$random_value" "$type"
    
    echo.success "Generated random value '$key' with length $length"
}

# Generate OAuth key pair (tokens functionality)
function env_generate_oauth() {
    local name="$1"
    local key_type="${2:-rsa}"
    local bits="${3:-2048}"
    local description="${4:-}"
    
    if [[ -z "$name" ]]; then
        echo.error "Usage: dotfiles env generate-oauth <name> [type] [bits] [description]"
        echo.info "Key types: rsa, ec (elliptic curve), ed25519"
        return 1
    fi
    
    if [[ "$name" =~ [^a-zA-Z0-9_-] ]]; then
        echo.error "Invalid name: $name (use only alphanumeric, underscore, and hyphen)"
        return 1
    fi
    
    local temp_dir=$(mktemp -d)
    local private_key_file="$temp_dir/private.key"
    local public_key_file="$temp_dir/public.key"
    
    case "$key_type" in
        rsa)
            openssl genrsa -out "$private_key_file" "$bits" 2>/dev/null || {
                echo.error "Failed to generate RSA key pair"
                rm -rf "$temp_dir"
                return 1
            }
            openssl rsa -in "$private_key_file" -pubout -out "$public_key_file" 2>/dev/null
            ;;
        ec)
            openssl ecparam -genkey -name secp256r1 -out "$private_key_file" 2>/dev/null || {
                echo.error "Failed to generate EC key pair"
                rm -rf "$temp_dir"
                return 1
            }
            openssl ec -in "$private_key_file" -pubout -out "$public_key_file" 2>/dev/null
            ;;
        ed25519)
            openssl genpkey -algorithm Ed25519 -out "$private_key_file" 2>/dev/null || {
                echo.error "Failed to generate Ed25519 key pair"
                rm -rf "$temp_dir"
                return 1
            }
            openssl pkey -in "$private_key_file" -pubout -out "$public_key_file" 2>/dev/null
            ;;
        *)
            echo.error "Unsupported key type: $key_type"
            echo.info "Supported types: rsa, ec, ed25519"
            rm -rf "$temp_dir"
            return 1
            ;;
    esac
    
    local private_key=$(cat "$private_key_file")
    local public_key=$(cat "$public_key_file")
    
    # Store private key encrypted
    env_init
    local encrypted_private_key=$(env_encrypt "$private_key")
    if [[ -z "$encrypted_private_key" ]]; then
        echo.error "Failed to encrypt private key"
        rm -rf "$temp_dir"
        return 1
    fi
    
    # Store both keys in the database
    local now=$(date -Iseconds)
    jq --arg name "$name" \
       --arg type "oauth" \
       --arg key_type "$key_type" \
       --arg public_key "$public_key" \
       --arg private_key "$encrypted_private_key" \
       --arg description "$description" \
       --arg created "$now" \
       '.[$name] = {"type": $type, "key_type": $key_type, "public_key": $public_key, "private_key": $private_key, "description": $description, "created": $created}' \
       "$DOTFILES_ENV_DB" > "${DOTFILES_ENV_DB}.tmp" && \
    mv "${DOTFILES_ENV_DB}.tmp" "$DOTFILES_ENV_DB"
    
    rm -rf "$temp_dir"
    echo.success "Generated $key_type OAuth key pair '$name' ($bits bits)"
}

# Search environment variables
function env_search() {
    local query="$1"
    
    if [[ -z "$query" ]]; then
        echo.error "Usage: dotfiles env search <query>"
        return 1
    fi
    
    echo.info "Searching for environment variables matching: $query"
    
    jq -r --arg query "$query" 'to_entries | .[] | select(.key | contains($query) or .value.type | contains($query) or .value.description | contains($query)) | "\(.key) (\(.value.type)) - \(.value.description // "No description")"' "$DOTFILES_ENV_DB" 2>/dev/null | \
    while IFS=' ' read -r key type description; do
        if [[ -n "$key" ]]; then
            echo.cyan "$key" | tr '\n' ' '
            echo "($type) - $description"
        fi
    done
}

# Backup environment variables database
function env_backup() {
    local backup_dir="${DOTFILES_UTILS}/backups"
    local timestamp=$(date +%Y%m%d_%H%M%S)
    local backup_file="${backup_dir}/env_${timestamp}.json"
    
    [[ ! -d "$backup_dir" ]] && mkdir -p "$backup_dir"
    
    cp "$DOTFILES_ENV_DB" "$backup_file"
    echo.success "Environment variables backed up to: $backup_file"
}

# Restore environment variables database
function env_restore() {
    local backup_file="$1"
    
    if [[ -z "$backup_file" ]]; then
        echo.error "Usage: dotfiles env restore <backup_file>"
        return 1
    fi
    
    if [[ ! -f "$backup_file" ]]; then
        echo.error "Backup file not found: $backup_file"
        return 1
    fi
    
    cp "$backup_file" "$DOTFILES_ENV_DB"
    echo.success "Environment variables restored from: $backup_file"
}

# Show environment variables info
function env_info() {
    local key="$1"
    
    if [[ -z "$key" ]]; then
        echo.header "Environment Variables Database Info"
        echo.info "Database: $DOTFILES_ENV_DB"
        echo.info "Encryption: AES-256-CBC with PBKDF2"
        echo.info "Total variables: $(jq 'length' "$DOTFILES_ENV_DB" 2>/dev/null || echo '0')"
        echo.info "Last modified: $(stat -c %y "$DOTFILES_ENV_DB" 2>/dev/null || echo 'Unknown')"
    else
        local env_info=$(jq --arg key "$key" '.[$key]' "$DOTFILES_ENV_DB" 2>/dev/null)
        if [[ "$env_info" != "null" ]]; then
            echo.header "Environment Variable: $key"
            local type=$(echo "$env_info" | jq -r '.type')
            local description=$(echo "$env_info" | jq -r '.description // "No description"')
            local created=$(echo "$env_info" | jq -r '.created')
            
            echo.info "Type: $type"
            echo.info "Description: $description"
            echo.info "Created: $created"
            
            # Show public key if it's an OAuth token
            if [[ "$type" == "oauth" ]]; then
                local public_key=$(echo "$env_info" | jq -r '.public_key // empty')
                if [[ -n "$public_key" ]]; then
                    echo
                    echo.info "Public Key:"
                    echo "$public_key"
                fi
            fi
        else
            echo.error "Environment variable not found: $key"
            return 1
        fi
    fi
}

# Main function
function main() {
    local command="$1"
    shift
    
    case "$command" in
        "list"|"ls")
            env_list
            ;; 
        "get")
            env_get "$@"
            ;; 
        "set")
            env_set "$@"
            ;; 
        "remove"|"rm")
            env_remove "$@"
            ;; 
        "export")
            env_export
            ;; 
        "import")
            env_import "$@"
            ;; 
        "generate"|"gen")
            env_generate "$@"
            ;; 
        "generate-oauth"|"gen-oauth")
            env_generate_oauth "$@"
            ;; 
        "search")
            env_search "$@"
            ;; 
        "backup")
            env_backup
            ;; 
        "restore")
            env_restore "$@"
            ;; 
        "info")
            env_info "$@"
            ;; 
        "init")
            env_init
            ;; 
        "help"|"--help"|"-h"|"")
            echo.header "Dotfiles Environment Variables & Secrets Manager"
            echo
            echo.info "Usage: dotfiles env <command> [options]"
            echo
            echo.info "Commands:"
            echo.cyan "  list, ls" | tr '\n' ' '
            echo "     - List all stored environment variables"
            echo.cyan "  get [--copy|-c] [--prefix|-p[=NAME]] [key]" | tr '\n' ' '
            echo "     - Get a variable value; interactive if key omitted; copies to clipboard"
            echo.cyan "  set <key> <value> [type] [--prefix <name>] [--desc <description>]" | tr '\n' ' '
            echo "     - Store a variable with optional type, prefix and description"
            echo.cyan "  remove, rm <key>" | tr '\n' ' '
            echo "     - Remove a variable"
            echo.cyan "  export" | tr '\n' ' '
            echo "     - Export variables to environment"
            echo.cyan "  import [file]" | tr '\n' ' '
            echo "     - Import variables from file"
            echo.cyan "  generate, gen <key> [length] [type]" | tr '\n' ' '
            echo "     - Generate a random value"
            echo.cyan "  generate-oauth, gen-oauth <name> [type] [bits] [desc]" | tr '\n' ' '
            echo "     - Generate OAuth key pair (rsa, ec, ed25519)"
            echo.cyan "  search <query>" | tr '\n' ' '
            echo "     - Search variables by name, type or description"
            echo.cyan "  backup" | tr '\n' ' '
            echo "     - Backup variables database"
            echo.cyan "  restore <file>" | tr '\n' ' '
            echo "     - Restore variables from backup"
            echo.cyan "  info [key]" | tr '\n' ' '
            echo "     - Show database info or variable details"
            echo.cyan "  init" | tr '\n' ' '
            echo "     - Initialize encryption keys"
            echo.cyan "  help" | tr '\n' ' '
            echo "     - Show this help message"
            echo
            echo.info "Examples:"
            echo "  dotfiles env set GITHUB_TOKEN abc123 api --desc 'GitHub API token'"
            echo "  dotfiles env get GITHUB_TOKEN"
            echo "  dotfiles env get                    # Interactive selection"
            echo "  dotfiles env get --copy             # Interactive selection, copy only"
            echo "  dotfiles env set API_KEY abc api --prefix MYAPI"
            echo "  dotfiles env get -p API_KEY         # Copies as MYAPI=<value> if prefix stored"
            echo "  dotfiles env get --prefix=FOO API_KEY  # Copies as FOO=<value>"
            echo "  dotfiles env generate-oauth GITHUB_OAUTH rsa 4096 'GitHub OAuth App'"
            ;; 
        *)
            echo.error "Unknown command: $command"
            echo.info "Run 'dotfiles env help' for usage information"
            return 1
            ;; 
    esac
}

# Run main function with all arguments
main "$@"
