#!/usr/bin/env bash

source "${HOME}/.config/dotfiles/core/_env"
source "${HOME}/.config/dotfiles/core/_colors"
source "${HOME}/.config/dotfiles/core/_safety"

# Configuration
ENV_SYNC_DIR="${HOME}/.env-vault"
ENCRYPTED_BACKUP="${ENV_SYNC_DIR}/env.vault"
SYNC_URL_FILE="${ENV_SYNC_DIR}/sync_url"

# Initialize environment vault
function env_sync_init() {
    echo.info "Initializing environment sync system..."
    
    mkdir -p "$ENV_SYNC_DIR"
    chmod 700 "$ENV_SYNC_DIR"
    
    if [[ ! -f "$SYNC_URL_FILE" ]]; then
        echo.info "Choose sync method:"
        echo "1) Private GitHub gist (recommended)"
        echo "2) Custom URL (your own server)"
        echo "3) Dropbox/Google Drive path"
        
        read -r -p "Select option (1-3): " choice
        
        case "$choice" in
            1)
                setup_github_gist
                ;;
            2)
                read -r -p "Enter your sync URL: " url
                echo "$url" > "$SYNC_URL_FILE"
                ;;
            3)
                read -r -p "Enter cloud storage path: " path
                echo "file://$path" > "$SYNC_URL_FILE"
                ;;
            *)
                echo.error "Invalid choice"
                return 1
                ;;
        esac
    fi
    
    echo.success "Environment sync initialized"
}

# Setup GitHub gist for sync
function setup_github_gist() {
    echo.info "Setting up private GitHub gist..."
    
    # Check if gh CLI is available
    if ! command -v gh &>/dev/null; then
        echo.error "GitHub CLI (gh) not found. Install with: sudo apt install gh"
        return 1
    fi
    
    # Check if authenticated
    if ! gh auth status &>/dev/null; then
        echo.error "GitHub CLI not authenticated. Run: gh auth login"
        return 1
    fi
    
    # Search for existing env gist first
    echo.info "Checking for existing environment gist..."
    local existing_gist=$(gh gist list --limit 100 | grep -E "(Encrypted dotfiles environment|env\.vault)" | head -1 | awk '{print $1}' || true)
    
    if [[ -n "$existing_gist" ]]; then
        echo.info "Found existing secrets gist: $existing_gist"
        read -r -p "Use existing gist? [Y/n] " use_existing
        if [[ ! "$use_existing" =~ ^[Nn]$ ]]; then
            local github_user=$(gh api user --jq .login)
            echo "https://gist.githubusercontent.com/${github_user}/${existing_gist}/raw/env.vault" > "$SYNC_URL_FILE"
            echo.success "Using existing gist: $existing_gist"
            return 0
        fi
    fi
    
    # Create new private gist
    echo.info "Creating new private gist..."
    local gist_content='{
  "description": "Encrypted dotfiles environment - DO NOT EDIT MANUALLY",
  "public": false,
  "files": {
    "env.vault": {
      "content": "# Encrypted dotfiles environment\n# This file is managed by dotfiles-env-sync\n# Last updated: '$(date)'\n\nplaceholder"
    },
    "README.md": {
      "content": "# Encrypted Dotfiles Environment\n\nThis gist contains encrypted environment variables for dotfiles sync.\n\n**Do not edit manually!**\n\nManaged by: dotfiles-env-sync\nLast updated: '$(date)'\n"
    }
  }
}'
    
    local gist_id=$(echo "$gist_content" | gh gist create --private --filename env.vault --desc "Encrypted dotfiles environment" | grep -o '[a-f0-9]\{32\}')
    
    if [[ -n "$gist_id" ]]; then
        local github_user=$(gh api user --jq .login)
        echo "https://gist.githubusercontent.com/${github_user}/${gist_id}/raw/env.vault" > "$SYNC_URL_FILE"
        echo.success "GitHub gist created: $gist_id"
        echo.info "Gist URL: https://gist.github.com/${github_user}/${gist_id}"
    else
        echo.error "Failed to create gist"
        return 1
    fi
}

# Calculate hash of environment database for conflict detection
function env_sync_calculate_hash() {
    if [[ -f "$DOTFILES_ENV_DB" ]]; then
        sha256sum "$DOTFILES_ENV_DB" | cut -d' ' -f1
    else
        echo ""
    fi
}

# Store sync metadata
function env_sync_store_metadata() {
    local hash="$1"
    local timestamp="$2"
    local metadata_file="${ENV_SYNC_DIR}/sync_metadata.json"
    
    jq -n --arg hash "$hash" --arg timestamp "$timestamp" \
        '{last_sync: $timestamp, local_hash: $hash}' > "$metadata_file"
}

# Get sync metadata
function env_sync_get_metadata() {
    local metadata_file="${ENV_SYNC_DIR}/sync_metadata.json"
    if [[ -f "$metadata_file" ]]; then
        cat "$metadata_file"
    else
        echo '{}'
    fi
}

# Encrypt and upload environment variables
function env_sync_push() {
    echo.info "Encrypting and syncing environment variables..."
    
    if [[ ! -f "$DOTFILES_ENV_DB" ]]; then
        echo.error "No environment database found"
        return 1
    fi
    
    if [[ ! -f "$SYNC_URL_FILE" ]]; then
        echo.error "Sync not initialized. Run: dotfiles env-sync init"
        return 1
    fi
    
    # Calculate current hash
    local current_hash=$(env_sync_calculate_hash)
    local timestamp=$(date -Iseconds)
    
    # Get master password
    read -r -s -p "Enter master password for encryption: " master_pass
    echo
    
    # Create encrypted backup
    echo.info "Creating encrypted backup..."
    tar -czf - -C "$DOTFILES_UTILS" env.json .env.key .env.salt 2>/dev/null | \
    openssl enc -aes-256-cbc -pbkdf2 -iter 100000 -pass "pass:$master_pass" -out "$ENCRYPTED_BACKUP"
    
    # Add metadata to the backup
    local metadata_temp=$(mktemp)
    echo "{\"hash\": \"$current_hash\", \"timestamp\": \"$timestamp\", \"hostname\": \"$(hostname)\"}" > "$metadata_temp"
    
    # Upload to sync location
    local sync_url=$(cat "$SYNC_URL_FILE")
    
    if [[ "$sync_url" == https://gist.githubusercontent.com/* ]]; then
        # Update GitHub gist
        local gist_id=$(echo "$sync_url" | sed 's|.*github.com/.*/\([^/]*\)/.*|\1|')
        echo.info "Updating gist $gist_id..."
        
        # Update both the vault file and metadata
        gh gist edit "$gist_id" --add env.vault < "$ENCRYPTED_BACKUP" --add sync_metadata.json < "$metadata_temp"
        
        # Update gist description with timestamp
        local description="Encrypted dotfiles environment - Last updated: $timestamp from $(hostname)"
        gh api "gists/$gist_id" -X PATCH -f description="$description" > /dev/null
        
        echo.success "Environment variables pushed to GitHub gist"
    elif [[ "$sync_url" == file://* ]]; then
        # Copy to file location
        local file_path="${sync_url#file://}"
        mkdir -p "$(dirname "$file_path")"
        cp "$ENCRYPTED_BACKUP" "$file_path/env.vault"
        cp "$metadata_temp" "$file_path/sync_metadata.json"
        echo.success "Environment variables pushed to $file_path"
    else
        # Upload via curl
        curl -s -X PUT --data-binary "@$ENCRYPTED_BACKUP" "$sync_url" > /dev/null
        echo.success "Environment variables pushed to $sync_url"
    fi
    
    # Store local metadata
    env_sync_store_metadata "$current_hash" "$timestamp"
    
    rm -f "$ENCRYPTED_BACKUP" "$metadata_temp"
}

# Download and decrypt environment variables
function env_sync_pull() {
    echo.info "Downloading and decrypting environment variables..."
    
    if [[ ! -f "$SYNC_URL_FILE" ]]; then
        echo.error "Sync not initialized. Run: dotfiles env-sync init"
        return 1
    fi
    
    local sync_url=$(cat "$SYNC_URL_FILE")
    
    # Download encrypted backup
    if [[ "$sync_url" == https://gist.githubusercontent.com/* ]]; then
        curl -s "$sync_url" -o "$ENCRYPTED_BACKUP"
    elif [[ "$sync_url" == file://* ]]; then
        local file_path="${sync_url#file://}"
        cp "$file_path/env.vault" "$ENCRYPTED_BACKUP"
    else
        curl -s "$sync_url" -o "$ENCRYPTED_BACKUP"
    fi
    
    if [[ ! -f "$ENCRYPTED_BACKUP" ]] || [[ ! -s "$ENCRYPTED_BACKUP" ]]; then
        echo.error "Failed to download environment variables or file is empty"
        return 1
    fi
    
    # Get master password
    read -r -s -p "Enter master password for decryption: " master_pass
    echo
    
    # Create backup of current environment variables
    if [[ -f "$DOTFILES_ENV_DB" ]]; then
        cp "$DOTFILES_ENV_DB" "${DOTFILES_ENV_DB}.backup.$(date +%s)"
        echo.info "Current environment variables backed up"
    fi
    
    # Decrypt and extract
    if openssl enc -aes-256-cbc -d -pbkdf2 -iter 100000 -pass "pass:$master_pass" -in "$ENCRYPTED_BACKUP" | \
       tar -xzf - -C "$DOTFILES_UTILS" 2>/dev/null; then
        echo.success "Environment variables successfully restored"
        echo.info "Run 'dotfiles env list' to verify"
    else
        echo.error "Failed to decrypt environment variables. Wrong password?"
        return 1
    fi
    
    rm -f "$ENCRYPTED_BACKUP"
}

# Enhanced status command
function env_sync_status() {
    echo.header "ðŸ”„ Environment Sync Status"
    
    # Sync configuration
    echo.info "Configuration:"
    if [[ -f "$SYNC_URL_FILE" ]]; then
        local sync_url=$(cat "$SYNC_URL_FILE")
        echo.success "  âœ“ Sync configured"
        echo.info "    URL: $sync_url"
        
        # Extract gist ID for GitHub gists
        if [[ "$sync_url" == https://gist.githubusercontent.com/* ]]; then
            local gist_id=$(echo "$sync_url" | sed 's|.*github.com/.*/\([^/]*\)/.*|\1|')
            echo.info "    Gist ID: $gist_id"
        fi
    else
        echo.warning "  âœ— Sync not configured"
        echo.info "    Run: dotfiles env-sync init"
    fi
    
    echo
    echo.info "Local Status:"
    if [[ -f "$DOTFILES_ENV_DB" ]]; then
        local env_count=$(jq 'length' "$DOTFILES_ENV_DB" 2>/dev/null || echo "0")
        local current_hash=$(env_sync_calculate_hash)
        echo.success "  âœ“ Environment database exists"
        echo.info "    Variables: $env_count"
        echo.info "    Current hash: ${current_hash:0:12}..."
        echo.info "    Last modified: $(stat -c %y "$DOTFILES_ENV_DB" 2>/dev/null || echo 'Unknown')"
    else
        echo.warning "  âœ— No environment database found"
    fi
    
    echo
    echo.info "Sync History:"
    local metadata=$(env_sync_get_metadata)
    local last_sync=$(echo "$metadata" | jq -r '.last_sync // "Never"')
    local stored_hash=$(echo "$metadata" | jq -r '.local_hash // "None"')
    
    if [[ "$last_sync" != "Never" ]]; then
        echo.success "  âœ“ Last sync: $last_sync"
        echo.info "    Synced hash: ${stored_hash:0:12}..."
        
        # Check if current state differs from last sync
        local current_hash=$(env_sync_calculate_hash)
        if [[ "$current_hash" != "$stored_hash" && -n "$current_hash" ]]; then
            echo.warning "  âš  Local changes detected since last sync"
        else
            echo.success "  âœ“ Local state matches last sync"
        fi
    else
        echo.info "  â€¢ No sync history"
    fi
    
    echo
    echo.info "Auto-sync: ${DOTFILES_AUTO_SYNC:-disabled}"
}

# Discover existing gists (delegated to bootstrap command)
function env_sync_discover() {
    echo.info "Discovering existing secrets gists..."
    if command -v "$DOTFILES_BIN/dotfiles-secrets-bootstrap" &>/dev/null; then
        "$DOTFILES_BIN/dotfiles-secrets-bootstrap" discover
    else
        echo.warning "Enhanced discovery not available - using basic search"
        if command -v gh &>/dev/null && gh auth status &>/dev/null; then
            echo.info "Searching GitHub gists..."
            gh gist list --limit 50 | grep -i "dotfiles\|env\|secrets" || echo.info "No matching gists found"
        else
            echo.error "GitHub CLI not available or not authenticated"
        fi
    fi
}

# Bootstrap command (delegated to dedicated bootstrap script)
function env_sync_bootstrap() {
    echo.info "Bootstrapping secrets sync..."
    if command -v "$DOTFILES_BIN/dotfiles-secrets-bootstrap" &>/dev/null; then
        "$DOTFILES_BIN/dotfiles-secrets-bootstrap" setup
    else
        echo.warning "Enhanced bootstrap not available - using fallback"
        env_sync_init
    fi
}

# Auto-sync on dotfiles operations
function env_sync_auto() {
    if [[ -f "$SYNC_URL_FILE" ]] && [[ "${DOTFILES_AUTO_SYNC:-0}" == "1" ]]; then
        echo.info "Auto-syncing environment variables..."
        env_sync_push
    fi
}

# Main function
function main() {
    local command="$1"
    shift
    
    case "$command" in
        "init")
            env_sync_init
            ;;
        "push"|"upload")
            env_sync_push
            ;;
        "pull"|"download")
            env_sync_pull
            ;;
        "auto")
            env_sync_auto
            ;;
        "status")
            env_sync_status
            ;;
        "discover")
            env_sync_discover
            ;;
        "bootstrap")
            env_sync_bootstrap
            ;;
        "help"|"--help"|"-h"|"")
            echo.header "Dotfiles Environment Sync"
            echo
            echo.info "Usage: dotfiles env-sync <command>"
            echo
            echo.info "Commands:"
            echo.cyan "  init" | tr '\n' ' '
            echo "       - Initialize sync system"
            echo.cyan "  push" | tr '\n' ' '
            echo "       - Encrypt and upload environment variables"
            echo.cyan "  pull" | tr '\n' ' '
            echo "       - Download and decrypt environment variables"
            echo.cyan "  status" | tr '\n' ' '
            echo "       - Show sync configuration"
            echo.cyan "  help" | tr '\n' ' '
            echo "       - Show this help"
            echo
            echo.info "Setup:"
            echo "1. Run 'dotfiles env-sync init' on your main machine"
            echo "2. Run 'dotfiles env-sync push' to upload environment variables"
            echo "3. On new machine: clone dotfiles, then 'dotfiles env-sync pull'"
            echo
            echo.info "Auto-sync:"
            echo "Set DOTFILES_AUTO_SYNC=1 in your environment for automatic syncing"
            ;;
        *)
            echo.error "Unknown command: $command"
            echo.info "Run 'dotfiles env-sync help' for usage"
            return 1
            ;;
    esac
}

main "$@"
