#!/usr/bin/env bash

source "${HOME}/.config/dotfiles/core/_env"
source "${HOME}/.config/dotfiles/core/_colors"
source "${HOME}/.config/dotfiles/core/_safety"

function dotfiles_version() {
    echo.header "Dotfiles v${DOTFILES_VERSION}"
    echo
    echo "  Path: $DOTFILES_ROOT"
    echo "  Shell: $DOTFILES_SHELL"
    echo "  OS: $DOTFILES_OS ($DOTFILES_ARCH)"
    echo
    echo "Components:"
    
    # Show module counts from configuration if available
    local modules_config="$DOTFILES_UTILS/modules.json"
    if [[ -f "$modules_config" ]]; then
        local total_modules=$(jq -r '[.modules, .plugins, .aliases] | map(length) | add' "$modules_config" 2>/dev/null || echo 0)
        local enabled_modules=$(jq -r '[.modules, .plugins, .aliases] | map(to_entries[] | select(.value.enabled == true)) | length' "$modules_config" 2>/dev/null || echo 0)
        echo "  â€¢ $enabled_modules/$total_modules modules enabled"
    else
        echo "  â€¢ $(find $DOTFILES_MODULES -maxdepth 1 -type f 2>/dev/null | wc -l) legacy modules"
    fi
    
    echo "  â€¢ $(ls $DOTFILES_BIN 2>/dev/null | wc -l) commands"
    echo "  â€¢ $(jq 'length' $DOTFILES_LINKS_DB 2>/dev/null || echo 0) symlinks"
    echo "  â€¢ $(jq 'length' $DOTFILES_ENV_DB 2>/dev/null || echo 0) env variables"
}

function dotfiles_reload() {
    echo.info "Reloading shell..."
    exec ${SHELL}
}

function dotfiles_update() {
    echo.header "Updating Dotfiles"
    
    cd "$DOTFILES_ROOT" || exit 1
    
    echo.info "Fetching updates..."
    git fetch origin
    
    local LOCAL=$(git rev-parse @)
    local REMOTE=$(git rev-parse @{u})
    
    if [[ "$LOCAL" == "$REMOTE" ]]; then
        echo.success "Already up to date"
    else
        echo.info "Updates available"
        git pull origin main
        echo.success "Updated successfully"
        dotfiles_reload
    fi
}

function dotfiles_doctor() {
    echo.header "Dotfiles Health Check"
    
    local issues=0
    
    # Check core files
    echo.info "Checking core files..."
    for file in cfg core/_env core/_colors core/_safety core/_bootstrap; do
        if [[ ! -f "$DOTFILES_ROOT/$file" ]]; then
            echo.error "  âœ— Missing: $file"
            ((issues++))
        else
            echo.success "  âœ“ $file"
        fi
    done
    
    # Check directories
    echo.info "Checking directories..."
    for dir in bin modules utils configs logs; do
        if [[ ! -d "$DOTFILES_ROOT/$dir" ]]; then
            echo.warning "  âœ— Missing directory: $dir"
            mkdir -p "$DOTFILES_ROOT/$dir"
            echo.success "    Created: $dir"
        else
            echo.success "  âœ“ $dir"
        fi
    done
    
    # Check symlinks
    echo.info "Checking symlinks..."
    local broken=0
    jq -r 'to_entries | .[] | "\(.key)"' "$DOTFILES_LINKS_DB" 2>/dev/null | \
    while read -r target; do
        if [[ ! -e "$target" ]]; then
            echo.warning "  âœ— Broken link: $target"
            ((broken++))
        fi
    done
    
    if [[ $broken -gt 0 ]]; then
        echo.warning "  Found $broken broken symlinks. Run: dotfiles-link fix"
        ((issues++))
    else
        echo.success "  âœ“ All symlinks valid"
    fi
    
    # Check commands
    echo.info "Checking commands..."
    for cmd in jq git curl; do
        if command -v $cmd &>/dev/null; then
            echo.success "  âœ“ $cmd"
        else
            echo.warning "  âœ— $cmd not found"
            ((issues++))
        fi
    done
    
    echo
    if [[ $issues -eq 0 ]]; then
        echo.success "No issues found!"
    else
        echo.warning "Found $issues issue(s)"
    fi
}


function dotfiles_install() {
    echo.header "Installing Dotfiles"
    
    # Create symlink to shell rc
    if [[ "$DOTFILES_SHELL" == "bash" ]]; then
        safe_link "$DOTFILES_ROOT/cfg" "$HOME/.bashrc"
    elif [[ "$DOTFILES_SHELL" == "zsh" ]]; then
        safe_link "$DOTFILES_ROOT/cfg" "$HOME/.zshrc"
    fi
    
    # Add bin to path in profile
    if ! grep -q "DOTFILES_ROOT" "$HOME/.profile" 2>/dev/null; then
        echo 'export PATH="$HOME/.config/dotfiles/bin:$PATH"' >> "$HOME/.profile"
    fi
    
    echo.success "Dotfiles installed"
    echo.info "Restart your shell or run: source ~/.${DOTFILES_SHELL}rc"
}

function dotfiles_modules() {
    # Check if new module management system is available
    if command -v dotfiles-modules >/dev/null 2>&1; then
        echo.info "Using new module management system"
        dotfiles-modules "${@:2}"
        return $?
    fi
    
    # Fallback to legacy system
    echo.header "Module Manager (Legacy)"
    echo.warning "Consider running 'dotfiles-modules init' to use the new configuration system"
    
    case "${2:-list}" in
        list|ls)
            echo.cyan "Enabled modules:"
            for file in "$DOTFILES_MODULES/enabled"/*; do
                [[ -f "$file" ]] && echo "  â€¢ $(basename "$file")"
            done
            
            echo.cyan "Disabled modules:"
            for file in "$DOTFILES_MODULES/disabled"/*; do
                [[ -f "$file" ]] && echo "  â€¢ $(basename "$file")"
            done
            ;;
            
        enable)
            local module="${3}"
            if [[ -z "$module" ]]; then
                echo.error "Usage: dotfiles modules enable <module>"
                return 1
            fi
            
            if [[ -f "$DOTFILES_MODULES/disabled/$module" ]]; then
                mv "$DOTFILES_MODULES/disabled/$module" "$DOTFILES_MODULES/enabled/"
                echo.success "Enabled module: $module"
            else
                echo.error "Module not found: $module"
            fi
            ;;
            
        disable)
            local module="${3}"
            if [[ -z "$module" ]]; then
                echo.error "Usage: dotfiles modules disable <module>"
                return 1
            fi
            
            if [[ -f "$DOTFILES_MODULES/enabled/$module" ]]; then
                ensure_dir "$DOTFILES_MODULES/disabled"
                mv "$DOTFILES_MODULES/enabled/$module" "$DOTFILES_MODULES/disabled/"
                echo.success "Disabled module: $module"
            else
                echo.error "Module not found: $module"
            fi
            ;;
            
        *)
            echo.error "Unknown command: ${2}"
            echo "Usage: dotfiles modules [list|enable|disable] [module]"
            echo "       or use: dotfiles-modules [command] for full features"
            ;;
    esac
}

function dotfiles_aliases_help() {
    echo.purple "ðŸš€ Aliases:"
    local alias_count=0
    local max_per_category=3  # Limit to keep compact
    
    for file in "$DOTFILES_ROOT/modules/aliases"/*.aliases; do
        if [[ -f "$file" ]]; then
            local category=$(basename "$file" .aliases)
            local current_count=0
            
            # Show category header only if we have aliases to show
            local has_aliases=false
            while IFS= read -r line; do
                if [[ "$line" =~ ^#\ @alias\ (.+) ]] && [[ $current_count -lt $max_per_category ]]; then
                    has_aliases=true
                    break
                fi
            done < "$file"
            
            if [[ "$has_aliases" == "true" ]]; then
                [[ $alias_count -eq 0 ]] || echo  # Add spacing between categories
                echo.cyan "  $category:"
                
                current_count=0
                while IFS= read -r line; do
                    if [[ "$line" =~ ^#\ @alias\ (.+) ]] && [[ $current_count -lt $max_per_category ]]; then
                        local alias_name="${BASH_REMATCH[1]}"
                        read -r desc_line
                        if [[ "$desc_line" =~ ^#\ @desc\ (.+) ]]; then
                            local alias_desc="${BASH_REMATCH[1]}"
                            printf "    %-12s %s\n" "$alias_name" "$alias_desc"
                            ((current_count++))
                            ((alias_count++))
                        fi
                    fi
                done < "$file"
                
                # Show "more available" if we truncated
                local total_aliases=$(grep -c "^# @alias" "$file" 2>/dev/null || echo 0)
                if [[ $total_aliases -gt $max_per_category ]]; then
                    echo.info "    ... and $(($total_aliases - $max_per_category)) more"
                fi
            fi
        fi
    done
    
    if [[ $alias_count -eq 0 ]]; then
        echo "  No documented aliases found"
    fi
}

function dotfiles_personal_dashboard() {
    local API_URL="http://localhost:3451"
    
    if command -v xdg-open &>/dev/null; then
        xdg-open "$API_URL" 2>/dev/null
    elif command -v open &>/dev/null; then
        open "$API_URL" 2>/dev/null
    else
        echo.info "Open your browser to: $API_URL"
    fi
}

function dotfiles_track_project() {
    local path="${1:-$PWD}"
    local language="${2:-}"
    local git_remote=""
    local git_branch=""
    local API_URL="http://localhost:3451"
    local API_TOKEN="dev-token"
    
    echo.debug "Tracking project: $path"
    
    # Check if API server is available
    if ! curl -s --connect-timeout 1 "$API_URL/health" >/dev/null 2>&1; then
        echo.warning "Personal dashboard API not available at $API_URL"
        return 1
    fi
    
    # Auto-detect git info if in git repo
    if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        git_remote=$(git remote get-url origin 2>/dev/null || echo "")
        git_branch=$(git branch --show-current 2>/dev/null || echo "")
    fi
    
    # Auto-detect language from common files
    if [[ -z "$language" ]]; then
        if [[ -f "package.json" ]]; then
            language="JavaScript/TypeScript"
        elif [[ -f "go.mod" ]]; then
            language="Go"
        elif [[ -f "Cargo.toml" ]]; then
            language="Rust"
        elif [[ -f "requirements.txt" || -f "pyproject.toml" ]]; then
            language="Python"
        elif [[ -f "pom.xml" ]]; then
            language="Java"
        fi
    fi
    
    # Send to API
    if curl -s -X POST \
        -H "Authorization: Bearer $API_TOKEN" \
        -H "Content-Type: application/json" \
        -d "{\"path\":\"$path\",\"git_remote\":\"$git_remote\",\"git_branch\":\"$git_branch\",\"language\":\"$language\"}" \
        "$API_URL/api/projects" > /dev/null 2>&1; then
        echo.success "Project tracked: $path"
    else
        echo.error "Failed to track project"
        return 1
    fi
}

function dotfiles_sync() {
    echo.header "Dotfiles Sync"
    
    local has_changes=false
    
    # Check and commit git changes
    cd "$DOTFILES_ROOT" || return 1
    
    if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        if ! git diff --quiet 2>/dev/null || ! git diff --cached --quiet 2>/dev/null; then
            echo.info "Found uncommitted changes..."
            git add -A
            git commit -m "Auto-sync: $(date +'%Y-%m-%d %H:%M:%S')" 
            echo.success "Changes committed"
            has_changes=true
        fi
        
        # Check for untracked files
        if [[ -n "$(git ls-files --others --exclude-standard 2>/dev/null)" ]]; then
            echo.info "Found untracked files..."
            git add .
            git commit -m "Add untracked files: $(date +'%Y-%m-%d %H:%M:%S')" 
            echo.success "Untracked files added"
            has_changes=true
        fi
    fi
    
    # Remove sync-needed marker if it exists
    [[ -f "$DOTFILES_UTILS/sync-needed" ]] && rm -f "$DOTFILES_UTILS/sync-needed"
    
    if [[ "$has_changes" == "true" ]]; then
        echo.success "Dotfiles synchronized successfully!"
        echo.info "Restart shell to see updated status"
    else
        echo.success "Dotfiles already in sync!"
    fi
}

function dotfiles_tour() {
    echo.header "Dotfiles Tour & Sync"
    echo.info "This will guide you through synchronizing your dotfiles..."
    echo
    
    # Run sync
    dotfiles_sync
    
    echo
    echo.info "Quick tour of available commands:"
    echo "  â€¢ $(echo.cyan 'reload')     - Restart shell with updated config"
    echo "  â€¢ $(echo.cyan 'dotfiles doctor') - Run health diagnostics"
    echo "  â€¢ $(echo.cyan 'envs list')  - Manage environment variables"
    echo "  â€¢ $(echo.cyan 'z <dir>')    - Jump to directories with zoxide"
    echo
}

function dotfiles_help() {
    # Check if new help system is available
    local help_cmd="$DOTFILES_BIN/dotfiles-help"
    if [[ -x "$help_cmd" ]]; then
        echo.info "ðŸŒ¸ Using comprehensive help system"
        "$help_cmd" "${@:2}"
        return $?
    fi
    
    # Fallback to legacy help
    echo.header "ðŸ”§ Dotfiles Management System"
    echo.cyan "Usage: dotfiles <command> [args]"
    echo
    
    # Core Commands - most frequently used
    echo.purple "âš¡ Core Commands:"
    printf "  %-12s %s\n" "$(echo.cyan 'help')" "Show this help"
    printf "  %-12s %s\n" "$(echo.cyan 'version')" "Show version info"
    printf "  %-12s %s\n" "$(echo.cyan 'reload')" "Reload config"
    printf "  %-12s %s\n" "$(echo.cyan 'doctor')" "Health check"
    printf "  %-12s %s\n" "$(echo.cyan 'sync')" "Commit changes"
    printf "  %-12s %s\n" "$(echo.cyan 'tour')" "Guided setup"
    echo
    
    # Management Commands - organized in columns
    echo.purple "ðŸ”§ Management:"  
    printf "  %-12s %-20s %-12s %s\n" "$(echo.cyan 'modules')" "Manage modules" "$(echo.cyan 'link')" "Symlink manager"
    printf "  %-12s %-20s %-12s %s\n" "$(echo.cyan 'env')" "Environment vars" "$(echo.cyan 'new')" "Create module/script"
    printf "  %-12s %-20s %-12s %s\n" "$(echo.cyan 'scripts')" "Custom scripts help" "$(echo.cyan 'templates')" "Available templates"
    printf "  %-12s %-20s %-12s %s\n" "$(echo.cyan 'generate')" "Code generators" "$(echo.cyan 'templates')" "Available templates"
    echo
    
    # Quick Actions - single line each
    echo.purple "âš¡ Quick Actions:"
    printf "  %-12s %-20s %-12s %-20s %-12s %s\n" \
        "$(echo.cyan 'cd')" "Go to dotfiles" \
        "$(echo.cyan 'edit')" "Edit in \$EDITOR" \
        "$(echo.cyan 'logs')" "View error logs"
    printf "  %-12s %-20s %-12s %-20s %-12s %s\n" \
        "$(echo.cyan 'update')" "Git pull latest" \
        "$(echo.cyan 'install')" "Setup symlinks" \
        "$(echo.cyan 'studio')" "Dev tools"
    echo
    
    # Version & Dashboard - compact
    echo.purple "ðŸ“Š Tools:"
    printf "  %-12s %-20s %-12s %s\n" \
        "$(echo.cyan 'dashboard')" "Personal dashboard" \
        "$(echo.cyan 'track')" "Track project"
    printf "  %-12s %-20s %-12s %s\n" \
        "$(echo.cyan 'fans')" "Fan control system" \
        "$(echo.cyan 'version')" "Version management"
    echo
    
    # Aliases - condensed
    dotfiles_aliases_help
    echo
    
    # Examples - fewer lines
    echo.purple "âœ¨ Quick Examples:"
    echo.success "  dotfiles doctor â€¢ dotfiles env set KEY â€¢ dotfiles new module â€¢ dotfiles generate"
    echo
    echo.info "ðŸ’¡ Use: dotfiles <command> help for detailed help"
    echo.info "ðŸŽ† Try: dotfiles help (comprehensive version)"
}

function dotfiles_studio_start() {
    local app_dir="$DOTFILES_ROOT/core/_internal-tools/starship-visual-generator"
    if [[ ! -d "$app_dir" ]]; then
        echo.error "Studio app not found at $app_dir"
        return 1
    fi
    echo.info "Starting Dotfiles Studio in background..."
    (
      cd "$app_dir" && nohup bun run start > "$DOTFILES_ROOT/logs/studio.log" 2>&1 & echo $! > "$DOTFILES_ROOT/logs/studio.pid"
    )
    sleep 1
    local url="http://localhost:5173"
    echo.success "Studio started at ${url}"
    read -r -p "Open in browser? [Y/n] " ans
    ans=${ans:-Y}
    if [[ "$ans" == "Y" || "$ans" == "y" ]]; then
        if command -v xdg-open >/dev/null 2>&1; then xdg-open "$url" >/dev/null 2>&1 &
        elif command -v open >/dev/null 2>&1; then open "$url" >/dev/null 2>&1 &
        else echo.info "Please open $url in your browser"; fi
    fi
    echo.info "Vite server running in background; CLI remains usable"
}

function dotfiles_studio_deploy() {
    local app_dir="$DOTFILES_ROOT/core/_internal-tools/starship-visual-generator"
    if [[ ! -d "$app_dir" ]]; then
        echo.error "Studio app not found at $app_dir"
        return 1
    fi
    if ! command -v vercel >/dev/null 2>&1; then
        echo.error "vercel CLI not found. Install with: npm i -g vercel"
        return 1
    fi
    echo.header "Building and deploying Dotfiles Studio"
    (
      cd "$app_dir" && bun run build
    ) || { echo.error "Build failed"; return 1; }
    local deploy_url
    deploy_url=$(cd "$app_dir" && vercel deploy --prod --yes 2>/dev/null | tail -n 1)
    if [[ -z "$deploy_url" ]]; then
        echo.error "Deploy failed"
        return 1
    fi
    echo.success "Deployed: $deploy_url"
    local alias="dotfiles-studio"
    local chosen_alias=""
    if (cd "$app_dir" && vercel alias set "$deploy_url" "$alias" >/dev/null 2>&1); then
        chosen_alias="$alias"
        echo.success "Alias set: https://$alias.vercel.app"
    else
        local fallback1="${alias}-$(whoami)"
        if (cd "$app_dir" && vercel alias set "$deploy_url" "$fallback1" >/dev/null 2>&1); then
            chosen_alias="$fallback1"
            echo.success "Alias set: https://$fallback1.vercel.app"
        else
            local fallback2="${alias}-$(date +%s)"
            if (cd "$app_dir" && vercel alias set "$deploy_url" "$fallback2" >/dev/null 2>&1); then
                chosen_alias="$fallback2"
                echo.success "Alias set: https://$fallback2.vercel.app"
            else
                echo.warning "Could not set alias; use deployed URL above"
            fi
        fi
    fi
    if [[ -n "$chosen_alias" ]]; then
        echo "$chosen_alias" > "$DOTFILES_ROOT/logs/studio.alias"
    fi
}

function dotfiles_studio_stop() {
    local pid_file="$DOTFILES_ROOT/logs/studio.pid"
    if [[ ! -f "$pid_file" ]]; then
        echo.warning "Studio is not running (no PID file)"
        return 0
    fi
    local pid=$(cat "$pid_file")
    if kill -0 "$pid" >/dev/null 2>&1; then
        kill "$pid" >/dev/null 2>&1 && echo.success "Stopped studio (pid $pid)" || echo.warning "Failed to stop pid $pid"
    else
        echo.info "No running process for pid $pid"
    fi
    rm -f "$pid_file"
}

function dotfiles_studio_open() {
    local alias_arg="${1:-}"
    local alias_file="$DOTFILES_ROOT/logs/studio.alias"
    local alias_name=""
    if [[ -n "$alias_arg" ]]; then
        alias_name="$alias_arg"
    elif [[ -f "$alias_file" ]]; then
        alias_name=$(cat "$alias_file")
    else
        alias_name="dotfiles-studio"
    fi
    local url="https://$alias_name.vercel.app"
    echo.info "Opening $url"
    if command -v xdg-open >/dev/null 2>&1; then xdg-open "$url" >/dev/null 2>&1 &
    elif command -v open >/dev/null 2>&1; then open "$url" >/dev/null 2>&1 &
    else echo "$url"; fi
}

function dotfiles_generate() {
    echo.header "ðŸ› ï¸ Dotfiles Code Generators"
    echo
    echo.info "Choose a generator to create helpful scripts and documentation:"
    echo
    
    echo.purple "â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®"
    echo.purple "â”‚                    âœ¨ Available Generators âœ¨                â”‚"
    echo.purple "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤"
    echo.purple "â”‚                                                             â”‚"
    echo.purple "â”‚  [1] ðŸ“„ Source-All Script Generator                        â”‚"
    echo.cyan   "â”‚      Create scripts that auto-source .sh files             â”‚"
    echo.purple "â”‚                                                             â”‚"
    echo.purple "â”‚  [2] ðŸŒ¸ Alias Help Generator                               â”‚"
    echo.cyan   "â”‚      Generate aesthetic help menus from alias files        â”‚"
    echo.purple "â”‚                                                             â”‚"
    echo.purple "â”‚  [q] âŒ Quit                                               â”‚"
    echo.purple "â”‚                                                             â”‚"
    echo.purple "â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯"
    echo
    
    echo -n "[38;2;255;211;146mChoose an option [1-2, q]: [0m"
    read -r choice
    
    case "$choice" in
        1)
            echo.header "ðŸ“„ Source-All Script Generator"
            echo
            echo.info "This tool creates scripts that automatically source all .sh files in a directory"
            echo.info "Perfect for modular configurations and dynamic script loading"
            echo
            
            local generator="$DOTFILES_ROOT/core/_internal-tools/generate-source-all"
            if [[ -x "$generator" ]]; then
                "$generator"
            else
                echo.error "Generator not found or not executable: $generator"
                return 1
            fi
            ;;
        2)
            echo.header "ðŸŒ¸ Alias Help Generator"
            echo
            echo.info "Generate beautiful, aesthetic help menus from alias files"
            echo.info "Creates searchable, colorized documentation for your aliases"
            echo.info "Automatically adds docstrings and organizes by category"
            echo
            
            local alias_generator="$DOTFILES_BIN/dotfiles-gen-alias-help"
            if [[ -x "$alias_generator" ]]; then
                echo.cyan "Choose your approach:"
                echo.purple "  [1] Interactive file picker (recommended)"
                echo.purple "  [2] Select from specific folder"
                echo.purple "  [3] Specify exact file path"
                echo
                read -r approach
                
                case "$approach" in
                    1)
                        "$alias_generator" --interactive
                        ;;
                    2)
                        echo.cyan "Enter folder path (relative to dotfiles):"
                        echo.purple "(e.g., 'modules/aliases', 'configs')"
                        read -r folder_path
                        "$alias_generator" --folder "$folder_path"
                        ;;
                    3)
                        echo.cyan "Enter the full path to your alias file:"
                        read -r alias_file
                        
                        if [[ -f "$alias_file" ]]; then
                            "$alias_generator" --file "$alias_file"
                        else
                            echo.error "File not found: $alias_file"
                            return 1
                        fi
                        ;;
                    *)
                        echo.warning "Invalid choice, using interactive mode..."
                        "$alias_generator" --interactive
                        ;;
                esac
            else
                echo.error "Alias help generator not found: $alias_generator"
                return 1
            fi
            ;;
        q|Q|quit|exit)
            echo.info "Exiting generator menu"
            return 0
            ;;
        *)
            echo.error "Invalid choice: $choice"
            echo.info "Please choose 1, 2, or q"
            return 1
            ;;
    esac
}


function dotfiles_templates() {
    echo.header "Available Templates"
    echo
    
    local templates_dir="$DOTFILES_ROOT/core/_internal-tools/templates"
    if [[ -d "$templates_dir" ]]; then
        echo.info "Templates directory: $templates_dir"
        echo
        
        for template in "$templates_dir"/*; do
            if [[ -f "$template" ]]; then
                local name=$(basename "$template")
                echo.cyan "ðŸ“„ $name"
                
                # Show first few lines as preview
                head -n 3 "$template" 2>/dev/null | sed 's/^/    /'
                echo "    ..."
                echo
            fi
        done
        
        echo.info "To use a template: cp $templates_dir/<template> <destination>"
    else
        echo.warning "Templates directory not found: $templates_dir"
        
        # Show alternative location
        local alt_templates="$DOTFILES_ROOT/templates"
        if [[ -d "$alt_templates" ]]; then
            echo.info "Found alternative templates at: $alt_templates"
            ls -la "$alt_templates"
        fi
    fi
}



case "${1:-help}" in
    version|v)
        if [[ -n "$2" ]]; then
            # Delegate to dotfiles-version for subcommands
            shift
            "$DOTFILES_BIN/dotfiles-version" "$@"
        else
            dotfiles_version
        fi
        ;;
    reload|r)
        dotfiles_reload
        ;;
    update|u)
        dotfiles_update
        ;;
    doctor|check)
        case "$2" in
            animated|a)
                shift 2
                "$DOTFILES_BIN/dotfiles-doctor-animated" "$@"
                ;;
            fast|f)
                "$DOTFILES_BIN/dotfiles-doctor-fast"
                ;;
            *)
                dotfiles_doctor
                ;;
        esac
        ;;
    install|i)
        dotfiles_install
        ;;
    modules|mod|m)
        dotfiles_modules "$@"
        ;;
    new|n)
        shift
        "$DOTFILES_BIN/dotfiles-new" "$@"
        ;;
    link|l)
        shift
        "$DOTFILES_BIN/dotfiles-link" "$@"
        ;;
    env|e)
        shift
        "$DOTFILES_BIN/dotfiles-env" "$@"
        ;;
    scripts|script)
        shift
        if command -v scripts >/dev/null 2>&1; then
            scripts "$@"
        else
            echo.error "Scripts module not loaded"
            echo.info "Try: reload or source ~/.zshrc"
            return 1
        fi
        ;;
    sync)
        dotfiles_sync
        ;;
    tour)
        dotfiles_tour
        ;;
    cd)
        cd "$DOTFILES_ROOT"
        ;;
    edit)
        ${EDITOR:-vim} "$DOTFILES_ROOT"
        ;;
    logs)
        if [[ -f "$DOTFILES_ERROR_LOG" ]]; then
            tail -n 50 "$DOTFILES_ERROR_LOG"
        else
            echo.info "No error logs found"
        fi
        ;;
    dashboard|dash)
        dotfiles_personal_dashboard
        ;;
    track)
        dotfiles_track_project "$@"
        ;;
    generate|gen)
        dotfiles_generate
        ;;
    templates|tmpl|t)
        dotfiles_templates
        ;;
    prompt|p)
        shift
        if [[ -x "$DOTFILES_BIN/prompt" ]]; then
            "$DOTFILES_BIN/prompt" "$@"
        else
            echo.error "Prompt command not found"
            echo.info "Try: dotfiles doctor to check system health"
            return 1
        fi
        ;;
    studio)
        case "${2:-start}" in
            start|dev)
                dotfiles_studio_start
                ;;
            stop)
                dotfiles_studio_stop
                ;;
            deploy)
                dotfiles_studio_deploy
                ;;
            open)
                shift 2
                dotfiles_studio_open "$@"
                ;;
            *)
                echo.error "Usage: dotfiles studio [start|stop|deploy|open [alias]]"
                ;;
        esac
        ;;
help|h|--help|-h)
    dotfiles_help "$@"
    ;;
*)
    echo.error "Unknown command: $1"
    dotfiles_help
    exit 1
    ;;
esac


