#!/usr/bin/env bash

# Interactive manager for additional-packages.json

set -euo pipefail

# --- Configuration ---
PACKAGES_FILE="$(dirname "$0")/../configs/additional-packages.json"

# --- Colors and Formatting ---
RED='[0;31m'
GREEN='[0;32m'
YELLOW='[1;33m'
BLUE='[0;34m'
PURPLE='[0;35m'
CYAN='[0;36m'
NC='[0m' # No Color
BOLD='[1m'

# --- Utility Functions ---
log_info() { echo -e "${CYAN}â„¹${NC} $1"; }
log_success() { echo -e "${GREEN}âœ“${NC} $1"; }
log_error() { echo -e "${RED}âœ—${NC} $1"; }

# Ensure jq and fzf are installed
if ! command -v jq &>/dev/null || ! command -v fzf &>/dev/null; then
    log_error "This tool requires 'jq' and 'fzf'. Please install them first."
    exit 1
fi

backup_file() {
    cp "$PACKAGES_FILE" "${PACKAGES_FILE}.bak"
    log_info "Created backup at ${PACKAGES_FILE}.bak"
}

# --- Core Functions ---

show_main_menu() {
    clear
    echo -e "${BOLD}${BLUE}ðŸ“¦ Additional Packages Manager${NC}"
    echo "---------------------------------"
    echo "1) List Packages"
    echo "2) Add New Package"
    echo "3) Edit Existing Package"
    echo "4) Remove Package"
    echo "q) Quit"
    echo "---------------------------------"
    read -p "Choose an option: " choice
}

list_packages() {
    jq -r '.[] | "\n\t\u001b[1m\u001b[35mName:\u001b[0m \(.name)\n\t\u001b[1mDescription:\u001b[0m \(.description)"' "$PACKAGES_FILE"
    read -p "\nPress Enter to return to the menu..."
}

add_package() {
    backup_file

    read -p "Package Name (e.g., lazygit): " name
    read -p "Description: " description
    read -p "Docs URL (optional): " docs

    local new_pkg
    new_pkg=$(jq -n \
        --arg name "$name" \
        --arg description "$description" \
        --arg docs "$docs" \
        '{name: $name, description: $description, docs: $docs, commands: []}')

    while true; do
        read -p "Add a command? [y/N]: " add_cmd
        if [[ ! "$add_cmd" =~ ^[Yy]$ ]]; then break; fi

        read -p "  OS (e.g., linux, macos, or blank): " os
        read -p "  Distro (e.g., ubuntu, or blank): " distro
        read -p "  Package Manager (e.g., apt, brew): " manager
        read -p "  Install Command: " command

        local new_cmd
        new_cmd=$(jq -n \
            --arg os "$os" --arg distro "$distro" --arg manager "$manager" --arg command "$command" \
            '{os: $os, distro: $distro, manager: $manager, command: $command} | with_entries(select(.value != ""))')
        
        new_pkg=$(echo "$new_pkg" | jq --argjson new_cmd "$new_cmd" '.commands += [$new_cmd]')
    done

    local updated_json=$(jq --argjson new_pkg "$new_pkg" '. + [$new_pkg]' "$PACKAGES_FILE")
    echo "$updated_json" | jq '.' > "$PACKAGES_FILE"

    log_success "Package '$name' added successfully."
    sleep 1
}

edit_package() {
    local selection=$(jq -r '.[].name' "$PACKAGES_FILE" | fzf --prompt="Select a package to edit: ")
    if [[ -z "$selection" ]]; then return; fi

    backup_file

    local pkg_index=$(jq -r "map(.name == \"$selection\") | index(true)" "$PACKAGES_FILE")
    local pkg_obj=$(jq ".[${pkg_index}]" "$PACKAGES_FILE")

    log_info "Editing '$selection'. Press Enter to keep the current value."

    read -p "Name [$(echo $pkg_obj | jq -r .name)]: " new_name
    read -p "Description [$(echo $pkg_obj | jq -r .description)]: " new_description
    read -p "Docs [$(echo $pkg_obj | jq -r .docs)]: " new_docs

    # Update fields
    pkg_obj=$(echo "$pkg_obj" | jq --arg val "${new_name:-$(echo $pkg_obj | jq -r .name)}" '.name = $val')
    pkg_obj=$(echo "$pkg_obj" | jq --arg val "${new_description:-$(echo $pkg_obj | jq -r .description)}" '.description = $val')
    pkg_obj=$(echo "$pkg_obj" | jq --arg val "${new_docs:-$(echo $pkg_obj | jq -r .docs)}" '.docs = $val')

    # In a real script, editing the commands array would be more complex.
    # For now, we'll just show them.
    log_info "Current commands:
$(echo $pkg_obj | jq -r '.commands[] | tojson')"
    read -p "(Command editing not yet implemented). Press Enter to save other changes."

    local updated_json=$(jq --argjson new_obj "$pkg_obj" ".[${pkg_index}] = \"$new_obj\"" "$PACKAGES_FILE")
    echo "$updated_json" | jq '.' > "$PACKAGES_FILE"

    log_success "Package '$selection' updated."
    sleep 1
}

remove_package() {
    local selection=$(jq -r '.[].name' "$PACKAGES_FILE" | fzf --prompt="Select a package to REMOVE: ")
    if [[ -z "$selection" ]]; then return; fi

    read -p "Are you sure you want to permanently remove '$selection'? [y/N]: " confirm
    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        log_info "Removal cancelled."
        return
    fi

    backup_file

    local updated_json=$(jq "del(.[] | select(.name == \"$selection\"))" "$PACKAGES_FILE")
    echo "$updated_json" | jq '.' > "$PACKAGES_FILE"

    log_success "Package '$selection' has been removed."
    sleep 1
}

# --- Main Loop ---
while true; do
    show_main_menu
    case "$choice" in
        1) list_packages ;; 
        2) add_package ;; 
        3) edit_package ;; 
        4) remove_package ;; 
        q|Q) break ;; 
        *) log_error "Invalid option. Please try again." && sleep 1 ;; 
    esac
done

log_success "Exiting package manager."
