#!/usr/bin/env python3

import os
import sys
import subprocess
from pathlib import Path
from typing import Optional, List, Tuple
import shutil

# Colors for better terminal output
class Colors:
    RESET = '\033[0m'
    BOLD = '\033[1m'
    DIM = '\033[2m'
    RED = '\033[31m'
    GREEN = '\033[32m'
    YELLOW = '\033[33m'
    BLUE = '\033[34m'
    MAGENTA = '\033[35m'
    CYAN = '\033[36m'
    WHITE = '\033[37m'
    BRIGHT_CYAN = '\033[96m'

class DatabaseManager:
    def __init__(self):
        self.dotfiles_path = self._get_dotfiles_path()
        self.scripts_path = self.dotfiles_path / "scripts"
        self.bin_path = self.dotfiles_path / "bin"
        self.missing_deps = []
        self._check_dependencies()
        
    def _get_dotfiles_path(self) -> Path:
        env_path = os.getenv('DOTFILES_PATH')
        if env_path:
            path = Path(env_path)
            if path.exists():
                return path
        
        default_path = Path.home() / ".config" / "dotfiles"
        if default_path.exists():
            return default_path
        
        script_path = Path(__file__).parent.parent
        if (script_path / "scripts").exists():
            return script_path
        
        print(f"{Colors.RED}Error: Could not locate dotfiles directory{Colors.RESET}")
        print(f"{Colors.DIM}Tried:{Colors.RESET}")
        print(f"  - $DOTFILES_PATH: {env_path or 'not set'}")
        print(f"  - {default_path}")
        print(f"  - {script_path}")
        print(f"\n{Colors.YELLOW}Set DOTFILES_PATH environment variable or ensure dotfiles are at ~/.config/dotfiles{Colors.RESET}")
        sys.exit(1)
    
    def _check_dependencies(self):
        self.missing_deps = []
        
        python_deps = [
            ('psycopg2', 'psycopg2-binary', 'PostgreSQL adapter'),
            ('rich', 'rich', 'Enhanced terminal UI'),
            ('keyring', 'keyring', 'Secure credential storage'),
            ('cryptography', 'cryptography', 'Encryption support')
        ]
        
        for module_name, package_name, description in python_deps:
            try:
                __import__(module_name)
            except ImportError:
                self.missing_deps.append({
                    'type': 'python',
                    'name': description,
                    'package': package_name,
                    'install': f'pip install {package_name}'
                })
        
        cli_deps = [
            ('turso', 'Turso CLI', 'curl -sSfL https://get.tur.so/install.sh | bash'),
        ]
        
        for cmd, name, install in cli_deps:
            if not shutil.which(cmd):
                self.missing_deps.append({
                    'type': 'cli',
                    'name': name,
                    'package': cmd,
                    'install': install
                })
    
    def _show_dependency_warnings(self):
        if not self.missing_deps:
            return
        
        print(f"\n{Colors.YELLOW}âš ï¸  Optional Dependencies Missing:{Colors.RESET}")
        for dep in self.missing_deps:
            print(f"  {Colors.DIM}â€¢ {dep['name']}{Colors.RESET}")
            print(f"    Install: {Colors.CYAN}{dep['install']}{Colors.RESET}")
        print()
    
    def print_header(self):
        header = f"""
{Colors.CYAN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    ðŸ—„ï¸  DATABASE MANAGER v1.0                 â•‘
â•‘                     Unified Database Toolkit                 â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•{Colors.RESET}
        """
        print(header)
        self._show_dependency_warnings()
    
    def print_menu(self):
        menu_items = [
            ("1", "ðŸ˜ PostgreSQL Manager", "Interactive PostgreSQL database management"),
            ("2", "ðŸ” Database Analyzer", "AI-powered database performance analysis"),
            ("3", "ðŸš€ Turso Environment Generator", "Generate Turso database configuration"),
            ("4", "ðŸ³ Docker Manager", "Container management for databases"),
            ("5", "ðŸ“‹ Show All Tools Info", "Display detailed information about all tools"),
            ("h", "â“ Help", "Show detailed usage information"),
            ("q", "ðŸšª Quit", "Exit the database manager")
        ]
        
        print(f"{Colors.BOLD}{Colors.WHITE}Available Database Tools:{Colors.RESET}\n")
        
        for key, title, description in menu_items:
            key_color = Colors.BRIGHT_CYAN if key.isdigit() else Colors.YELLOW
            print(f"  {key_color}[{key}]{Colors.RESET} {Colors.BOLD}{title}{Colors.RESET}")
            print(f"      {Colors.DIM}{description}{Colors.RESET}\n")
    
    def show_help(self):
        help_text = f"""
{Colors.BOLD}{Colors.CYAN}DATABASE MANAGER - DETAILED HELP{Colors.RESET}

{Colors.BOLD}Tool Descriptions:{Colors.RESET}

{Colors.GREEN}1. PostgreSQL Manager{Colors.RESET}
   â€¢ Interactive PostgreSQL database management
   â€¢ Connection management with secure credential storage
   â€¢ Query execution with syntax highlighting
   â€¢ Table management and SQL snippets
   â€¢ Support for cloud databases (Supabase, Neon, etc.)
   â€¢ Location: ~/.config/dotfiles/scripts/postgres

{Colors.GREEN}2. Database Analyzer{Colors.RESET}
   â€¢ AI-powered database performance analysis
   â€¢ Table statistics and usage patterns
   â€¢ Index optimization recommendations
   â€¢ Gemini AI integration for insights
   â€¢ Query performance analysis
   â€¢ Location: ~/.config/dotfiles/scripts/db_analyzer.py

{Colors.GREEN}3. Turso Environment Generator{Colors.RESET}
   â€¢ Generate Turso database environment variables
   â€¢ Interactive configuration setup
   â€¢ Secret management with reveal options
   â€¢ Environment file generation
   â€¢ Clipboard integration support
   â€¢ Location: ~/.config/dotfiles/scripts/generate-turso-db.py

{Colors.GREEN}4. Docker Manager{Colors.RESET}
   â€¢ Interactive Docker container management
   â€¢ Database container orchestration
   â€¢ Container lifecycle management (start/stop/remove)
   â€¢ Real-time logs and statistics
   â€¢ System cleanup utilities
   â€¢ Location: ~/.config/dotfiles/bin/docker

{Colors.BOLD}Usage Examples:{Colors.RESET}

  {Colors.CYAN}db{Colors.RESET}                    # Start interactive mode
  {Colors.CYAN}db postgres{Colors.RESET}          # Launch PostgreSQL manager directly
  {Colors.CYAN}db analyze{Colors.RESET}           # Run database analyzer
  {Colors.CYAN}db turso{Colors.RESET}             # Generate Turso environment
  {Colors.CYAN}db docker{Colors.RESET}            # Open Docker manager
  {Colors.CYAN}db --help{Colors.RESET}            # Show this help

{Colors.BOLD}Environment Requirements:{Colors.RESET}
  â€¢ Python 3.8+ (for most tools)
  â€¢ Node.js (for Docker manager)
  â€¢ PostgreSQL client tools (for postgres manager)
  â€¢ Optional: Rich library for enhanced UI (pip install rich)
        """
        print(help_text)
    
    def show_tools_info(self):
        info_text = f"""
{Colors.BOLD}{Colors.CYAN}DATABASE TOOLS - DETAILED INFORMATION{Colors.RESET}

{Colors.BOLD}ðŸ˜ PostgreSQL Manager{Colors.RESET}
   Status: {self._get_tool_status('postgres')}
   Features:
   â€¢ Interactive SQL query execution
   â€¢ Cloud database support (Supabase, Neon, Railway)
   â€¢ Secure credential management with keyring
   â€¢ Table inspection and management
   â€¢ Pre-built SQL snippets for common operations
   â€¢ Transaction support with rollback

{Colors.BOLD}ðŸ” Database Analyzer{Colors.RESET}
   Status: {self._get_tool_status('db_analyzer.py')}
   Features:
   â€¢ Performance bottleneck detection
   â€¢ Index usage analysis and recommendations
   â€¢ Table size and row count statistics
   â€¢ Query pattern analysis (with pg_stat_statements)
   â€¢ AI-powered optimization suggestions via Gemini

{Colors.BOLD}ðŸš€ Turso Environment Generator{Colors.RESET}
   Status: {self._get_tool_status('generate-turso-db.py')}
   Features:
   â€¢ Automated Turso database setup
   â€¢ Environment variable generation
   â€¢ Secret masking and reveal functionality
   â€¢ Configuration persistence
   â€¢ Multiple output formats (.env, JSON)

{Colors.BOLD}ðŸ³ Docker Manager{Colors.RESET}
   Status: {self._get_tool_status('docker', is_bin=True)}
   Features:
   â€¢ Container lifecycle management
   â€¢ Real-time monitoring and logs
   â€¢ Database container templates
   â€¢ System resource cleanup
   â€¢ Interactive terminal interface

{Colors.BOLD}Configuration Paths:{Colors.RESET}
   â€¢ Config Directory: {self.dotfiles_path}
   â€¢ Scripts Directory: {self.scripts_path}
   â€¢ Executables: {self.bin_path}
        """
        print(info_text)
    
    def _get_tool_status(self, tool_name: str, is_bin: bool = False) -> str:
        path = (self.bin_path if is_bin else self.scripts_path) / tool_name
        if path.exists():
            return f"{Colors.GREEN}âœ“ Available{Colors.RESET}"
        else:
            return f"{Colors.RED}âœ— Not Found{Colors.RESET}"
    
    def _test_connection(self, tool_name: str) -> Tuple[bool, str]:
        if tool_name == 'postgres':
            try:
                import psycopg2
                return True, "PostgreSQL adapter available"
            except ImportError:
                return False, "psycopg2 not installed (pip install psycopg2-binary)"
        elif tool_name == 'turso':
            if shutil.which('turso'):
                result = subprocess.run(['turso', 'auth', 'status'], 
                                      capture_output=True, text=True, timeout=5)
                if result.returncode == 0 and 'not logged in' not in result.stdout.lower():
                    return True, "Turso CLI authenticated"
                return False, "Turso CLI not authenticated (run: turso auth login)"
            return False, "Turso CLI not installed"
        return True, "No connection test available"
    
    def run_postgres_manager(self):
        postgres_script = self.scripts_path / "postgres"
        if not postgres_script.exists():
            print(f"{Colors.RED}Error: PostgreSQL manager not found at {postgres_script}{Colors.RESET}")
            return False
        
        print(f"{Colors.CYAN}ðŸ˜ Launching PostgreSQL Manager...{Colors.RESET}")
        print(f"{Colors.DIM}Testing connection requirements...{Colors.RESET}")
        
        success, message = self._test_connection('postgres')
        if not success:
            print(f"{Colors.YELLOW}âš ï¸  {message}{Colors.RESET}")
            proceed = input(f"{Colors.BOLD}Continue anyway? (y/N): {Colors.RESET}").strip().lower()
            if proceed != 'y':
                return False
        else:
            print(f"{Colors.GREEN}âœ“ {message}{Colors.RESET}")
        
        try:
            subprocess.run([sys.executable, str(postgres_script)], check=True)
        except subprocess.CalledProcessError as e:
            print(f"{Colors.RED}Error running PostgreSQL manager: {e}{Colors.RESET}")
            return False
        return True
    
    def run_db_analyzer(self):
        analyzer_script = self.scripts_path / "db_analyzer.py"
        if not analyzer_script.exists():
            print(f"{Colors.RED}Error: Database analyzer not found at {analyzer_script}{Colors.RESET}")
            return False
        
        print(f"{Colors.CYAN}ðŸ” Launching Database Analyzer...{Colors.RESET}")
        print(f"{Colors.DIM}Note: You'll need to provide a PostgreSQL connection URL{Colors.RESET}\n")
        
        try:
            subprocess.run([sys.executable, str(analyzer_script)], check=True)
        except subprocess.CalledProcessError as e:
            print(f"{Colors.RED}Error running database analyzer: {e}{Colors.RESET}")
            return False
        return True
    
    def run_turso_generator(self):
        turso_script = self.scripts_path / "generate-turso-db.py"
        if not turso_script.exists():
            print(f"{Colors.RED}Error: Turso generator not found at {turso_script}{Colors.RESET}")
            return False
        
        print(f"{Colors.CYAN}ðŸš€ Launching Turso Environment Generator...{Colors.RESET}")
        print(f"{Colors.DIM}Testing Turso CLI...{Colors.RESET}")
        
        success, message = self._test_connection('turso')
        if not success:
            print(f"{Colors.YELLOW}âš ï¸  {message}{Colors.RESET}")
            proceed = input(f"{Colors.BOLD}Continue anyway? (y/N): {Colors.RESET}").strip().lower()
            if proceed != 'y':
                return False
        else:
            print(f"{Colors.GREEN}âœ“ {message}{Colors.RESET}")
        
        try:
            subprocess.run([sys.executable, str(turso_script)], check=True)
        except subprocess.CalledProcessError as e:
            print(f"{Colors.RED}Error running Turso generator: {e}{Colors.RESET}")
            return False
        return True
    
    def run_docker_manager(self):
        docker_script = self.bin_path / "docker"
        if not docker_script.exists():
            print(f"{Colors.RED}Error: Docker manager not found at {docker_script}{Colors.RESET}")
            return False
        
        print(f"{Colors.CYAN}ðŸ³ Launching Docker Manager...{Colors.RESET}")
        try:
            subprocess.run([str(docker_script)], check=True)
        except subprocess.CalledProcessError as e:
            print(f"{Colors.RED}Error running Docker manager: {e}{Colors.RESET}")
            return False
        return True
    
    def handle_direct_command(self, command: str) -> bool:
        """Handle direct command execution"""
        command_map = {
            'postgres': self.run_postgres_manager,
            'pg': self.run_postgres_manager,
            'analyze': self.run_db_analyzer,
            'analyzer': self.run_db_analyzer,
            'turso': self.run_turso_generator,
            'docker': self.run_docker_manager,
            'help': self.show_help,
            '--help': self.show_help,
            '-h': self.show_help,
            'info': self.show_tools_info,
        }
        
        if command in command_map:
            if command in ['help', '--help', '-h', 'info']:
                command_map[command]()
                return True
            else:
                return command_map[command]()
        else:
            print(f"{Colors.RED}Error: Unknown command '{command}'{Colors.RESET}")
            print(f"{Colors.DIM}Available commands: {', '.join(command_map.keys())}{Colors.RESET}")
            return False
    
    def interactive_mode(self):
        """Run the interactive menu"""
        while True:
            print("\n" + "="*65)
            self.print_header()
            self.print_menu()
            
            try:
                choice = input(f"{Colors.BOLD}{Colors.CYAN}Select an option: {Colors.RESET}").strip().lower()
                
                if choice in ['q', 'quit', 'exit']:
                    print(f"\n{Colors.GREEN}ðŸ‘‹ Goodbye! Database operations completed.{Colors.RESET}")
                    break
                elif choice == '1':
                    self.run_postgres_manager()
                elif choice == '2':
                    self.run_db_analyzer()
                elif choice == '3':
                    self.run_turso_generator()
                elif choice == '4':
                    self.run_docker_manager()
                elif choice == '5':
                    self.show_tools_info()
                elif choice in ['h', 'help']:
                    self.show_help()
                else:
                    print(f"{Colors.RED}Invalid choice. Please try again.{Colors.RESET}")
                
                if choice.isdigit() and choice != '5':  # Don't pause for info display
                    input(f"\n{Colors.DIM}Press Enter to continue...{Colors.RESET}")
                    
            except KeyboardInterrupt:
                print(f"\n\n{Colors.YELLOW}ðŸ‘‹ Interrupted. Goodbye!{Colors.RESET}")
                break
            except EOFError:
                print(f"\n\n{Colors.YELLOW}ðŸ‘‹ EOF received. Goodbye!{Colors.RESET}")
                break

def main():
    """Main entry point"""
    manager = DatabaseManager()
    
    # Handle command line arguments
    if len(sys.argv) > 1:
        command = sys.argv[1].lower()
        success = manager.handle_direct_command(command)
        sys.exit(0 if success else 1)
    else:
        # Interactive mode
        manager.interactive_mode()

if __name__ == "__main__":
    main()