#!/usr/bin/env zsh

# Prompt Template Management Module
# Provides functions for managing and building AI script request prompts

# Constants
PROMPT_TEMPLATE_CONTENT='# Script Request Template

## Core Request
**Task:** {{REPLACE_ME_WITH_YOUR_REQUEST}}
**Command Name:** {{REPLACE_ME_WITH_COMMAND_NAME}}

## Behavior
### Basic Usage
- Typing `{{COMMAND_NAME}} {{BASIC_USAGE_EXAMPLE}}` runs:
  `{{RESULTING_COMMAND}}`

### With Arguments
- Adding `{{ARG_FLAG}}` does `{{ARG_BEHAVIOR}}`. Example:
  `{{COMMAND_NAME}} {{EXAMPLE_WITH_ARG}}`
  translates to:
  `{{RESULTING_COMMAND_WITH_ARG}}`

### Additional Examples
{{REPLACE_ME_WITH_MORE_EXAMPLES}}

## Parsing Rules
- {{REPLACE_ME_WITH_PARSING_RULE_1}}
- {{REPLACE_ME_WITH_PARSING_RULE_2}}
- Example:
  `{{COMMAND_NAME}} {{PARSING_EXAMPLE}}`
  translates to:
  `{{PARSED_RESULT}}`

## Edge Cases
- {{REPLACE_ME_WITH_EDGE_CASE_1}}
- {{REPLACE_ME_WITH_EDGE_CASE_2}}
- Example:
  `{{EDGE_CASE_EXAMPLE}}`

## Custom Arguments (Replace These)
{{REPLACE_ME_WITH_CUSTOM_ARGS}}

---

## Standard Arguments (Keep These)
- `-p` `--p` `--push` ‚Üí adds `; git push`
- `-S` `--s` `--sign` ‚Üí sign commit with GPG
- `-v` `--v` `--verbose` ‚Üí verbose output
- `-h` `--h` `--help` ‚Üí show helper menu

## Output Requirements
- {{REPLACE_ME_WITH_OUTPUT_REQUIREMENTS}}
- Success message: `{{SUCCESS_MESSAGE}}`
- Error handling: `{{ERROR_HANDLING}}`

## Helper Menu Requirements (Keep These)
- Create colorized helper menu using `~/.config/dotfiles` color helpers
- Trigger with: `{{COMMAND_NAME}} help`, `{{COMMAND_NAME}} --h`, `{{COMMAND_NAME}} --help`
- Integrate with dotfiles helper system:
  - Show in `dotfiles help` or `dotfiles` menu
  - Show in `dotfiles scripts help/--help/--h/?`
  - Show in `scripts help/--help/--h/?`

## File Structure Requirements (Keep These)
- **Location:** `~/.config/dotfiles/scripts/{{COMMAND_NAME}}` (no extension)
- **Shebang:** `#!/usr/bin/env zsh` (line 1)
- **Sourcer:** Create/update `~/.config/dotfiles/sourcers/script-sourcer`
- **Integration:** Add sourcer path to `~/.config/dotfiles/src`'

PROMPT_BACKUP_DIR="${HOME}/.config/prompts"
PROMPT_BACKUP_RETENTION=30  # days

# Initialize module
function prompt_template_init() {
    echo.debug "Initializing prompt-template module"
    
    # Ensure backup directory exists
    ensure_dir "$PROMPT_BACKUP_DIR"
    
    # Clean up old backups
    prompt_cleanup_backups
    
    # Make template file available if it doesn't exist
    local template_file="${DOTFILES_ROOT}/core/_internal-tools/templates/prompt-template"
    if [[ ! -f "$template_file" ]]; then
        ensure_dir "$(dirname "$template_file")"
        echo "$PROMPT_TEMPLATE_CONTENT" > "$template_file"
        echo.debug "Created prompt template file: $template_file"
    fi
}

# Help function
function prompt_template_help() {
    echo.header "üìù Prompt Template Manager"
    echo
    echo.cyan "Usage: prompt <command> [options]"
    echo
    echo.purple "üìã Available Commands:"
    printf "  %-15s %s\n" "$(echo.cyan '')" "Show the template using bat"
    printf "  %-15s %s\n" "$(echo.cyan 'copy|c')" "Copy template to clipboard"
    printf "  %-15s %s\n" "$(echo.cyan 'interactive|i')" "Interactive prompt builder"
    printf "  %-15s %s\n" "$(echo.cyan 'help|h')" "Show this help"
    echo
    echo.purple "üé® Copy Options:"
    printf "  %-15s %s\n" "$(echo.cyan '--copy|--c')" "Copy template to clipboard"
    echo
    echo.purple "üîß Interactive Options:"
    printf "  %-15s %s\n" "$(echo.cyan '--interactive|--i')" "Launch interactive builder"
    echo
    echo.purple "‚ú® Examples:"
    echo.success "  prompt              # Show template with syntax highlighting"
    echo.success "  prompt copy         # Copy template to clipboard"
    echo.success "  prompt i            # Interactive prompt builder"
    echo.success "  dotfiles prompt h   # Show help (also works with dotfiles prefix)"
    echo
    echo.info "üí° All commands work with 'dotfiles prompt' prefix as well"
    echo.info "üóÇÔ∏è  Backups are saved to: ${PROMPT_BACKUP_DIR}"
}

# Cross-platform clipboard function
function prompt_copy_to_clipboard() {
    local content="$1"
    
    # Try different clipboard commands in order of preference
    if command -v pbcopy >/dev/null 2>&1; then
        # macOS
        echo "$content" | pbcopy
        return $?
    elif command -v xclip >/dev/null 2>&1; then
        # Linux with X11
        echo "$content" | xclip -selection clipboard
        return $?
    elif command -v xsel >/dev/null 2>&1; then
        # Linux with X11 (alternative)
        echo "$content" | xsel --clipboard --input
        return $?
    elif command -v wl-copy >/dev/null 2>&1; then
        # Linux with Wayland
        echo "$content" | wl-copy
        return $?
    else
        echo.error "No clipboard utility found"
        echo.info "Please install one of: pbcopy, xclip, xsel, or wl-copy"
        return 1
    fi
}

# Show template function
function prompt_show_template() {
    echo.header "üìù Prompt Template"
    echo
    
    if command -v bat >/dev/null 2>&1; then
        echo "$PROMPT_TEMPLATE_CONTENT" | bat --style=numbers,grid --language=markdown
    else
        echo.warning "bat not found, using plain text display:"
        echo
        echo "$PROMPT_TEMPLATE_CONTENT"
    fi
}

# Copy template function
function prompt_copy_template() {
    if prompt_copy_to_clipboard "$PROMPT_TEMPLATE_CONTENT"; then
        echo.success "‚úÖ Template copied to clipboard!"
        echo.info "üìã Ready to paste with Ctrl+V"
    else
        echo.error "Failed to copy template to clipboard"
        echo.info "Alternative: Use 'prompt' to view and copy manually"
        return 1
    fi
}

# Cleanup old backups
function prompt_cleanup_backups() {
    if [[ ! -d "$PROMPT_BACKUP_DIR" ]]; then
        return 0
    fi
    
    echo.debug "Cleaning up backups older than $PROMPT_BACKUP_RETENTION days"
    
    find "$PROMPT_BACKUP_DIR" -name "prompt.*.backup.*.md" -type f -mtime +$PROMPT_BACKUP_RETENTION -delete 2>/dev/null
}

# Create backup
function prompt_create_backup() {
    local name="$1"
    local content="$2"
    local timestamp=$(date +"%Y%m%d_%H%M%S")
    local backup_file="$PROMPT_BACKUP_DIR/prompt.${name}.backup.${timestamp}.md"
    
    ensure_dir "$PROMPT_BACKUP_DIR"
    echo "$content" > "$backup_file"
    echo.debug "Backup saved: $backup_file"
}

# Interactive prompt builder
function prompt_interactive_builder() {
    echo.header "üé® Interactive Prompt Builder"
    echo.info "Build your custom prompt step by step"
    echo.warning "Use Ctrl+C to exit at any time"
    echo
    
    local template_content="$PROMPT_TEMPLATE_CONTENT"
    local current_content="$template_content"
    
    # Extract all template variables
    local variables=($(echo "$template_content" | grep -oE '\{\{[^}]+\}\}' | sort -u))
    
    if [[ ${#variables[@]} -eq 0 ]]; then
        echo.error "No template variables found in template"
        return 1
    fi
    
    echo.success "Found ${#variables[@]} template variables to configure"
    echo
    
    local var_index=1
    local user_values=()
    local var_names=()
    
    # Initialize arrays with variable names and empty values
    for var in "${variables[@]}"; do
        var_names+=("$var")
        user_values+=("")
    done
    
    function show_preview() {
        local preview_content="$current_content"
        for ((i=0; i<${#var_names[@]}; i++)); do
            local var_name="${var_names[i]}"
            local var_value="${user_values[i]:-$var_name}"
            preview_content="${preview_content//$var_name/$var_value}"
        done
        
        echo.header "üìñ Current Preview"
        if command -v bat >/dev/null 2>&1; then
            echo "$preview_content" | bat --style=grid --language=markdown
        else
            echo "$preview_content"
        fi
        echo
    }
    
    function process_variable() {
        local idx=$1
        local var_name="${var_names[idx]}"
        local clean_var=$(echo "$var_name" | sed 's/[{}]//g')
        
        clear
        echo.header "üé® Interactive Prompt Builder"
        echo.info "Variable $(($idx + 1)) of ${#var_names[@]}: $clean_var"
        echo
        echo.cyan "Current value: ${user_values[idx]:-'(empty)'}"
        echo
        
        # Show a mini preview of just this section
        echo.purple "Template context:"
        echo "$template_content" | grep -B2 -A2 "$var_name" | sed 's/^/  /'
        echo
        
        echo.yellow "Enter your value (or press Enter to keep current):"
        echo -n "$(echo.pastel_purple '‚ùØ') "
        
        local input
        read -r input
        
        if [[ -n "$input" ]]; then
            user_values[idx]="$input"
            # Update current content
            current_content="${current_content//$var_name/$input}"
        fi
    }
    
    # Main interactive loop
    local current_var=0
    while [[ $current_var -lt ${#var_names[@]} ]]; do
        process_variable $current_var
        
        # Create backup after each step
        local backup_name="interactive_step_$(($current_var + 1))"
        prompt_create_backup "$backup_name" "$current_content"
        
        echo
        echo.success "‚úÖ Variable configured! What's next?"
        echo
        echo.cyan "Options:"
        printf "  %-20s %s\n" "$(echo.pastel_green '[Enter]')" "Continue to next variable"
        printf "  %-20s %s\n" "$(echo.pastel_blue '[p]')" "Show full preview"
        printf "  %-20s %s\n" "$(echo.pastel_yellow '[b]')" "Go back to previous variable"
        printf "  %-20s %s\n" "$(echo.pastel_purple '[s]')" "Skip to end and save"
        printf "  %-20s %s\n" "$(echo.pastel_pink '[q]')" "Quit without saving"
        echo
        echo -n "$(echo.pastel_cyan '‚ùØ Choice: ')"
        
        local choice
        read -r choice
        
        case "$choice" in
            ""|"n"|"next")
                ((current_var++))
                ;;
            "p"|"preview")
                clear
                show_preview
                echo.info "Press Enter to continue..."
                read -r
                ;;
            "b"|"back"|"prev")
                if [[ $current_var -gt 0 ]]; then
                    ((current_var--))
                else
                    echo.warning "Already at first variable"
                    sleep 1
                fi
                ;;
            "s"|"save"|"skip")
                current_var=${#var_names[@]}  # Exit loop
                ;;
            "q"|"quit"|"exit")
                echo.warning "Quitting without saving..."
                return 0
                ;;
            *)
                echo.warning "Invalid choice, continuing to next variable..."
                ((current_var++))
                ;;
        esac
    done
    
    # Final step - show result and save options
    clear
    show_preview
    
    echo.header "üéâ Prompt Building Complete!"
    echo
    echo.success "Your custom prompt is ready! Choose what to do:"
    echo
    printf "  %-20s %s\n" "$(echo.pastel_green '[1]')" "Copy to clipboard and exit"
    printf "  %-20s %s\n" "$(echo.pastel_blue '[2]')" "Save as MDX file"
    printf "  %-20s %s\n" "$(echo.pastel_purple '[3]')" "Restart the builder"
    printf "  %-20s %s\n" "$(echo.pastel_yellow '[4]')" "Go back to edit variables"
    printf "  %-20s %s\n" "$(echo.pastel_pink '[q]')" "Quit without saving"
    echo
    echo -n "$(echo.pastel_cyan '‚ùØ Final choice: ')"
    
    local final_choice
    read -r final_choice
    
    case "$final_choice" in
        "1"|"copy"|"clipboard")
            if prompt_copy_to_clipboard "$current_content"; then
                echo.success "‚úÖ Custom prompt copied to clipboard!"
            else
                echo.error "Failed to copy. Here's your prompt:"
                echo "$current_content"
            fi
            
            # Save final backup
            prompt_create_backup "final" "$current_content"
            ;;
        "2"|"save"|"mdx")
            echo.cyan "Enter the path to save your MDX file:"
            echo -n "$(echo.pastel_purple '‚ùØ Path: ')"
            local save_path
            read -r save_path
            
            if [[ -n "$save_path" ]]; then
                echo "$current_content" > "$save_path"
                echo.success "‚úÖ Saved to: $save_path"
                
                # Also save backup
                prompt_create_backup "saved" "$current_content"
            else
                echo.error "No path provided"
            fi
            ;;
        "3"|"restart")
            echo.info "Restarting prompt builder..."
            prompt_interactive_builder
            return $?
            ;;
        "4"|"edit"|"back")
            echo.info "Going back to variable editing..."
            current_var=$((${#var_names[@]} - 1))
            # Continue the loop (this is a bit hacky but works)
            ;;
        *)
            echo.info "Thanks for using the prompt builder!"
            prompt_create_backup "final" "$current_content"
            ;;
    esac
    
    # Clean up old backups
    prompt_cleanup_backups
}

# Main prompt command dispatcher
function prompt_main() {
    case "${1:-}" in
        ""|show)
            prompt_show_template
            ;;
        copy|c|--copy|--c)
            prompt_copy_template
            ;;
        interactive|i|--interactive|--i)
            prompt_interactive_builder
            ;;
        help|h|--help|--h|-h)
            prompt_template_help
            ;;
        *)
            echo.error "Unknown command: $1"
            echo
            prompt_template_help
            return 1
            ;;
    esac
}

# Create global alias for easy access
alias prompt='prompt_main'

# Initialize the module
prompt_template_init
