#!/usr/bin/env zsh

# Multi-Template Prompt Management Module
# Provides functions for managing and building AI prompts with different templates

# Constants
TEMPLATE_DIR="${DOTFILES_ROOT}/modules/enabled/prompt-template/templates"
VARIABLES_JSON="${TEMPLATE_DIR}/variables.json"
PARTIALS_DIR="${TEMPLATE_DIR}/partials"

# Legacy template content for backward compatibility
PROMPT_TEMPLATE_CONTENT='# Script Request Template

## Core Request
**Task:** {{REPLACE_ME_WITH_YOUR_REQUEST}}
**Command Name:** {{REPLACE_ME_WITH_COMMAND_NAME}}

## Behavior
### Basic Usage
- Typing `{{COMMAND_NAME}} {{BASIC_USAGE_EXAMPLE}}` runs:
  `{{RESULTING_COMMAND}}`

### With Arguments
- Adding `{{ARG_FLAG}}` does `{{ARG_BEHAVIOR}}`. Example:
  `{{COMMAND_NAME}} {{EXAMPLE_WITH_ARG}}`
  translates to:
  `{{RESULTING_COMMAND_WITH_ARG}}`

### Additional Examples
{{REPLACE_ME_WITH_MORE_EXAMPLES}}

## Parsing Rules
- {{REPLACE_ME_WITH_PARSING_RULE_1}}
- {{REPLACE_ME_WITH_PARSING_RULE_2}}
- Example:
  `{{COMMAND_NAME}} {{PARSING_EXAMPLE}}`
  translates to:
  `{{PARSED_RESULT}}`

## Edge Cases
- {{REPLACE_ME_WITH_EDGE_CASE_1}}
- {{REPLACE_ME_WITH_EDGE_CASE_2}}
- Example:
  `{{EDGE_CASE_EXAMPLE}}`

## Custom Arguments (Replace These)
{{REPLACE_ME_WITH_CUSTOM_ARGS}}

---

## Standard Arguments (Keep These)
- `-p` `--p` `--push` â†’ adds `; git push`
- `-S` `--s` `--sign` â†’ sign commit with GPG
- `-v` `--v` `--verbose` â†’ verbose output
- `-h` `--h` `--help` â†’ show helper menu

## Output Requirements
- {{REPLACE_ME_WITH_OUTPUT_REQUIREMENTS}}
- Success message: `{{SUCCESS_MESSAGE}}`
- Error handling: `{{ERROR_HANDLING}}`

## Helper Menu Requirements (Keep These)
- Create colorized helper menu using `~/.config/dotfiles` color helpers
- Trigger with: `{{COMMAND_NAME}} help`, `{{COMMAND_NAME}} --h`, `{{COMMAND_NAME}} --help`
- Integrate with dotfiles helper system:
  - Show in `dotfiles help` or `dotfiles` menu
  - Show in `dotfiles scripts help/--help/--h/?`
  - Show in `scripts help/--help/--h/?`

## File Structure Requirements (Keep These)
- **Location:** `~/.config/dotfiles/scripts/{{COMMAND_NAME}}` (no extension)
- **Shebang:** `#!/usr/bin/env zsh` (line 1)
- **Sourcer:** Create/update `~/.config/dotfiles/sourcers/script-sourcer`
- **Integration:** Add sourcer path to `~/.config/dotfiles/src`'

PROMPT_BACKUP_DIR="${HOME}/.config/prompts"
PROMPT_BACKUP_RETENTION=30  # days

# Initialize module
function prompt_template_init() {
    echo.debug "Initializing prompt-template module"
    
    # Ensure backup directory exists
    ensure_dir "$PROMPT_BACKUP_DIR"
    
    # Clean up old backups
    prompt_cleanup_backups
    
    # Make template file available if it doesn't exist
    local template_file="${DOTFILES_ROOT}/core/_internal-tools/templates/prompt-template"
    if [[ ! -f "$template_file" ]]; then
        ensure_dir "$(dirname "$template_file")"
        echo "$PROMPT_TEMPLATE_CONTENT" > "$template_file"
        echo.debug "Created prompt template file: $template_file"
    fi
}

# Help function
function prompt_template_help() {
    echo.header "Prompt Template Manager"
    echo
    echo.cyan "Usage: prompt <command> [options]"
    echo
    echo.purple "Available Commands:"
    printf "  %-15s %s\n" "$(echo.cyan '')" "Show the template using bat"
    printf "  %-15s %s\n" "$(echo.cyan 'copy|c')" "Copy template to clipboard"
    printf "  %-15s %s\n" "$(echo.cyan 'interactive|i')" "Interactive prompt builder"
    printf "  %-15s %s\n" "$(echo.cyan 'help|h')" "Show this help"
    echo
    echo.purple "Copy Options:"
    printf "  %-15s %s\n" "$(echo.cyan '--copy|--c')" "Copy template to clipboard"
    echo
    echo.purple "Interactive Options:"
    printf "  %-15s %s\n" "$(echo.cyan '--interactive|--i')" "Launch interactive builder"
    echo
    echo.purple "Examples:"
    echo.success "  prompt              # Show template with syntax highlighting"
    echo.success "  prompt copy         # Copy template to clipboard"
    echo.success "  prompt i            # Interactive prompt builder"
    echo.success "  dotfiles prompt h   # Show help (also works with dotfiles prefix)"
    echo
    echo.info "All commands work with 'dotfiles prompt' prefix as well"
    echo.info "Backups are saved to: ${PROMPT_BACKUP_DIR}"
}

# Cross-platform clipboard function
function prompt_copy_to_clipboard() {
    local content="$1"
    
    # Try different clipboard commands in order of preference
    if command -v pbcopy >/dev/null 2>&1; then
        # macOS
        echo "$content" | pbcopy
        return $?
    elif command -v xclip >/dev/null 2>&1; then
        # Linux with X11
        echo "$content" | xclip -selection clipboard
        return $?
    elif command -v xsel >/dev/null 2>&1; then
        # Linux with X11 (alternative)
        echo "$content" | xsel --clipboard --input
        return $?
    elif command -v wl-copy >/dev/null 2>&1; then
        # Linux with Wayland
        echo "$content" | wl-copy
        return $?
    else
        echo.error "No clipboard utility found"
        echo.info "Please install one of: pbcopy, xclip, xsel, or wl-copy"
        return 1
    fi
}

# Show template function
function prompt_show_template() {
    echo.header "Prompt Template"
    echo
    
    if command -v bat >/dev/null 2>&1; then
        echo "$PROMPT_TEMPLATE_CONTENT" | bat --style=numbers,grid --language=markdown
    else
        echo.warning "bat not found, using plain text display:"
        echo
        echo "$PROMPT_TEMPLATE_CONTENT"
    fi
}

# Copy template function
function prompt_copy_template() {
    if prompt_copy_to_clipboard "$PROMPT_TEMPLATE_CONTENT"; then
        echo.success "Template copied to clipboard"
        echo.info "Ready to paste with Ctrl+V"
    else
        echo.error "Failed to copy template to clipboard"
        echo.info "Alternative: Use 'prompt' to view and copy manually"
        return 1
    fi
}

# Cleanup old backups
function prompt_cleanup_backups() {
    if [[ ! -d "$PROMPT_BACKUP_DIR" ]]; then
        return 0
    fi
    
    echo.debug "Cleaning up backups older than $PROMPT_BACKUP_RETENTION days"
    
    find "$PROMPT_BACKUP_DIR" -name "prompt.*.backup.*.md" -type f -mtime +$PROMPT_BACKUP_RETENTION -delete 2>/dev/null
}

# Create backup
function prompt_create_backup() {
    local name="$1"
    local content="$2"
    local timestamp=$(date +"%Y%m%d_%H%M%S")
    local backup_file="$PROMPT_BACKUP_DIR/prompt.${name}.backup.${timestamp}.md"
    
    ensure_dir "$PROMPT_BACKUP_DIR"
    echo "$content" > "$backup_file"
    echo.debug "Backup saved: $backup_file"
}
# Terminal layout management functions
function get_terminal_dimensions() {
    local cols=${COLUMNS:-$(tput cols 2>/dev/null || echo 80)}
    local lines=${LINES:-$(tput lines 2>/dev/null || echo 24)}
    echo "$cols $lines"
}

function setup_split_layout() {
    local dimension_output=$(get_terminal_dimensions)
    local total_cols=$(echo "$dimension_output" | cut -d' ' -f1)
    local total_lines=$(echo "$dimension_output" | cut -d' ' -f2)
    
    # Calculate split: 60% left panel, 40% right panel (minimum 50 cols for left)
    local left_cols=$(( total_cols * 60 / 100 ))
    if [[ $left_cols -lt 50 ]]; then
        left_cols=50
    fi
    local right_cols=$(( total_cols - left_cols - 1 ))  # -1 for divider
    
    # Ensure right panel has minimum space
    if [[ $right_cols -lt 30 ]]; then
        left_cols=$(( total_cols - 31 ))  # Leave 31 for right panel + divider
        right_cols=30
    fi
    
    # Store in global variables
    LAYOUT_TOTAL_COLS=$total_cols
    LAYOUT_TOTAL_LINES=$total_lines
    LAYOUT_LEFT_COLS=$left_cols
    LAYOUT_RIGHT_COLS=$right_cols
    LAYOUT_DIVIDER_COL=$((left_cols + 1))
}

# ANSI cursor control functions
function cursor_to() {
    printf "\033[%d;%dH" "$1" "$2"
}

function save_cursor() {
    printf "\033[s"
}

function restore_cursor() {
    printf "\033[u"
}

function clear_screen() {
    printf "\033[2J\033[H"
}

function clear_from_cursor() {
    printf "\033[J"
}

function clear_line() {
    printf "\033[2K"
}

# Sidebar rendering functions
function render_sidebar() {
    local current_var_idx="$1"
    shift
    local -A values=("${(@kv)@}")
    
    local line=1
    
    # Header
    cursor_to $line $LAYOUT_DIVIDER_COL
    printf "â”‚"
    cursor_to $line $((LAYOUT_DIVIDER_COL + 2))
    echo.cyan "Live Preview"
    ((line++))
    
    # Progress indicator
    cursor_to $line $LAYOUT_DIVIDER_COL
    printf "â”‚"
    cursor_to $line $((LAYOUT_DIVIDER_COL + 2))
    local completed=$(echo "${values[@]}" | grep -o '[^[:space:]]' | wc -l)
    echo.info "Progress: $completed/${#var_names[@]} variables"
    ((line++))
    
    # Separator
    cursor_to $line $LAYOUT_DIVIDER_COL
    printf "â”‚"
    cursor_to $line $((LAYOUT_DIVIDER_COL + 2))
    printf 'â”€%.0s' $(seq 1 $((LAYOUT_RIGHT_COLS - 2)))
    ((line++))
    
    # Render current content with highlighting
    local preview_content="$current_content"
    for var_name in "${var_names[@]}"; do
        local var_value="${values[$var_name]:-$var_name}"
        if [[ -n "${values[$var_name]}" ]]; then
            # Variable filled - use green
            var_value="$(echo.success "$var_value")"
        elif [[ $var_name == "${var_names[$current_var_idx]}" ]]; then
            # Current variable - use yellow
            var_value="$(echo.warning "$var_name")"
        else
            # Unfilled variable - use dim
            var_value="\033[2m$var_name\033[0m"
        fi
        preview_content="${preview_content//$var_name/$var_value}"
    done
    
    # Split preview into lines and render each in sidebar
    local preview_lines=(${(f)preview_content})
    local max_sidebar_lines=$((LAYOUT_TOTAL_LINES - 5))
    local lines_shown=0
    
    for preview_line in "${preview_lines[@]}"; do
        if [[ $lines_shown -ge $max_sidebar_lines ]]; then
            break
        fi
        
        cursor_to $line $LAYOUT_DIVIDER_COL
        printf "â”‚"
        cursor_to $line $((LAYOUT_DIVIDER_COL + 2))
        
        # Truncate line if too long for sidebar
        local display_line="$preview_line"
        if [[ ${#display_line} -gt $((LAYOUT_RIGHT_COLS - 4)) ]]; then
            display_line="${display_line:0:$((LAYOUT_RIGHT_COLS - 7))}..."
        fi
        
        printf "%s" "$display_line"
        
        ((line++))
        ((lines_shown++))
    done
    
    # Fill remaining sidebar lines
    while [[ $line -le $LAYOUT_TOTAL_LINES ]]; do
        cursor_to $line $LAYOUT_DIVIDER_COL
        printf "â”‚"
        ((line++))
    done
}

function render_divider() {
    local line=1
    while [[ $line -le $LAYOUT_TOTAL_LINES ]]; do
        cursor_to $line $LAYOUT_DIVIDER_COL
        printf "â”‚"
        ((line++))
    done
}

# Interactive prompt builder with sidebar
function prompt_interactive_builder() {
    # Setup terminal
    setup_split_layout
    
    # Check if terminal is wide enough
    if [[ $LAYOUT_TOTAL_COLS -lt 100 ]]; then
        echo.warning "Terminal too narrow for split view (need 100+ columns, have $LAYOUT_TOTAL_COLS)"
        echo.info "Falling back to original interactive mode..."
        prompt_interactive_builder_simple
        return $?
    fi
    
    clear_screen
    
    # Initialize content
    local template_content="$PROMPT_TEMPLATE_CONTENT"
    local current_content="$template_content"
    
    # Extract all template variables
    local variables=($(echo "$template_content" | grep -oE '\{\{[^}]+\}\}' | sort -u))
    
    if [[ ${#variables[@]} -eq 0 ]]; then
        echo.error "No template variables found in template"
        return 1
    fi
    
    # Initialize associative array for values
    typeset -A user_values
    local var_names=("${variables[@]}")
    
    # Initialize all values as empty
    for var in "${variables[@]}"; do
        user_values["$var"]=""
    done
    
    function show_full_template() {
        clear_screen
        echo.header "ðŸ“„ Full Template View"
        echo.info "Press any key to return to interactive mode"
        echo
        
        if command -v bat >/dev/null 2>&1; then
            echo "$template_content" | bat --style=grid --language=markdown
        else
            echo "$template_content"
        fi
        echo
        echo.warning "Press any key to continue..."
        read -k1
        
        # Restore split screen
        clear_screen
        render_divider
    }
    
    function process_variable() {
        local idx=$1
        local var_name="${var_names[$idx]}"
        local clean_var=$(echo "$var_name" | sed 's/[{}]//g')
        
        # Clear left panel only
        local line=1
        while [[ $line -le $LAYOUT_TOTAL_LINES ]]; do
            cursor_to $line 1
            printf '%.0s' $(seq 1 $LAYOUT_LEFT_COLS)
            ((line++))
        done
        
        # Render left panel content
        cursor_to 1 1
        echo.header "ðŸŽ¨ Interactive Prompt Builder"
        echo.info "Variable $idx of ${#var_names[@]}: $(echo.cyan $clean_var)"
        echo
        echo.cyan "Current value: ${user_values[$var_name]:-'(empty)'}"
        echo
        
        # Show template context
        echo.purple "Template context:"
        echo "$template_content" | grep -B2 -A2 "$var_name" | sed 's/^/  /' | head -5
        echo
        
        # Show keyboard shortcuts
        echo.info "Shortcuts: [Tab] Full template, [Ctrl+C] Exit"
        echo
        
        # Update sidebar with current state
        render_sidebar $(($idx - 1)) "${(@kv)user_values}"
        
        # Input prompt
        cursor_to 15 1
        echo.warning "Enter your value (or press Enter to keep current):"
        echo -n "$(echo.purple 'â¯') "
        
        local input
        read -r input
        
        if [[ -n "$input" ]]; then
            user_values["$var_name"]="$input"
            # Update current content
            current_content="${current_content//$var_name/$input}"
        fi
    }
    
    # Initial render
    render_divider
    render_sidebar 0 "${(@kv)user_values}"
    
    # Main interactive loop
    local current_var=1
    while [[ $current_var -le ${#var_names[@]} ]]; do
        process_variable $current_var
        
        # Create backup after each step
        local backup_name="interactive_step_$current_var"
        prompt_create_backup "$backup_name" "$current_content"
        
        # Navigation menu in left panel
        cursor_to 18 1
        echo.success "âœ… Variable configured! What's next?"
        echo
        echo.cyan "Options:"
        printf "  %-20s %s\n" "$(echo.cyan '[Enter]')" "Continue to next variable"
        printf "  %-20s %s\n" "$(echo.cyan '[t]')" "Show full template"
        printf "  %-20s %s\n" "$(echo.cyan '[b]')" "Go back to previous variable"
        printf "  %-20s %s\n" "$(echo.cyan '[s]')" "Skip to end and save"
        printf "  %-20s %s\n" "$(echo.cyan '[q]')" "Quit without saving"
        echo
        echo -n "$(echo.cyan 'â¯ Choice: ')"
        
        local choice
        read -r choice
        
        case "$choice" in
            ""|"n"|"next")
                ((current_var++))
                ;;
            "t"|"template")
                show_full_template
                ;;
            "b"|"back"|"prev")
                if [[ $current_var -gt 1 ]]; then
                    ((current_var--))
                else
                    cursor_to 28 1
                    echo.warning "Already at first variable"
                    sleep 1
                fi
                ;;
            "s"|"save"|"skip")
                current_var=$((${#var_names[@]} + 1))  # Exit loop
                ;;
            "q"|"quit"|"exit")
                clear_screen
                echo.warning "Quitting without saving..."
                return 0
                ;;
            *)
                cursor_to 28 1
                echo.warning "Invalid choice, continuing to next variable..."
                sleep 1
                ((current_var++))
                ;;
        esac
    done
    
    # Final step - show result and save options
    clear_screen
    
    # Show final preview full screen
    local preview_content="$current_content"
    for var_name in "${var_names[@]}"; do
        local var_value="${user_values[$var_name]:-$var_name}"
        preview_content="${preview_content//$var_name/$var_value}"
    done
    
    echo.header "ðŸ“– Final Preview"
    if command -v bat >/dev/null 2>&1; then
        echo "$preview_content" | bat --style=grid --language=markdown
    else
        echo "$preview_content"
    fi
    echo
    
    echo.header "Prompt Building Complete"
    echo
    echo.success "Your custom prompt is ready. Choose what to do:"
    echo
    printf "  %-20s %s\n" "$(echo.cyan '[1]')" "Copy to clipboard and exit"
    printf "  %-20s %s\n" "$(echo.cyan '[2]')" "Save as MDX file"
    printf "  %-20s %s\n" "$(echo.cyan '[3]')" "Restart the builder"
    printf "  %-20s %s\n" "$(echo.cyan '[4]')" "Go back to edit variables"
    printf "  %-20s %s\n" "$(echo.cyan '[q]')" "Quit without saving"
    echo
    echo -n "$(echo.cyan '> Final choice: ')"
    
    local final_choice
    read -r final_choice
    
    case "$final_choice" in
        "1"|"copy"|"clipboard")
            if prompt_copy_to_clipboard "$current_content"; then
                echo.success "Custom prompt copied to clipboard"
            else
                echo.error "Failed to copy. Here's your prompt:"
                echo "$current_content"
            fi
            
            # Save final backup
            prompt_create_backup "final" "$current_content"
            ;;
        "2"|"save"|"mdx")
            echo.cyan "Enter the path to save your MDX file:"
            echo -n "$(echo.purple '> Path: ')"
            local save_path
            read -r save_path
            
            if [[ -n "$save_path" ]]; then
                echo "$current_content" > "$save_path"
                echo.success "Saved to: $save_path"
                
                # Also save backup
                prompt_create_backup "saved" "$current_content"
            else
                echo.error "No path provided"
            fi
            ;;
        "3"|"restart")
            echo.info "Restarting prompt builder..."
            prompt_interactive_builder
            return $?
            ;;
        "4"|"edit"|"back")
            echo.info "Going back to variable editing..."
            current_var=$((${#var_names[@]} - 1))
            # Continue the loop (this is a bit hacky but works)
            ;;
        *)
            echo.info "Thanks for using the prompt builder!"
            prompt_create_backup "final" "$current_content"
            ;;
    esac
    
    # Clean up old backups
    prompt_cleanup_backups
}

# Main prompt command dispatcher
function prompt_main() {
    case "${1:-}" in
        ""|show)
            prompt_show_template
            ;;
        copy|c|--copy|--c)
            prompt_copy_template
            ;;
        interactive|i|--interactive|--i)
            prompt_interactive_builder
            ;;
        help|h|--help|--h|-h)
            prompt_template_help
            ;;
        *)
            echo.error "Unknown command: $1"
            echo
            prompt_template_help
            return 1
            ;;
    esac
}

# Create global alias for easy access
alias prompt='prompt_main'

# Fallback simple interactive builder for narrow terminals
function prompt_interactive_builder_simple() {
    echo.header "ðŸŽ¨ Interactive Prompt Builder (Simple Mode)"
    echo.info "Build your custom prompt step by step"
    echo.warning "Use Ctrl+C to exit at any time"
    echo
    
    local template_content="$PROMPT_TEMPLATE_CONTENT"
    local current_content="$template_content"
    
    # Extract all template variables
    local variables=($(echo "$template_content" | grep -oE '\{\{[^}]+\}\}' | sort -u))
    
    if [[ ${#variables[@]} -eq 0 ]]; then
        echo.error "No template variables found in template"
        return 1
    fi
    
    echo.success "Found ${#variables[@]} template variables to configure"
    echo
    
    # Initialize associative arrays for better handling
    typeset -A user_values
    local var_names=("${variables[@]}")
    
    # Initialize all values as empty
    for var in "${variables[@]}"; do
        user_values["$var"]=""
    done
    
    function show_preview_simple() {
        local preview_content="$current_content"
        for var_name in "${var_names[@]}"; do
            local var_value="${user_values[$var_name]:-$var_name}"
            preview_content="${preview_content//$var_name/$var_value}"
        done
        
        echo.header "ðŸ“– Current Preview"
        if command -v bat >/dev/null 2>&1; then
            echo "$preview_content" | bat --style=grid --language=markdown
        else
            echo "$preview_content"
        fi
        echo
    }
    
    function process_variable_simple() {
        local idx=$1
        local var_name="${var_names[$idx]}"
        local clean_var=$(echo "$var_name" | sed 's/[{}]//g')
        
        clear
        # Add padding from top
        printf '\n%.0s' {1..5}
        echo.header "ðŸŽ¨ Interactive Prompt Builder"
        echo.info "Variable $idx of ${#var_names[@]}: $clean_var"
        echo
        echo.cyan "Current value: ${user_values[$var_name]:-'(empty)'}"
        echo
        
        # Show a mini preview of just this section
        echo.purple "Template context:"
        echo "$template_content" | grep -B2 -A2 "$var_name" | sed 's/^/  /'
        echo
        
        echo.warning "Enter your value (or press Enter to keep current):"
        echo -n "$(echo.purple 'â¯') "
        
        local input
        read -r input
        
        if [[ -n "$input" ]]; then
            user_values["$var_name"]="$input"
            # Update current content
            current_content="${current_content//$var_name/$input}"
        fi
    }
    
    # Main interactive loop (simple mode - same as original)
    local current_var=1
    while [[ $current_var -le ${#var_names[@]} ]]; do
        process_variable_simple $current_var
        
        # Create backup after each step
        local backup_name="interactive_step_$current_var"
        prompt_create_backup "$backup_name" "$current_content"
        
        echo
        echo.success "âœ… Variable configured! What's next?"
        echo
        echo.cyan "Options:"
        printf "  %-20s %s\n" "$(echo.cyan '[Enter]')" "Continue to next variable"
        printf "  %-20s %s\n" "$(echo.cyan '[p]')" "Show full preview"
        printf "  %-20s %s\n" "$(echo.cyan '[b]')" "Go back to previous variable"
        printf "  %-20s %s\n" "$(echo.cyan '[s]')" "Skip to end and save"
        printf "  %-20s %s\n" "$(echo.cyan '[q]')" "Quit without saving"
        echo
        echo -n "$(echo.cyan 'â¯ Choice: ')"
        
        local choice
        read -r choice
        
        case "$choice" in
            ""|"n"|"next")
                ((current_var++))
                ;;
            "p"|"preview")
                clear
                # Add padding from top
                printf '\n%.0s' {1..3}
                show_preview_simple
                echo.info "Press Enter to continue..."
                read -r
                ;;
            "b"|"back"|"prev")
                if [[ $current_var -gt 1 ]]; then
                    ((current_var--))
                else
                    echo.warning "Already at first variable"
                    sleep 1
                fi
                ;;
            "s"|"save"|"skip")
                current_var=$((${#var_names[@]} + 1))  # Exit loop
                ;;
            "q"|"quit"|"exit")
                echo.warning "Quitting without saving..."
                return 0
                ;;
            *)
                echo.warning "Invalid choice, continuing to next variable..."
                ((current_var++))
                ;;
        esac
    done
    
    # Final step - show result and save options
    clear
    # Add padding from top
    printf '\n%.0s' {1..3}
    show_preview_simple
    
    echo.header "ðŸŽ‰ Prompt Building Complete!"
    echo
    echo.success "Your custom prompt is ready! Choose what to do:"
    echo
    printf "  %-20s %s\n" "$(echo.cyan '[1]')" "Copy to clipboard and exit"
    printf "  %-20s %s\n" "$(echo.cyan '[2]')" "Save as MDX file"
    printf "  %-20s %s\n" "$(echo.cyan '[3]')" "Restart the builder"
    printf "  %-20s %s\n" "$(echo.cyan '[4]')" "Go back to edit variables"
    printf "  %-20s %s\n" "$(echo.cyan '[q]')" "Quit without saving"
    echo
    echo -n "$(echo.cyan 'â¯ Final choice: ')"
    
    local final_choice
    read -r final_choice
    
    case "$final_choice" in
        "1"|"copy"|"clipboard")
            if prompt_copy_to_clipboard "$current_content"; then
                echo.success "âœ… Custom prompt copied to clipboard!"
            else
                echo.error "Failed to copy. Here's your prompt:"
                echo "$current_content"
            fi
            
            # Save final backup
            prompt_create_backup "final" "$current_content"
            ;;
        "2"|"save"|"mdx")
            echo.cyan "Enter the path to save your MDX file:"
            echo -n "$(echo.purple 'â¯ Path: ')"
            local save_path
            read -r save_path
            
            if [[ -n "$save_path" ]]; then
                echo "$current_content" > "$save_path"
                echo.success "âœ… Saved to: $save_path"
                
                # Also save backup
                prompt_create_backup "saved" "$current_content"
            else
                echo.error "No path provided"
            fi
            ;;
        "3"|"restart")
            echo.info "Restarting prompt builder..."
            prompt_interactive_builder_simple
            return $?
            ;;
        "4"|"edit"|"back")
            echo.info "Going back to variable editing..."
            current_var=$((${#var_names[@]} - 1))
            ;;
        *)
            echo.info "Thanks for using the prompt builder!"
            prompt_create_backup "final" "$current_content"
            ;;
    esac
    
    # Clean up old backups
    prompt_cleanup_backups
}

# Multi-template functions
function prompt_template_list() {
    echo.header "Available Templates"
    echo
    
    if [[ ! -f "$VARIABLES_JSON" ]]; then
        echo.error "Templates not found. Run 'dotfiles doctor' to check installation."
        return 1
    fi
    
    if command -v jq >/dev/null 2>&1; then
        jq -r '.templates[] | "\(.id)\t\(.name)\t\(.description)"' "$VARIABLES_JSON" 2>/dev/null | while IFS=$'\t' read -r id name description; do
            printf "  %-20s %s\n" "$(echo.cyan $id)" "$name"
            printf "  %-20s %s\n" "" "$description"
            echo
        done
    else
        echo.warning "jq not found, showing basic list:"
        echo.cyan "Available templates:"
        echo "  react_component    - React/Next.js Component Creation"
        echo "  api_backend        - API/Backend Feature"
        echo "  bug_fix            - Bug Fix Request"
        echo "  refactor           - Code Refactoring"
        echo "  feature            - General Feature Request"
    fi
}

function prompt_template_select() {
    if [[ ! -f "$VARIABLES_JSON" ]]; then
        echo.error "Templates not found. Using legacy template."
        prompt_interactive_builder_simple
        return $?
    fi
    
    # Try fzf first for better UX
    if command -v fzf >/dev/null 2>&1 && command -v jq >/dev/null 2>&1; then
        echo.info "Choose a template (fzf interactive selector):"
        
        local selected_id=$(jq -r '.templates[] | "\(.id)\t\(.name)"' "$VARIABLES_JSON" 2>/dev/null | \
            fzf --prompt="Choose template: " \
                --with-nth=2 \
                --delimiter='\t' \
                --height=10 | cut -f1)
        
        if [[ -n "$selected_id" ]]; then
            echo.success "Selected template: $selected_id"
            prompt_template_build "$selected_id"
        else
            echo.warning "No template selected"
        fi
    else
        # Fallback to simple selection
        prompt_template_list
        echo
        echo.cyan "Enter template ID (or press Enter for legacy template):"
        echo -n "$(echo.purple 'â¯ Template: ')"
        
        local template_id
        read -r template_id
        
        if [[ -z "$template_id" ]]; then
            echo.info "Using legacy template..."
            prompt_interactive_builder_simple
        else
            prompt_template_build "$template_id"
        fi
    fi
}

function prompt_template_build() {
    local template_id="$1"
    
    if [[ ! -f "$VARIABLES_JSON" ]]; then
        echo.error "Templates not found"
        return 1
    fi
    
    # Get template file path
    local template_file
    if command -v jq >/dev/null 2>&1; then
        template_file=$(jq -r ".templates[] | select(.id==\"$template_id\") | .file" "$VARIABLES_JSON" 2>/dev/null)
    else
        # Fallback without jq
        case "$template_id" in
            react_component) template_file="$TEMPLATE_DIR/react_component.prompt" ;;
            api_backend) template_file="$TEMPLATE_DIR/api_backend.prompt" ;;
            bug_fix) template_file="$TEMPLATE_DIR/bug_fix.prompt" ;;
            refactor) template_file="$TEMPLATE_DIR/refactor.prompt" ;;
            feature) template_file="$TEMPLATE_DIR/feature.prompt" ;;
            *) echo.error "Unknown template: $template_id"; return 1 ;;
        esac
    fi
    
    if [[ ! -f "$template_file" ]]; then
        echo.error "Template file not found: $template_file"
        return 1
    fi
    
    # Load template content
    local template_content=$(<"$template_file")
    
    # Load partials into variables
    local project_rules_content=""
    local project_rules_file="$PARTIALS_DIR/common_rules.partial"
    if [[ -f "$project_rules_file" ]]; then
        project_rules_content=$(<"$project_rules_file")
    fi
    
    # Replace PROJECT_RULES partial
    template_content="${template_content//\{\{PROJECT_RULES\}\}/$project_rules_content}"
    
    echo.header "Building Template: $template_id"
    echo.info "Template loaded successfully"
    echo
    
    # For now, use a simplified variable collection
    prompt_template_collect_vars_simple "$template_content" "$template_id"
}

function prompt_template_collect_vars_simple() {
    local template_content="$1"
    local template_id="$2"
    
    # Extract template variables
    local variables=($(echo "$template_content" | grep -oE '\{\{[^}]+\}\}' | sort -u))
    
    if [[ ${#variables[@]} -eq 0 ]]; then
        echo.warning "No variables found in template"
        if prompt_copy_to_clipboard "$template_content"; then
            echo.success "Template copied to clipboard"
        fi
        return 0
    fi
    
    echo.success "Found ${#variables[@]} variables to configure"
    echo
    
    # Initialize values
    typeset -A user_values
    for var in "${variables[@]}"; do
        user_values["$var"]=""
    done
    
    # Collect values
    local current_content="$template_content"
    for var_name in "${variables[@]}"; do
        local clean_var=$(echo "$var_name" | sed 's/[{}]//g')
        
        echo.cyan "Variable: $clean_var"
        echo.info "Current value: ${user_values[$var_name]:-'(empty)'}"
        echo -n "$(echo.purple 'â¯ Enter value: ')"
        
        local input
        read -r input
        
        if [[ -n "$input" ]]; then
            user_values["$var_name"]="$input"
            current_content="${current_content//$var_name/$input}"
        fi
        echo
    done
    
    # Show final result and options
    echo.header "Template Complete"
    echo
    if command -v bat >/dev/null 2>&1; then
        echo "$current_content" | bat --style=grid --language=markdown
    else
        echo "$current_content"
    fi
    echo
    
    echo.cyan "What would you like to do?"
    printf "  %-20s %s\n" "$(echo.cyan '[1]')" "Copy to clipboard"
    printf "  %-20s %s\n" "$(echo.cyan '[2]')" "Save to file"
    printf "  %-20s %s\n" "$(echo.cyan '[3]')" "Show again"
    printf "  %-20s %s\n" "$(echo.cyan '[q]')" "Quit"
    echo
    echo -n "$(echo.purple 'â¯ Choice: ')"
    
    local choice
    read -r choice
    
    case "$choice" in
        "1"|"copy")
            if prompt_copy_to_clipboard "$current_content"; then
                echo.success "Template copied to clipboard!"
            fi
            ;;
        "2"|"save")
            echo -n "$(echo.cyan 'â¯ Save path: ')"
            local save_path
            read -r save_path
            if [[ -n "$save_path" ]]; then
                echo "$current_content" > "$save_path"
                echo.success "Saved to: $save_path"
            fi
            ;;
        "3"|"show")
            prompt_template_collect_vars_simple "$template_content" "$template_id"
            return $?
            ;;
        *)
            echo.info "Done!"
            ;;
    esac
    
    # Save backup
    prompt_create_backup "${template_id}_$(date +%s)" "$current_content"
}

# Enhanced main dispatcher
function prompt_main() {
    case "${1:-}" in
        ""|show)
            # Check if new templates exist, otherwise use legacy
            if [[ -f "$VARIABLES_JSON" ]]; then
                prompt_template_select
            else
                prompt_show_template
            fi
            ;;
        list|l|--list)
            prompt_template_list
            ;;
        template|t|--template)
            if [[ -n "$2" ]]; then
                prompt_template_build "$2"
            else
                prompt_template_select
            fi
            ;;
        copy|c|--copy|--c)
            prompt_copy_template
            ;;
        interactive|i|--interactive|--i)
            # Use legacy interactive builder for now
            prompt_interactive_builder
            ;;
        help|h|--help|--h|-h)
            prompt_template_help
            ;;
        *)
            echo.error "Unknown command: $1"
            echo
            prompt_template_help
            return 1
            ;;
    esac
}

# Initialize the module
prompt_template_init
