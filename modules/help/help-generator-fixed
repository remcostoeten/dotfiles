#!/usr/bin/env bash

# Fixed Simple Help Manifest Generator
# Works without complex dependencies
# Part of the dotfiles management system

set -euo pipefail

# --- Setup ---
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
DOTFILES_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"
DOTFILES_UTILS="$DOTFILES_ROOT/utils"
DOTFILES_HELP_MANIFEST="$DOTFILES_UTILS/help_manifest.json"

# Ensure directories exist
mkdir -p "$DOTFILES_UTILS" "${DOTFILES_ROOT}/helpers/help" "${DOTFILES_ROOT}/docs/help" 2>/dev/null || true

# Simple color functions
function echo.error() { echo -e "\\033[0;31m✗\\033[0m $*"; }
function echo.success() { echo -e "\\033[0;32m✓\\033[0m $*"; }
function echo.warning() { echo -e "\\033[1;33m⚠\\033[0m $*"; }
function echo.info() { echo -e "\\033[0;36mℹ\\033[0m $*"; }
function echo.header() {
    echo -e "\\n\\033[1;34m════════════════════════════════════════════════════════════\\033[0m"
    echo -e "\\033[1;34m                    $*\\033[0m"
    echo -e "\\033[1;34m════════════════════════════════════════════════════════════\\033[0m\\n"
}

# --- State Variables ---
declare -a JSON_ENTRIES=()

# --- Utility Functions ---
function json_escape() {
    local input="$1"
    # Simple JSON escaping - replace problematic characters
    input="${input//\\\\/\\\\\\\\}"  # Escape backslashes
    input="${input//\"/\\\\\"}"      # Escape quotes
    input="${input//$/\\\\$}"       # Escape dollar signs
    input="${input//\`/\\\\\`}"      # Escape backticks
    echo "$input"
}

# --- Discovery Functions ---

function discover_aliases() {
    echo.info "🔍 Discovering aliases..."
    
    local alias_count=0
    local aliases_dir="$DOTFILES_ROOT/modules/aliases"
    
    [[ ! -d "$aliases_dir" ]] && return 0
    
    # Temporarily disable set -e for error handling
    set +e
    
    # Find all .aliases files
    for alias_file in "$aliases_dir"/*.aliases; do
        [[ ! -f "$alias_file" ]] && continue
        
        local file_base=$(basename "$alias_file" .aliases)
        echo "  Processing: $(basename "$alias_file")"
        
        # Parse aliases - look for standard alias format  
        while IFS= read -r line || [[ -n "$line" ]]; do
            # Skip empty lines and comments
            [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
            
            # Match: alias name='command'
            if [[ "$line" =~ ^[[:space:]]*alias[[:space:]]+([^=]+)=(.+) ]]; then
                local alias_name="${BASH_REMATCH[1]// /}"
                local alias_command="${BASH_REMATCH[2]}"
                
                # Clean up command (remove outer quotes)
                if [[ "$alias_command" =~ ^[\'\"](.*)[\'\"]+$ ]]; then
                    alias_command="${BASH_REMATCH[1]}"
                fi
                
                # Skip if it looks like a function call or complex command
                [[ "$alias_command" =~ \$|\`|\( ]] && continue
                
                # Create JSON entry
                local id="alias-$alias_name"
                local title=$(json_escape "$alias_name")
                local synopsis="Alias for: $(json_escape "$alias_command")"
                local source_path=$(json_escape "$alias_file")
                
                # Use here-string instead of here-doc to avoid command substitution issues
                local json_entry="{
  \"id\": \"$id\",
  \"title\": \"$title\",
  \"category\": \"aliases\",
  \"tags\": [\"alias\", \"$file_base\"],
  \"synopsis\": \"$synopsis\",
  \"usage\": \"$alias_name\",
  \"examples\": [
    {
      \"description\": \"Use the alias\",
      \"command\": \"$alias_name\"
    }
  ],
  \"sourcePath\": \"$source_path\",
  \"autogenerated\": true,
  \"lastModified\": \"$(date -Iseconds)\",
  \"icon\": \"⚡\",
  \"priority\": 80
}"
                
                JSON_ENTRIES+=("$json_entry")
                ((alias_count++))
            fi
        done < "$alias_file" 2>/dev/null || {
            echo "  Warning: Could not process $alias_file - skipping"
        }
    done
    
    # Re-enable set -e
    set -e
    
    echo.success "  Found $alias_count aliases"
    return 0
}

function discover_scripts() {
    echo.info "🔍 Discovering scripts..."
    
    local script_count=0
    local bin_dir="$DOTFILES_ROOT/bin"
    
    [[ ! -d "$bin_dir" ]] && return 0
    
    for script_file in "$bin_dir"/*; do
        [[ ! -f "$script_file" || ! -x "$script_file" ]] && continue
        
        local script_name=$(basename "$script_file")
        
        # Skip help system files
        [[ "$script_name" =~ ^(dotfiles-help|help-) ]] && continue
        
        echo "  Processing: $script_name"
        
        # Determine category and description
        local description category
        if [[ "$script_name" == dotfiles-* ]]; then
            description="Dotfiles utility: ${script_name#dotfiles-}"
            category="commands"
        else
            description="Utility script: $script_name"
            category="scripts"
        fi
        
        # Create JSON entry
        local id="script-$script_name"
        local title=$(json_escape "$script_name")
        local synopsis=$(json_escape "$description")
        local source_path=$(json_escape "$script_file")
        
        # Use same approach as aliases - avoid here-docs in script discovery
        local json_entry="{
  \"id\": \"$id\",
  \"title\": \"$title\",
  \"category\": \"$category\",
  \"tags\": [\"script\", \"utility\"],
  \"synopsis\": \"$synopsis\",
  \"usage\": \"$script_name\",
  \"examples\": [
    {
      \"description\": \"Run the script\",
      \"command\": \"$script_name\"
    }
  ],
  \"sourcePath\": \"$source_path\",
  \"autogenerated\": true,
  \"lastModified\": \"$(date -Iseconds)\",
  \"icon\": \"🔧\",
  \"priority\": 70
}"
        
        JSON_ENTRIES+=("$json_entry")
        ((script_count++))
    done
    
    echo.success "  Found $script_count scripts"
    return 0
}

function discover_external_tools() {
    echo.info "🔍 Discovering external tools..."
    
    # Common tools that might be available
    local -a tools=(
        "git:Git version control:development:🔀"
        "fzf:Fuzzy finder:tools:🔍" 
        "rg:Ripgrep search:tools:🔎"
        "fd:Modern find alternative:tools:📂"
        "bat:Cat with syntax highlighting:tools:🦇"
        "eza:Modern ls alternative:tools:📋"
        "zoxide:Smart cd command:tools:📍"
        "htop:Process viewer:system:📊"
        "nvim:Neovim editor:development:✏️"
        "jq:JSON processor:tools:⚙️"
    )
    
    local tool_count=0
    
    for tool_spec in "${tools[@]}"; do
        IFS=':' read -r tool_name tool_desc tool_category tool_icon <<< "$tool_spec"
        
        if command -v "$tool_name" >/dev/null 2>&1; then
            echo "  Found tool: $tool_name"
            
            # Create JSON entry
            local id="tool-$tool_name"
            local title=$(json_escape "$tool_name")
            local synopsis=$(json_escape "$tool_desc")
            local source_path=$(json_escape "$(command -v "$tool_name")")
            
            # Use same approach - avoid here-docs
            local json_entry="{
  \"id\": \"$id\",
  \"title\": \"$title\",
  \"category\": \"$tool_category\",
  \"tags\": [\"tool\", \"external\"],
  \"synopsis\": \"$synopsis\",
  \"usage\": \"$tool_name [options]\",
  \"examples\": [
    {
      \"description\": \"Show help\",
      \"command\": \"$tool_name --help\"
    }
  ],
  \"sourcePath\": \"$source_path\",
  \"autogenerated\": true,
  \"lastModified\": \"$(date -Iseconds)\",
  \"icon\": \"$tool_icon\",
  \"priority\": 60
}"
            
            JSON_ENTRIES+=("$json_entry")
            ((tool_count++))
        fi
    done
    
    echo.success "  Found $tool_count external tools"
    return 0
}

function generate_manifest() {
    echo.info "📝 Generating help manifest..."
    
    local temp_file=$(mktemp)
    
    # Build JSON manifest
    cat > "$temp_file" << EOF
{
  "version": "1.0.0",
  "generated": "$(date -Iseconds)",
  "generator": "help-generator-fixed",
  "dotfilesVersion": "unknown",
  "totalEntries": ${#JSON_ENTRIES[@]},
  "entries": [
EOF
    
    # Add entries
    for i in "${!JSON_ENTRIES[@]}"; do
        if [[ $i -gt 0 ]]; then
            echo "," >> "$temp_file"
        fi
        echo "${JSON_ENTRIES[$i]}" >> "$temp_file"
    done
    
    cat >> "$temp_file" << 'EOF'
  ]
}
EOF
    
    # Validate JSON if jq available
    if command -v jq >/dev/null 2>&1; then
        if ! jq empty "$temp_file" 2>/dev/null; then
            echo.error "Generated invalid JSON manifest"
            echo.info "Debug: First few lines of generated JSON:"
            head -20 "$temp_file"
            rm -f "$temp_file"
            return 1
        fi
        
        # Pretty print
        jq '.' "$temp_file" > "$DOTFILES_HELP_MANIFEST"
    else
        mv "$temp_file" "$DOTFILES_HELP_MANIFEST"
    fi
    
    rm -f "$temp_file" 2>/dev/null || true
    
    echo.success "✨ Generated manifest with ${#JSON_ENTRIES[@]} entries"
    echo.info "   Saved to: $DOTFILES_HELP_MANIFEST"
    
    return 0
}

function show_stats() {
    echo.header "📊 Discovery Statistics"
    
    # Count by category
    declare -A category_counts=()
    
    for entry in "${JSON_ENTRIES[@]}"; do
        # Extract category from JSON entry
        if [[ "$entry" =~ \"category\":[[:space:]]*\"([^\"]+)\" ]]; then
            local category="${BASH_REMATCH[1]}"
            ((category_counts[$category]++))
        fi
    done
    
    echo "Entries by category:"
    for category in aliases commands scripts tools workflows references system development; do
        local count=${category_counts[$category]:-0}
        if [[ $count -gt 0 ]]; then
            echo "  • $category: $count"
        fi
    done
    
    echo
    echo "💡 Total entries: ${#JSON_ENTRIES[@]}"
    echo
}

# --- Main Function ---
function main() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            --force|-f)
                # Force flag accepted but not needed for this simple version
                shift
                ;;
            --help|-h)
                echo.header "Fixed Help Generator"
                echo "Usage: help-generator-fixed [--force]"
                exit 0
                ;;
            *)
                echo.error "Unknown option: $1"
                exit 1
                ;;
        esac
    done
    
    echo.header "🌸 Fixed Help Generator"
    
    # Run discovery
    discover_aliases
    discover_scripts
    discover_external_tools
    
    # Generate manifest
    if ! generate_manifest; then
        echo.error "Failed to generate manifest"
        return 1
    fi
    
    # Show stats
    show_stats
    
    echo.success "🎉 Help manifest generation complete!"
    echo.info "💡 Try: dotfiles help"
    echo
}

# Run if called directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
