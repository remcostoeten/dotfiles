#!/usr/bin/env bash

# Simplified Help Manifest Generator
# Basic version that generates help manifest without complex dependencies
# Part of the dotfiles management system

set -euo pipefail

# --- Setup ---
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
DOTFILES_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"
DOTFILES_UTILS="$DOTFILES_ROOT/utils"
DOTFILES_HELP_MANIFEST="$DOTFILES_UTILS/help_manifest.json"

# Ensure directories exist
mkdir -p "$DOTFILES_UTILS" "${DOTFILES_ROOT}/helpers/help" "${DOTFILES_ROOT}/docs/help" 2>/dev/null || true

# Simple color functions
function echo.error() { echo -e "\\033[0;31m✗\\033[0m $*"; }
function echo.success() { echo -e "\\033[0;32m✓\\033[0m $*"; }
function echo.warning() { echo -e "\\033[1;33m⚠\\033[0m $*"; }
function echo.info() { echo -e "\\033[0;36mℹ\\033[0m $*"; }
function echo.header() {
    echo -e "\\n\\033[1;34m════════════════════════════════════════════════════════════\\033[0m"
    echo -e "\\033[1;34m                    $*\\033[0m"
    echo -e "\\033[1;34m════════════════════════════════════════════════════════════\\033[0m\\n"
}

# --- State Variables ---
declare -a MANIFEST_ENTRIES=()

# --- Discovery Functions ---

function discover_aliases() {
    echo.info "🔍 Discovering aliases..."
    
    local alias_count=0
    local aliases_dir="$DOTFILES_ROOT/modules/aliases"
    
    [[ ! -d "$aliases_dir" ]] && return 0
    
    # Find all .aliases files
    for alias_file in "$aliases_dir"/*.aliases; do
        [[ ! -f "$alias_file" ]] && continue
        
        local file_base=$(basename "$alias_file" .aliases)
        
        echo "  Processing: $(basename "$alias_file")"
        
        # Parse aliases
        local current_alias=""
        local current_desc=""
        
        while IFS= read -r line; do
            # Skip empty lines
            [[ -z "$line" || "$line" =~ ^[[:space:]]*$ ]] && continue
            
            if [[ "$line" =~ ^#[[:space:]]*@alias[[:space:]]+(.+) ]]; then
                current_alias="${BASH_REMATCH[1]}"
            elif [[ "$line" =~ ^#[[:space:]]*@desc[[:space:]]+(.+) ]]; then
                current_desc="${BASH_REMATCH[1]}"
            elif [[ "$line" =~ ^[[:space:]]*alias[[:space:]]+([^=]+)=(.+) ]]; then
                local alias_name="${BASH_REMATCH[1]// /}"  
                local alias_command="${BASH_REMATCH[2]}"
                
                # Clean up command (remove quotes)
                alias_command="${alias_command#[\'\"]*}"
                alias_command="${alias_command%[\'\"]*}"
                
                # Use comment info if available
                local display_name="${current_alias:-$alias_name}"
                local description="${current_desc:-"Alias for: $alias_command"}"
                
                # Simple escaping for JSON (replace quotes with spaces to avoid issues)
                display_name="${display_name//\"/\\\"}"
                description="${description//\"/\\\"}"
                alias_command="${alias_command//\"/\\\"}"
                
                # Generate entry with simpler JSON
                cat >> "$temp_json" << EOF
{
  "id": "alias-$alias_name",
  "title": "$display_name",
  "category": "aliases",
  "tags": ["alias", "$file_base"],
  "synopsis": "$description",
  "usage": "$alias_name",
  "examples": [
    {
      "description": "Use the alias",
      "command": "$alias_name"
    }
  ],
  "sourcePath": "$alias_file",
  "autogenerated": true,
  "lastModified": "$(date -Iseconds)",
  "icon": "⚡",
  "priority": 80
}
EOF
                
                ((alias_count++))
                
                # Reset
                current_alias=""
                current_desc=""
            fi
        done < "$alias_file"
    done
    
    echo.success "  Found $alias_count aliases"
    return 0
}

function discover_scripts() {
    echo.info "🔍 Discovering scripts..."
    
    local script_count=0
    local bin_dir="$DOTFILES_ROOT/bin"
    
    [[ ! -d "$bin_dir" ]] && return 0
    
    for script_file in "$bin_dir"/*; do
        [[ ! -f "$script_file" || ! -x "$script_file" ]] && continue
        
        local script_name=$(basename "$script_file")
        
        # Skip help system files
        [[ "$script_name" =~ ^(dotfiles-help|help-) ]] && continue
        
        echo "  Processing: $script_name"
        
        # Simple description based on name
        local description=""
        local category="scripts"
        
        if [[ "$script_name" == dotfiles-* ]]; then
            description="Dotfiles utility: ${script_name#dotfiles-}"
            category="commands"
        else
            description="Utility script: $script_name"
        fi
        
        # Escape quotes
        description="${description//\\\"/\\\\\\\"}"
        
        local entry=$(cat <<EOF
{
  "id": "script-$script_name",
  "title": "$script_name",
  "category": "$category",
  "tags": ["script", "utility"],
  "synopsis": "$description",
  "usage": "$script_name",
  "examples": [
    {
      "description": "Run the script",
      "command": "$script_name"
    }
  ],
  "sourcePath": "$script_file",
  "autogenerated": true,
  "lastModified": "$(date -Iseconds)",
  "icon": "🔧",
  "priority": 70
}
EOF
        )
        
        MANIFEST_ENTRIES+=("$entry")
        ((script_count++))
    done
    
    echo.success "  Found $script_count scripts"
    return 0
}

function discover_external_tools() {
    echo.info "🔍 Discovering external tools..."
    
    # Common tools that might be available
    local -a tools=(
        "git:Git version control:development:🔀"
        "fzf:Fuzzy finder:tools:🔍" 
        "rg:Ripgrep search:tools:🔎"
        "fd:Modern find alternative:tools:📂"
        "bat:Cat with syntax highlighting:tools:🦇"
        "eza:Modern ls alternative:tools:📋"
        "zoxide:Smart cd command:tools:📍"
        "htop:Process viewer:system:📊"
        "nvim:Neovim editor:development:✏️"
        "jq:JSON processor:tools:⚙️"
    )
    
    local tool_count=0
    
    for tool_spec in "${tools[@]}"; do
        IFS=':' read -r tool_name tool_desc tool_category tool_icon <<< "$tool_spec"
        
        if command -v "$tool_name" >/dev/null 2>&1; then
            echo "  Found tool: $tool_name"
            
            # Escape quotes
            tool_desc="${tool_desc//\\\"/\\\\\\\"}"
            
            local entry=$(cat <<EOF
{
  "id": "tool-$tool_name",
  "title": "$tool_name",
  "category": "$tool_category",
  "tags": ["tool", "external"],
  "synopsis": "$tool_desc",
  "usage": "$tool_name [options]",
  "examples": [
    {
      "description": "Show help",
      "command": "$tool_name --help"
    }
  ],
  "sourcePath": "$(command -v "$tool_name")",
  "autogenerated": true,
  "lastModified": "$(date -Iseconds)",
  "icon": "$tool_icon",
  "priority": 60
}
EOF
            )
            
            MANIFEST_ENTRIES+=("$entry")
            ((tool_count++))
        fi
    done
    
    echo.success "  Found $tool_count external tools"
    return 0
}

function generate_manifest() {
    echo.info "📝 Generating help manifest..."
    
    local temp_file=$(mktemp)
    
    # Build JSON manifest
    cat > "$temp_file" << EOF
{
  "version": "1.0.0",
  "generated": "$(date -Iseconds)",
  "generator": "help-generator-simple",
  "dotfilesVersion": "unknown",
  "totalEntries": ${#MANIFEST_ENTRIES[@]},
  "entries": [
EOF
    
    # Add entries
    local first=true
    for entry in "${MANIFEST_ENTRIES[@]}"; do
        if [[ "$first" == true ]]; then
            first=false
        else
            echo "," >> "$temp_file"
        fi
        echo -n "$entry" >> "$temp_file"
    done
    
    cat >> "$temp_file" << EOF

  ]
}
EOF
    
    # Validate JSON if jq available
    if command -v jq >/dev/null 2>&1; then
        if ! jq empty "$temp_file" 2>/dev/null; then
            echo.error "Generated invalid JSON manifest"
            rm -f "$temp_file"
            return 1
        fi
        
        # Pretty print
        jq '.' "$temp_file" > "$DOTFILES_HELP_MANIFEST"
    else
        mv "$temp_file" "$DOTFILES_HELP_MANIFEST"
    fi
    
    rm -f "$temp_file" 2>/dev/null || true
    
    echo.success "✨ Generated manifest with ${#MANIFEST_ENTRIES[@]} entries"
    echo.info "   Saved to: $DOTFILES_HELP_MANIFEST"
    
    return 0
}

function show_stats() {
    echo.header "📊 Discovery Statistics"
    
    # Count by category
    declare -A category_counts=()
    
    for entry in "${MANIFEST_ENTRIES[@]}"; do
        local category
        if category=$(echo "$entry" | grep -o '"category": "[^"]*"' | cut -d'"' -f4); then
            ((category_counts[$category]++))
        fi
    done
    
    echo "Entries by category:"
    for category in aliases commands scripts tools workflows references system development; do
        local count=${category_counts[$category]:-0}
        if [[ $count -gt 0 ]]; then
            echo "  • $category: $count"
        fi
    done
    
    echo
    echo "💡 Total entries: ${#MANIFEST_ENTRIES[@]}"
    echo
}

# --- Main Function ---
function main() {
    local force=false
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --force|-f)
                force=true
                shift
                ;;
            --help|-h)
                echo.header "Simple Help Generator"
                echo "Usage: help-generator-simple [--force]"
                exit 0
                ;;
            *)
                echo.error "Unknown option: $1"
                exit 1
                ;;
        esac
    done
    
    echo.header "🌸 Simple Help Generator"
    
    # Run discovery
    discover_aliases
    discover_scripts
    discover_external_tools
    
    # Generate manifest
    if ! generate_manifest; then
        echo.error "Failed to generate manifest"
        return 1
    fi
    
    # Show stats
    show_stats
    
    echo.success "🎉 Help manifest generation complete!"
    echo.info "💡 Try: dotfiles help"
    echo
}

# Run if called directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
