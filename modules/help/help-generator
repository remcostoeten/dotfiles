#!/usr/bin/env bash

# Help Manifest Generator
# Auto-discovers and catalogues all help-worthy content in dotfiles
# Part of the dotfiles management system

set -euo pipefail

# --- Setup ---
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
DOTFILES_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"

# Source required modules
source "$DOTFILES_ROOT/core/_env" 2>/dev/null || { echo "ERROR: Cannot load environment" >&2; exit 1; }
source "$DOTFILES_ROOT/core/_colors" 2>/dev/null || { echo "ERROR: Cannot load colors" >&2; exit 1; }
source "$DOTFILES_ROOT/core/_help_constants" 2>/dev/null || { echo "ERROR: Cannot load help constants" >&2; exit 1; }

# --- State Variables ---
MANIFEST_ENTRIES=()
VERBOSE_MODE=false
FORCE_REGENERATE=false

# --- Core Discovery Functions ---

function discover_aliases() {
    echo.info "üîç Discovering aliases..."
    
    local alias_count=0
    
    # Find all .aliases files
    while IFS= read -r alias_file; do
        [[ ! -f "$alias_file" ]] && continue
        
        local category=$(basename "$(dirname "$alias_file")")
        local file_base=$(basename "$alias_file" .aliases)
        
        echo.debug "  Processing: $alias_file"
        
        # Parse aliases with @alias/@desc comments
        local current_alias=""
        local current_desc=""
        
        while IFS= read -r line; do
            # Skip empty lines and pure comments
            [[ -z "$line" || "$line" =~ ^[[:space:]]*$ ]] && continue
            
            if [[ "$line" =~ ^#[[:space:]]*@alias[[:space:]]+(.+) ]]; then
                current_alias="${BASH_REMATCH[1]}"
            elif [[ "$line" =~ ^#[[:space:]]*@desc[[:space:]]+(.+) ]]; then
                current_desc="${BASH_REMATCH[1]}"
            elif [[ "$line" =~ ^[[:space:]]*alias[[:space:]]+([^=]+)=(.+) ]]; then
                local alias_name="${BASH_REMATCH[1]// /}"  
                local alias_command="${BASH_REMATCH[2]}"
                
                # Clean up command
                alias_command="${alias_command#[\'\"]}"
                alias_command="${alias_command%[\'\"]}"
                
                # Use comment-based info if available, otherwise extract from alias
                local display_name="${current_alias:-$alias_name}"
                local description="${current_desc:-"Execute: $alias_command"}"
                
                # Generate help entry
                local entry=$(cat <<EOF
{
  "id": "alias-$alias_name",
  "title": "$display_name",
  "category": "aliases",
  "tags": ["alias", "$file_base", "$(echo $alias_command | cut -d' ' -f1)"],
  "synopsis": "$description",
  "usage": "$alias_name",
  "examples": [
    {
      "description": "Use the alias",
      "command": "$alias_name"
    }
  ],
  "sourcePath": "$alias_file",
  "autogenerated": true,
  "lastModified": "$(date -Iseconds)",
  "icon": "‚ö°",
  "priority": 80,
  "aliasCommand": "$alias_command",
  "aliasCategory": "$file_base"
}
EOF
                )
                
                MANIFEST_ENTRIES+=("$entry")
                ((alias_count++))
                
                # Reset comment state
                current_alias=""
                current_desc=""
            fi
        done < "$alias_file"
        
    done < <(find "$DOTFILES_ROOT/modules/aliases" -name "*.aliases" -type f 2>/dev/null | sort)
    
    echo.success "  Found $alias_count aliases"
    return 0
}

function discover_bin_scripts() {
    echo.info "üîç Discovering bin scripts..."
    
    local script_count=0
    
    # Scan all executable files in bin/
    while IFS= read -r script_file; do
        [[ ! -x "$script_file" ]] && continue
        
        local script_name=$(basename "$script_file")
        
        # Skip certain internal files
        case "$script_name" in
            dotfiles-help|help-*) continue ;;
        esac
        
        echo.debug "  Processing: $script_name"
        
        # Look for help comments in first 20 lines
        local description=""
        local usage=""
        local examples=()
        
        while IFS= read -r line && [[ ${#examples[@]} -lt 3 ]]; do
            if [[ "$line" =~ ^#[[:space:]]*@desc[[:space:]]+(.+) ]]; then
                description="${BASH_REMATCH[1]}"
            elif [[ "$line" =~ ^#[[:space:]]*@usage[[:space:]]+(.+) ]]; then
                usage="${BASH_REMATCH[1]}"
            elif [[ "$line" =~ ^#[[:space:]]*@example[[:space:]]+(.+) ]]; then
                examples+=("${BASH_REMATCH[1]}")
            fi
        done < <(head -n 20 "$script_file")
        
        # Generate default description if none found
        if [[ -z "$description" ]]; then
            # Try to infer from script name
            case "$script_name" in
                dotfiles-*)
                    description="Dotfiles utility: ${script_name#dotfiles-}"
                    ;;
                *)
                    description="Utility script: $script_name"
                    ;;
            esac
        fi
        
        # Build examples array
        local examples_json="[]"
        if [[ ${#examples[@]} -gt 0 ]]; then
            local examples_str=""
            for example in "${examples[@]}"; do
                if [[ -n "$examples_str" ]]; then
                    examples_str+=", "
                fi
                examples_str+="{\"description\": \"Example usage\", \"command\": \"$example\"}"
            done
            examples_json="[$examples_str]"
        else
            examples_json="[{\"description\": \"Run the script\", \"command\": \"$script_name\"}]"
        fi
        
        # Determine category
        local category="scripts"
        if [[ "$script_name" == dotfiles-* ]]; then
            category="commands"
        fi
        
        local entry=$(cat <<EOF
{
  "id": "script-$script_name",
  "title": "$script_name",
  "category": "$category",
  "tags": ["script", "utility", "$(echo $script_name | tr '-' ' ')"],
  "synopsis": "$description",
  "usage": "${usage:-$script_name}",
  "examples": $examples_json,
  "sourcePath": "$script_file",
  "autogenerated": true,
  "lastModified": "$(date -Iseconds)",
  "icon": "üîß",
  "priority": 70
}
EOF
        )
        
        MANIFEST_ENTRIES+=("$entry")
        ((script_count++))
        
    done < <(find "$DOTFILES_ROOT/bin" -type f -executable 2>/dev/null | sort)
    
    echo.success "  Found $script_count scripts"
    return 0
}

function discover_dotfiles_commands() {
    echo.info "üîç Discovering dotfiles commands..."
    
    local dotfiles_cmd="$DOTFILES_ROOT/bin/dotfiles"
    [[ ! -f "$dotfiles_cmd" ]] && return 0
    
    # Extract function definitions that look like commands
    local cmd_count=0
    
    # Parse main dotfiles command file for function definitions
    while IFS= read -r line; do
        if [[ "$line" =~ ^function[[:space:]]+dotfiles_([a-z_]+)\(\) ]]; then
            local cmd_name="${BASH_REMATCH[1]}"
            local cmd_title="${cmd_name//_/ }"
            cmd_title="${cmd_title^}"  # Capitalize first letter
            
            echo.debug "  Found command: $cmd_name"
            
            local entry=$(cat <<EOF
{
  "id": "cmd-$cmd_name",
  "title": "dotfiles $cmd_name",
  "category": "commands",
  "tags": ["dotfiles", "command", "$cmd_name"],
  "synopsis": "$cmd_title command",
  "usage": "dotfiles $cmd_name",
  "examples": [
    {
      "description": "Execute $cmd_title",
      "command": "dotfiles $cmd_name"
    }
  ],
  "sourcePath": "$dotfiles_cmd",
  "autogenerated": true,
  "lastModified": "$(date -Iseconds)",
  "icon": "‚ö°",
  "priority": 90
}
EOF
            )
            
            MANIFEST_ENTRIES+=("$entry")
            ((cmd_count++))
        fi
    done < "$dotfiles_cmd"
    
    echo.success "  Found $cmd_count dotfiles commands"
    return 0
}

function discover_external_tools() {
    echo.info "üîç Discovering external tools..."
    
    # Common development tools that users might have
    local -a tools=(
        "git:Git version control:development:üîÄ"
        "fzf:Fuzzy finder:tools:üîç" 
        "rg:Ripgrep search:tools:üîé"
        "fd:Modern find alternative:tools:üìÇ"
        "bat:Cat with syntax highlighting:tools:ü¶á"
        "eza:Modern ls alternative:tools:üìã"
        "zoxide:Smart cd command:tools:üìç"
        "htop:Process viewer:system:üìä"
        "nvim:Neovim editor:development:‚úèÔ∏è"
        "code:VS Code editor:development:üíª"
        "docker:Container platform:development:üê≥"
        "npm:Node package manager:development:üì¶"
        "python:Python interpreter:development:üêç"
        "node:Node.js runtime:development:üü¢"
        "curl:HTTP client:tools:üåê"
        "jq:JSON processor:tools:‚öôÔ∏è"
    )
    
    local tool_count=0
    
    for tool_spec in "${tools[@]}"; do
        IFS=':' read -r tool_name tool_desc tool_category tool_icon <<< "$tool_spec"
        
        if command -v "$tool_name" >/dev/null 2>&1; then
            echo.debug "  Found tool: $tool_name"
            
            local entry=$(cat <<EOF
{
  "id": "tool-$tool_name",
  "title": "$tool_name",
  "category": "$tool_category",
  "tags": ["tool", "external", "$tool_category"],
  "synopsis": "$tool_desc",
  "usage": "$tool_name [options]",
  "examples": [
    {
      "description": "Show help",
      "command": "$tool_name --help"
    }
  ],
  "sourcePath": "$(command -v "$tool_name")",
  "autogenerated": true,
  "lastModified": "$(date -Iseconds)",
  "icon": "$tool_icon",
  "priority": 60
}
EOF
            )
            
            MANIFEST_ENTRIES+=("$entry")
            ((tool_count++))
        fi
    done
    
    echo.success "  Found $tool_count external tools"
    return 0
}

function discover_manual_entries() {
    echo.info "üîç Discovering manual help entries..."
    
    [[ ! -d "$DOTFILES_HELP_DOCS" ]] && return 0
    
    local manual_count=0
    
    # Find markdown files in docs/help/
    while IFS= read -r doc_file; do
        [[ ! -f "$doc_file" ]] && continue
        
        echo.debug "  Processing manual entry: $(basename "$doc_file")"
        
        # Parse YAML frontmatter if present
        local in_frontmatter=false
        local title=""
        local category=""
        local synopsis=""
        local tags=()
        
        while IFS= read -r line; do
            if [[ "$line" == "---" ]]; then
                if [[ "$in_frontmatter" == false ]]; then
                    in_frontmatter=true
                    continue
                else
                    break  # End of frontmatter
                fi
            fi
            
            if [[ "$in_frontmatter" == true ]]; then
                if [[ "$line" =~ ^title:[[:space:]]*(.+)$ ]]; then
                    title="${BASH_REMATCH[1]}"
                elif [[ "$line" =~ ^category:[[:space:]]*(.+)$ ]]; then
                    category="${BASH_REMATCH[1]}"
                elif [[ "$line" =~ ^synopsis:[[:space:]]*(.+)$ ]]; then
                    synopsis="${BASH_REMATCH[1]}"
                elif [[ "$line" =~ ^tags:[[:space:]]*\[(.+)\]$ ]]; then
                    IFS=',' read -ra tag_array <<< "${BASH_REMATCH[1]}"
                    tags=("${tag_array[@]}")
                fi
            fi
        done < "$doc_file"
        
        # Use filename as fallback
        if [[ -z "$title" ]]; then
            title=$(basename "$doc_file" .md)
            title="${title//-/ }"
            title="${title^}"
        fi
        
        local file_id="manual-$(basename "$doc_file" .md)"
        local tags_json="[\"manual\""
        for tag in "${tags[@]}"; do
            tags_json+=", \"$(echo "$tag" | xargs)\""  # xargs trims whitespace
        done
        tags_json+="]"
        
        local entry=$(cat <<EOF
{
  "id": "$file_id",
  "title": "$title",
  "category": "${category:-references}",
  "tags": $tags_json,
  "synopsis": "${synopsis:-"Manual help entry: $title"}",
  "usage": "dotfiles help $file_id",
  "sourcePath": "$doc_file",
  "autogenerated": false,
  "lastModified": "$(date -Iseconds)",
  "icon": "üìñ",
  "priority": 50
}
EOF
        )
        
        MANIFEST_ENTRIES+=("$entry")
        ((manual_count++))
        
    done < <(find "$DOTFILES_HELP_DOCS" -name "*.md" -type f 2>/dev/null | sort)
    
    echo.success "  Found $manual_count manual entries"
    return 0
}

function generate_manifest() {
    echo.info "üìù Generating help manifest..."
    
    local manifest_file="$DOTFILES_HELP_MANIFEST"
    local temp_file=$(mktemp)
    
    # Build JSON manifest
    cat > "$temp_file" << EOF
{
  "version": "$DOTFILES_HELP_VERSION",
  "generated": "$(date -Iseconds)",
  "generator": "help-generator",
  "dotfilesVersion": "${DOTFILES_VERSION:-unknown}",
  "totalEntries": ${#MANIFEST_ENTRIES[@]},
  "entries": [
EOF
    
    # Add entries
    local first=true
    for entry in "${MANIFEST_ENTRIES[@]}"; do
        if [[ "$first" == true ]]; then
            first=false
        else
            echo "," >> "$temp_file"
        fi
        echo -n "$entry" >> "$temp_file"
    done
    
    cat >> "$temp_file" << EOF

  ]
}
EOF
    
    # Validate JSON
    if command -v jq >/dev/null 2>&1; then
        if ! jq empty "$temp_file" 2>/dev/null; then
            echo.error "Generated invalid JSON manifest"
            rm -f "$temp_file"
            return 1
        fi
        
        # Pretty print
        jq '.' "$temp_file" > "$manifest_file"
    else
        mv "$temp_file" "$manifest_file"
    fi
    
    rm -f "$temp_file"
    
    echo.success "‚ú® Generated manifest with ${#MANIFEST_ENTRIES[@]} entries"
    echo.info "   Saved to: $manifest_file"
    
    return 0
}

function show_stats() {
    echo.header "üìä Discovery Statistics"
    
    # Count by category
    declare -A category_counts=()
    
    for entry in "${MANIFEST_ENTRIES[@]}"; do
        local category
        if category=$(echo "$entry" | grep -o '"category": "[^"]*"' | cut -d'"' -f4); then
            ((category_counts[$category]++))
        fi
    done
    
    echo.cyan "Entries by category:"
    for category in aliases commands scripts tools workflows references system development; do
        local count=${category_counts[$category]:-0}
        if [[ $count -gt 0 ]]; then
            local icon=$(help.get_category_icon "$category")
            echo.pastel_purple "  $icon ${HELP_CATEGORIES[$category]}: $count"
        fi
    done
    
    echo
    echo.pastel_yellow "üí° Total entries: ${#MANIFEST_ENTRIES[@]}"
    echo.pastel_cyan "üìÅ Manifest: $DOTFILES_HELP_MANIFEST"
    echo
}

# --- Main Function ---
function main() {
    local regenerate_needed=false
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --verbose|-v)
                VERBOSE_MODE=true
                export DOTFILES_VERBOSE=1
                shift
                ;;
            --force|-f)
                FORCE_REGENERATE=true
                shift
                ;;
            --help|-h)
                echo.header "Help Manifest Generator"
                echo
                echo.cyan "Usage: help-generator [options]"
                echo
                echo "Options:"
                echo "  --verbose, -v    Enable verbose output"
                echo "  --force, -f      Force regeneration even if up-to-date"
                echo "  --help, -h       Show this help"
                echo
                exit 0
                ;;
            *)
                echo.error "Unknown option: $1"
                exit 1
                ;;
        esac
    done
    
    echo.header "üå∏ Dotfiles Help Manifest Generator"
    echo.pastel_purple "Discovering and cataloguing all help content..."
    echo
    
    # Check if regeneration is needed
    if [[ "$FORCE_REGENERATE" != true ]] && [[ -f "$DOTFILES_HELP_MANIFEST" ]]; then
        local manifest_age=$(help.get_manifest_age)
        if [[ $manifest_age -lt 3600 ]]; then  # Less than 1 hour old
            echo.info "Manifest is recent (${manifest_age}s old), use --force to regenerate"
            return 0
        fi
    fi
    
    # Run discovery
    discover_aliases
    discover_bin_scripts  
    discover_dotfiles_commands
    discover_external_tools
    discover_manual_entries
    
    # Generate manifest
    if ! generate_manifest; then
        echo.error "Failed to generate manifest"
        return 1
    fi
    
    # Show statistics
    show_stats
    
    echo.success "üéâ Help manifest generation complete!"
    echo.info "üí° Try: dotfiles help"
    echo
}

# Run if called directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
